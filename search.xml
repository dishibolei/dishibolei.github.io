<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IOS应用安全-HTTP/HTTPS网络安全(二)]]></title>
    <url>%2F2017%2F05%2F15%2Fhttps-safe-2%2F</url>
    <content type="text"><![CDATA[导读 本文主要讲解IOS中ATS相关的配置说明和使用AFNetworking框架来实现证书验证的方法。讲解了AFNetworking各个配置试用的场景和注意点。 ATSIOS9之后，苹果开启了App Transport Security（简称ATS）特性,即禁止HTTP请求，必须使用支持TLS1.2的HTTPS请求。但是也支持在Info.plist中做一些配置，来做缓冲。需要在info.plist中加入App Transport Security Settings字段。 plist里面的结构如下 123456789101112131415NSAppTransportSecurity : Dictionary &#123; NSAllowsArbitraryLoads : Boolean NSAllowsArbitraryLoadsForMedia : Boolean NSAllowsArbitraryLoadsInWebContent : Boolean NSAllowsLocalNetworking : Boolean NSExceptionDomains : Dictionary &#123; &lt;domain-name-string&gt; : Dictionary &#123; NSIncludesSubdomains : Boolean NSExceptionAllowsInsecureHTTPLoads : Boolean NSExceptionMinimumTLSVersion : String NSExceptionRequiresForwardSecrecy : Boolean // Default value is YES NSRequiresCertificateTransparency : Boolean &#125; &#125;&#125; ATS整体配置（NSAllowsArbitraryLoads） 配置ATS生效或不生效 在App Transport Security Settings字段下加入Allow Arbitrary Loads，或NSAllowsArbitraryLoads，配置为NO。PS：如果要禁用则为YES。但是如果配置为YES会导致审核失败，需要单独向APPStrore申诉说明。 配置web(H5)访问限制生效或不生效 在App Transport Security Settings字段下加入Allow Arbitrary Loads in Web Content或NSAllowsArbitraryLoadsInWebContent，默认配置生效为NO。如果要容许访问任意web网页内容，配置为YES。但是如果配置为YES会导致审核失败，需要单独向APPStrore申诉说明。 配置多媒体访问限制生效或不生效 在App Transport Security Settings字段下加入Allow Arbitrary Loads in Web Content，默认配置生效为NO。设置YES，容许访问通过AVFoundation框架访问媒体内容。 ATS根据域名配置（Exception Domains）在App Transport Security Settings字段下加入Exception Domains或NSExceptionDomains,系统优先响应NSExceptionDomains中的配置。比如之前设置NSAllowsArbitraryLoadsInMedia为 YES，然而NSExceptionDomain所代表的域名，如果没有特殊配置，依然默认不能访问不安全的媒体内容。 加入域名配置 在Exception Domains下，添加字典。其中key为域名的名称，比如baidu.com。 容许访问HTTP 在步骤1对应的域名字典下，加入字段NSExceptionAllowsInsecureHTTPLoads.默认为NO，如果设置YES，则容许访问HTTP 容许TLS支持非正向保密算法（Perfect Forward Secrecy） 在步骤1对应的域名字典下，加入字段NSExceptionRequiresForwardSecrecy.默认为YES。如果设置为NO，则支持非正向保密的加密算法。 正向保密算法（Forward Secrecy），指如果通信密钥泄露，使用FS算法，可以保证这个密钥泄露只会影响之后的加密数据，之前的加密数据无法解密。主要防止攻击者保存之前的数据，等到私钥泄露之后再解密数据。这个算法的基础是基于椭圆曲线向前保密的秘钥交换算法ECDHE（Elliptic Curve Diffie-Hellman Ephemeral）。这些算法有： 1234567891011TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHATLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHATLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 如果设置为NO，则非正向保密算法，有下面几种： 123456TLS_RSA_WITH_AES_256_GCM_SHA384TLS_RSA_WITH_AES_128_GCM_SHA256TLS_RSA_WITH_AES_256_CBC_SHA256TLS_RSA_WITH_AES_256_CBC_SHATLS_RSA_WITH_AES_128_CBC_SHA256TLS_RSA_WITH_AES_128_CBC_SHA 具体原理参考TLS/SSL 高级进阶。 容许支持低版本的TLS算法。 在步骤1对应的域名字典下，加入字段NSExceptionMinimumTLSVersion。值为对应的支持的最低版本。包含下面值 123TLSv1.0TLSv1.1TLSv1.2 包含域名下的所有子域名。 在步骤1对应的域名字典下，加入字段NSIncludesSubdomains。默认为NO。如果配置为YES则包含域名下的所有子域名。 开启Certificate Transparency 在步骤1对应的域名字典下，加入字段NSRequiresCertificateTransparency,这个默认为NO.如果设为YES，则开启Certificate Transparency。这个是IETF启动的一个开源项目，目的是进一步验证证书是否安全。个人觉得没什么用，没必要开启。 ATS各种字段含义说明主要的几个key： NSAllowsArbitraryLoads 默认NO。如果设置为YES，则不生效ATS规则。但是配置在NSExceptionDomains里面的规则，按照里面的规则生效。配置为YES，提交APP Strore需要说明 NSAllowsArbitraryLoadsForMedia 默认NO.如果设置为YES，那使用AVFoundation加载资源不生效ATS。 NSAllowsArbitraryLoadsInWebContent 默认NO.如果设置为YES.使用webview加载的页面资源不生效ATS。 NSExceptionDomains 用于单独配置其他域名ATS策略的键。值应该是字典类型。 下面是NSExceptionDomains相关的key NSIncludesSubdomains 默认NO。如果设置为YES，则生效此域名下的子域名 NSExceptionAllowsInsecureHTTPLoads 默认NO。如果设置为YES，则容许HTTP请求。设置YES，在审核时需要提供说明。 NSExceptionMinimumTLSVersion 默认TLSv1.2。可以设置为：TLSv1.0、TLSv1.1。在审核时需要提供说明 NSExceptionRequiresForwardSecrecy 默认YES。设置为NO标示不支持正向保密。 NSRequiresCertificateTransparency 默认NO。如果设置为YES，开启Certificate Transparency。 上面的是方便本人查找，详细设置case也可以参考[ATS 官方文档] (https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35)。目前过渡阶段最多出现的是第三方不兼容的问题+不支持NSExceptionRequiresForwardSecrecy+TLS版本不到1.2+h5访问的链接不支持ATS。按照要求配置就可以了，最重要的是推动第三方和自己后台使用HTTPS。自己的后台如果要求不高，可以用自制证书。 推荐的一个配置： 自己的域名使用最安全的方案，防止被苹果拒绝。第三方可以按照需求配置，但是审核时也建议进一步说明。 123456789101112NSAppTransportSecurity NSExceptionDomains &quot;domain-i-control.example.com&quot; // 后台的域名 NSExceptionAllowsInsecureHTTPLoads = NO //不容许HTTP NSExceptionRequiresForwardSecrecy = YES //支持正向加密 NSExceptionMinimumTLSVersion = &quot;TLSv1.2&quot; //使用1.2版本 NSIncludesSubdomains = YES //包含子域名 &quot;other-domain-i-control.example.com&quot; //部分不支持的第三方域名 NSExceptionAllowsInsecureHTTPLoads = NO //支持http NSExceptionRequiresForwardSecrecy = YES //不支持正向加密 NSExceptionMinimumTLSVersion = &quot;TLSv1.0&quot; //第三方支持的TLS版本 NSAllowsArbitraryLoads = NO 使用AFNetworking配置HTTPS安全AFNetworking是最常用的网络框架。所以以这个为基础说明一些配置信息。本人是使用2.6版本的。3.x版本和2.6相比安全验证的逻辑没有变化，可以参考。2.6之前的版本，建议所有配置项显示配置，不要用默认配置（因为有个版本有漏洞，默认不校验域名）。下面先讲解下配置参数，清楚之后再讲解代码实现。 AFSecurityPolicy说明AFNetworking使用AFSecurityPolicy类来管理安全策略。 主要的属性和方法： 12345@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode; //证书验证的策略@property (nonatomic, assign) BOOL allowInvalidCertificates; //是否容许无效的证书@property (nonatomic, assign) BOOL validatesDomainName; //是否验证证书的域名@property (nonatomic, strong, nullable) NSArray *pinnedCertificates; //app自己导入的证书文件，默认情况下主bundle里面的.cer文件都会导入到这个数组里。 validatesDomainName 说明是否容许证书包含的域名和实际访问的域名不匹配，默认为YES。采用的策略为： 如果validatesDomainName == YES，则开启域名验证。如果allowInvalidCertificates == NO，则不容许所用的证书里面的域名和实际域名不一致。如果allowInvalidCertificates == YES，则忽略域名验证，直接按照AFSSLPinningMode方式验证。 如果validatesDomainName == NO,则不对证书做域名验证。 allowInvalidCertificates 说明是否容许无效证书，默认为NO。采用的策略为： 如果allowInvalidCertificates == YES，则容许使用自制证书，或容许CA颁发的证书或系统信任的第三方证书（比如手动信任Charles证书）无效（包括域名无效和超过有效期） 如果allowInvalidCertificates == NO，那无法使用自制证书，且不容许CA颁发的证书或系统信任的第三方证书（比如手动信任Charles证书）超过有效期。如果配置了validatesDomainName == YES，则容许证书的域名不匹配，否则也不容许域名不匹配。 SSLPinningMode 说明证书文件实体验证策略，默认为AFSSLPinningModeNone。AFSSLPinningMode包括的值为： 123456typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, AFSSLPinningModePublicKey, AFSSLPinningModeCertificate &#125;; AFSSLPinningModeNone。AFNetworking默认配置模式。采用的策略为： 如果容许无效证书（allowInvalidCertificates == YES），则直接返回验证成功（YES） 如果不容许无效证书（allowInvalidCertificates == YES），则验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。 AFSSLPinningModePublicKey。验证证书公钥模式。采用的策略为： 如果容许无效证书（allowInvalidCertificates == YES），则比对服务端发来的证书链中的公钥和自己加入的所有证书的的公钥是否匹配，只要有一个证书匹配就返回成功。 如果不容许无效证书（allowInvalidCertificates == YES），则先验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。验证通过后，则比对服务端发来的证书链中的公钥和自己加入的所有证书的的公钥是否匹配，只要有一个证书匹配就返回成功。 AFSSLPinningModeCertificate。证书完全匹配模式。采用的策略为： 如果容许无效证书（allowInvalidCertificates == YES），则将自己导入的所有证书作为锚点，判断服务端是否有效。如果有效，判断服务端证书链中的证书中，是否有证书包含在导入的证书里（使用二进制比较，也就是必须完全一样）。 如果不容许无效证书（allowInvalidCertificates == YES），则先验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。验证通过后，则将自己导入的所有证书作为锚点，判断服务端证书是否有效。如果有效，判断服务端证书链中的证书中，是否有证书包含在导入的证书里（使用二进制比较，也就是必须完全一样）。 上面的比较绕，其实就是三个配置的组合。下面把这几种组合起来，看看验证了什么，使用于什么策略。其中AC表示allowInvalidCertificates，VD表示validatesDomainName。需要的可以去查这个表来决定方案。 场景 mode AC VD 验证策略 适用场景 不适用场景 1 None NO YES 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期3.验证证书域名是否匹配 1.AF默认的安全策略2.对于安全有基础的要求3.使用CA机构颁发的证书 1.使用自制证书的 2.不容许使用第三方抓包工具抓包的应用 2 None NO NO 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期 1.证书是正规CA颁发的。但是使用的域名不是证书中的域名 1.存在风险，会导致攻击方使用自己的合法的CA证书进行攻击 2.使用自制证书的 3.不容许使用第三方抓包工具抓包的应用 3 None YES YES /NO 不对证书做任何验证 请勿使用这儿配置。 1.对安全没有要求的 1.对安全有要求的 4 PublicKey NO YES 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期 3.验证证书域名是否匹配4.验证证书和埋入的证书的公钥是否一致 1.证书是正规CA颁发的。2.对安全有比较高的需求 3.需要本地APP中导入证书 4.禁止第三方工具抓包 5.证书过期后只要保证公钥一致，就可以保证请求有效 1.使用自制证书的2.害怕攻击者拿到私钥或公钥文件，伪造证书（概率极低，因为需要CA机构再签发） 3.证书过期需要更换，但是新旧证书公钥不同 5 PublicKey NO NO 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书 2.验证证书是否过期 3.验证证书和埋入的证书的公钥是否一致 1.证书是正规CA颁发的。 2.需要本地APP中导入证书 3.禁止第三方工具抓包 4.使用的域名和证书域名不一致 5.证书过期后只要保证公钥一致，就可以保证请求有效 1.使用自制证书的 2.害怕攻击者拿到私钥或公钥文件，伪造证书（概率极低，因为需要CA机构再签发） 3.证书过期需要更换，但是新旧证书公钥不同 6 PublicKey YES YES/NO 1.验证证书和埋入的证书公钥是否一致 1.使用自制证书 2.需要本地APP中导入证书 3.禁止第三方工具抓包 4.不需要关心证书的有效期 1.攻击者可以拿到私钥或公钥文件，伪造证书。相对于场景4和5，更容易攻击一些。 2.攻击者可以用不在有效期的证书对进行攻击 7 Certificate NO YES 1.验证证书域名是否匹配2.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书3.验证证书是否过期4.验证证书和埋入的证书是否完全一致 1.证书是正规CA颁发的。2.对安全有最高的需求3.需要本地APP中导入证书4.禁止第三方工具抓包 1.需要考虑证书更新的场景 2.证书如果失效，客户端网络请求将会失效 3.自制证书 8 Certificate NO NO 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期3.验证证书和埋入的证书是否完全一致 1.证书是正规CA颁发的。2.对安全有最高的需求3.需要本地APP中导入证书4.禁止第三方工具抓包5.证书域名和实际域名不一致 1.需要考虑证书更新的场景2.证书如果失效，客户端网络请求将会失效3.自制证书4.攻击者拿到公私钥的前提下，可以利用不校验域名，攻击或重定向其他域名。 9 Certificate YES YES 1.验证证书的域名是否匹配？ 2.验证证书是否过期？ 3.验证证书和埋入的证书是否完全一致 1.使用自制证书2.需要本地APP中导入证书3.禁止中间人攻击 1.需要考虑证书更新的场景2.证书如果失效，客户端网络请求将会失效3.无法作废不安全的证书。在攻击者拿到公私钥的前提下,可以监听数据。 10 Certificate YES NO 1.验证证书是否过期？2.验证证书和埋入的证书是否完全一致 1.使用自制证书2.需要本地APP中导入证书3.禁止禁止中间人攻击 1.需要考虑证书更新的场景2.证书如果失效，客户端网络请求将会失效3.攻击者拿到公私钥的前提下，可以利用不校验域名，定位到其他域名。 相关问题下面是一些疑问： 如何选择合适的方案? 建议对安全没有特别要求的或在测试环境下方便抓包，采用默认规则就可以了，重要的数据单独做加密。即选场景1 要校验域名，即：validatesDomainName不要设置为NO。如果设为NO，不校验域名，也最好自己加一层验证方法。 如果是自制证书，allowInvalidCertificates设置为YES。如果是ca颁发的证书则建议设置为YES。 无论是使用AFSSLPinningModePublicKey还是AFSSLPinningModeCertificate都应该考虑证书失效需要更换的问题。 如果用AFSSLPinningModePublicKey方式，使用场景6只要保证后续更换的证书公钥不变化就可以了。个人觉得是安全和方便性最平衡的一种模式，只要私钥不泄露就可以了。这个要求公司的证书管理机构知道这点，不过如果出了意外，也可以延缓部署。 最安全的方案是7。也就是强校验，漏洞最少，安全防护最高。但是必须考虑证书失效更换的问题。 如何防止证书过期导致不过的问题？有以下方案： 可以用场景6，保证后续更换的证书公钥不变化就可以了 APP强制升级，全局通知，热更新等保护通道，建议不要使用强校验策略，使用强的加密手段保证安全，作为最后手段。 加入证书更新的通道，每次应用启动的时候访问，查看是否有证书更新，如果有就去下载证书。 证书更新有什么方案？ 建议启动检查是否有证书更新，可以合并在检查APP更新或热更新里面。 发现有更新的时候，服务端把证书二进制数据转为16进制字符串下发给客户端。服务端对数据使用私钥签名，客户端使用公钥对数据进行验签。 客户端将下载的文件按照签名等规则保存。下次加载前，继续对文件验证签名，保证没有篡改。 对于场景9，容许无效的证书，使用AFSSLPinningModeCertificate模式，为什么说明里面还说会验证证书过期？ 我个人也不确定，但是这个模式在加入证书锚点后，代码里还是会调用AFServerTrustIsValid()方法，然后再匹配证书数据是否一致。这个AFServerTrustIsValid()最终调用的是系统验证的方法，不确定系统是否还是会验证有效期，还是只验证包含证书就可以了，目前没有手段验证，大概率认为系统还是会验证是否过期。所以相对来说验证AFSSLPinningModePublicKey需要考虑更新的情况更少。 如果使用AFSSLPinningModePublicKey模式，更换证书怎么保证公钥不变？ 参考上一篇文章的附录，有一步是使用私钥.key文件生成.csr。只要.key和.csr，下次签发的时候直接用这两文件，签发就可以了。这样能保证下次的证书公钥也不变化。建议生产私钥的时候使用位数在2048位以上，可以保证安全性。 代码具体实现导出证书建议向自己公司的网络管理员导出对应的crt文件。或者使用命令： openssl s_client -connect www.google.com:443 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer //获取www.google.com:443的ssl证书，地址可以换成自己的 建议最好导出根证书的crt文件。因为根证书crt文件有效期长，很少更换。 如果是crt格式，使用时需要转化为cer格式。两种转化方式都可以： 命令行 openssl x509 -in 你的证书.crt -out 你的证书.cer -outform der 通过电脑导出。 双击crt，安装到钥匙链中。 钥匙链中选中需要导出的证书，鼠标右键，菜单中选择&gt;&gt;导出，点击存储即可。 然后将.cer文件导入到工程中。注意选Copy items if needed . 设置生效规则代码实现其实非常简单，重要的是规则的设置，建议认真搞清楚上面讲的配置说明，然后再配置。 12345678910111213141516171819202122232425262728293031//设置模式 AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; //设置是否验证域名，不建议设置为NO policy.validatesDomainName = YES; //设置是否容许无效的证书，自制证书选YES policy.allowInvalidCertificates = NO; //AF如果模式为AFSSLPinningModeCertificate或AFSSLPinningModePublicKey会默认导入mainBundle里的所有cer文件，如果没有特别需求，没必要实现下面加载cer的代码 //先导入证书路径 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@"myCer" ofType:@"cer"];//证书的路径 // 有多个加多个 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; policy.pinnedCertificates = @[certData]; AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; //生效policy manager.securityPolicy = policy; //调用 NSString *host = @"exmple"; NSDictionary *params = @&#123;&#125;; [manager GET:host parameters:params success:^(AFHTTPRequestOperation *_Nonnull operation, id _Nonnull responseObject) &#123; &#125; failure:^(AFHTTPRequestOperation *_Nonnull operation, NSError *_Nonnull error)&#123; _hasUpdating = NO; &#125;]; 具体配置请参考上面AFSecurityPolicy的介绍。通常测试环境下使用默认模式，其他环境使用校验模式。 验证策略源码解读AF 2.6版本，在系统框架需要进行证书验证的时候会调用AFURLCOnnectionOpeation.m中的evaluateServerTrust:forDomain方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain&#123; //自制证书且验证域名不能用AFSSLPinningModeNone模式 if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123; // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html // According to the docs, you should only trust your provided certs for evaluation. // Pinned certificates are added to the trust. Without pinned certificates, // there is nothing to evaluate against. // // From Apple Docs: // "Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors). // Instead, add your own (self-signed) CA certificate to the list of trusted anchors." NSLog(@"In order to validate a domain name for self signed certificates, you MUST use pinning."); return NO; &#125; NSMutableArray *policies = [NSMutableArray array]; if (self.validatesDomainName) &#123; //如果要验证域名需要把域名加入到规则里 [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; //设置验证规则，如果有域名验证就加入域名验证 SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); if (self.SSLPinningMode == AFSSLPinningModeNone) &#123; //AFSSLPinningModeNone下，如果容许无效证书或者证书通过验证就返回成功，否则返回失败 return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123; //其他模式，如果没有容许无效证书，就做证书验证，失效了就返回失败 return NO; &#125; //抽取服务端的所有证书链数据 NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust); switch (self.SSLPinningMode) &#123; //不会进入到这个case case AFSSLPinningModeNone: default: return NO; case AFSSLPinningModeCertificate: &#123; //将导入的证书加入到锚点里 NSMutableArray *pinnedCertificates = [NSMutableArray array]; for (NSData *certificateData in self.pinnedCertificates) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; &#125; // PS:查看相关文档发现，如果只调用了SecTrustSetAnchorCertificates而没有调用SecTrustSetAnchorCertificatesOnly(serverTrust,false)方法，会导致只信任SecTrustSetAnchorCertificatesOnly设置的锚点的证书，不信任系统默认内置的锚点证书 SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); //验证是否证书是否在加入的锚点证书列表里。猜测会验证证书的有效期，如果有域名验证，验证域名。 if (!AFServerTrustIsValid(serverTrust)) &#123; return NO; &#125; //查看证书链中的证书是否和埋入的证书完全一致。 NSUInteger trustedCertificateCount = 0; for (NSData *trustChainCertificate in serverCertificates) &#123; if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123; trustedCertificateCount++; &#125; &#125; return trustedCertificateCount &gt; 0; &#125; case AFSSLPinningModePublicKey: &#123; NSUInteger trustedPublicKeyCount = 0; //从证书链中抽取所有公钥列表 NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust); //验证证书链中的公钥是否在导入的证书里面的公钥链中 for (id trustChainPublicKey in publicKeys) &#123; for (id pinnedPublicKey in self.pinnedPublicKeys) &#123; if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123; trustedPublicKeyCount += 1; &#125; &#125; &#125; return trustedPublicKeyCount &gt; 0; &#125; &#125; return NO;&#125; 里面实际验证是否有效的方法为：AFServerTrustIsValid(SecTrustRef serverTrust)。实现： 12345678910111213static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123; BOOL isValid = NO; SecTrustResultType result; // 具体实现，因为看不到源码无法确认，应该是标准的证书链验证方式，验证证书有效性，验证证书链的对应的CA根证书是否在颁发机构里或者是否是用户手动同意或拒绝的证书。如果设置了SecTrustSetAnchorCertificates,则验证是否在SecTrustSetAnchorCertificates方法设置的锚点证书里（不包含系统的证书） __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); //kSecTrustResultUnspecified:证书通过验证，但用户没有设置这些证书是否被信任 //kSecTrustResultProceed:证书通过验证，用户有操作设置了证书被信任，例如在弹出的是否信任的alert框中选择always trust isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);_out: return isValid;&#125; WebView进行证书验证如果不配置，webview执行系统默认的策略。因为项目中没用到，暂时不敢评判，下面是相关博客供参考。 参考文献 iOS 10 适配 ATS（app支持https通过App Store审核） [ATS 官方文档] (https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35) RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密? iOS安全系列之二：HTTPS进阶]]></content>
      <categories>
        <category>iOS</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>安全</tag>
        <tag>ATS</tag>
        <tag>AFNetworking</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS应用安全-HTTP/HTTPS网络安全(一)]]></title>
    <url>%2F2017%2F05%2F11%2Fhttps-safe-1%2F</url>
    <content type="text"><![CDATA[导读： 本文主要讲在HTTP和HTTPS实际开发中有用和有意思的地方，希望读者能够有所启发。 主要包括：HTTP和HTTPS的简单介绍。介绍HTTPS加密逻辑。介绍SSL证书和SSL证书校验的规则。 本文简化了相关的技术细节，主要关注于前端开发需要关注的点和可以借鉴的地方，希望能对开发能有所帮助。开发更关心的技术代码实现细节，会单独文章中说明。 HTTP简介具体细节可以参考后面的参考文献，只写我觉得有意思和实际中可以参考的地方。 HTTP协议构建于TCP之上。意味着http是可靠的数据传输。所以不用担心丢包和乱序的问题。 HTTP协议是基于请求和响应的协议。与之对比MQTT协议是基于订阅的协议。 比如我想要一个资源的种子，如果知道哪个老司机有，我直接问他，他有就给我，没有也告诉我没有。这种模式就是请求和响应，好处是一对一，可以准确完整的按照自己的需求拿到需要的数据，但是坏处是消息会滞后，我想知道老司机后面是不是有资源了，我就只能一遍遍重复的问，直到拿到想要的结果为止（循环延迟请求，之前专门写个looperRequest就是为了解决这种问题）。 另外一种方案，我发布消息到一个论坛，然后留下邮箱，求好人一生平安。然后很多好人有资源就发给我，这样也能拿到数据。这种模式就是订阅模式，好处是可以一对多，可以快速实时拿到数据。但是坏处是：需要长链接，且推送消息时不清楚客户端的状态，推送的东西不一定需要，比如这个种子可能我已经有了，再发给我就浪费大家的流量了。 总结下。利用请求应答的模式，可以快速的和服务端同步数据，保证当前请求数据的有效性，有时候我们也叫拉（pull）数据。订阅模块可以快速的更新需要保证实时性的数据，比如聊天数据，交易结果，账户异常，有时候我们也叫推送（push）数据。 这两种方案是和服务端常用的两种交互方案，有些交互可以考虑两者结合的方式解决。比如之前项目中解决聊天数据的实时有效性，就采用后端推送当前有新消息或其他状态信息，前端收到状态信息后，主动拉取消息到本地，既能保证能够快速更新消息或状态，又能通过本地的状态，按照需求拉取需要的消息。 推/拉这种设计思路也可以用于应用间的数据同步，应用于模块间数据通信来进行模块解耦等。现在的项目工程模块化设计方案也借鉴了这两种思想。 URL。URL定义了一个资源的地址。大部分格式如下 protocol :// hostname[:port] / abs_path / [;parameters][?query]#fragment 详细说明参考 其中query用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。例如：http://www.joes.com/inventory-check.cgi?item=12731&amp;color=blue。唯一需要注意的是，URL里面不容许有非ASCII字符（常见的就是汉字），也不容许有保留字符比如：!*&#39;\&quot;();:@&amp;=+$,/?%#[]%,所以通常拼接请求时（GET），需要对传进来的参数做一次URLEncode操作。 可以参考这个做私有协议跳转，比如push消息协议，模块跳转协议，外部跳转协议等。 http请求由三部分组成，分别是：请求行、消息报头、请求正文.详细的建议使用charles抓一个请求看下就知道了。 注：来源于http://www.cnblogs.com/ranyonsue/p/5984001.html. 重要的几个请求报头字段： Accept: 指定客户端接受的消息类型（通常没人使用,因为客户端大量使用json做数据解析） Host:请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 User-Agent:用于附加操作系统名称和浏览器版本，通常给H5使用的，UA很容易被修改，项目中有遇到修改UA导致H5页面识别不出来当前操作系统和版本的问题，遇到这种可以查下UA被谁篡改了。 Referer:用于标示请求来源，一般用于防盗链，这个实际中也遇到过。 http的响应一般由三个部分组成，分别是:状态行，消息报头，响应正文。 注：来源于http://www.cnblogs.com/ranyonsue/p/5984001.html. 重要的几个消息报头 Content-Type 正文媒体类型和编码格式，比如：Content-Type:text/html;charset=ISO-8859-1.Content-Type这个字段被AFNetworking框架用于决定用什么解析器，注意后端不要配置错了。charset被用于AFNetworking字符解码，也应该前后端配置正确。这个配置不正确是经常联调不过的原因。 具体实现参考AFURLResonseSerialization.m。 Content-Length 用于表示正文长度，下载长资源时，需要使用这个字段来计算进度，也可以用这个字段推算下载流量。 Content-Encoding 通常用于记录压缩方法，比如：gzip。 GET和POST的方法。HTTP有定义了几种常用的方法，不过通常前端只和这两个打交道。这两个区别： 通常认为get是获取消息，不改变数据，post是用来改变数据，不过实际中，并不是那么明确。 get参数是附在URL链接上的，参数拼接前需要做URLEncode，post是附在请求正文里的,格式为key=value，使用&amp;分割，所以对传入数据也要做URLEncode，拼接后和头部用回车换行隔开。 get的URL长度有一定限制，不过也取决于系统支持，具体长度需要实际调研，ie的限制为2083字节，post理论上不存在长度限制。 安全性，post相对安全，get相对不安全。不过post属于防君子不防小人的那种，实际没有什么安全可言。所以综合来说，如果没有技术洁癖，建议都用post处理。 上传图片等二进制资源。上传资源一般是post协议，但是通常post是用于传送文本的，如何传图片等资源呢？就需要multipart协议了。 mutipart和普通的post有两点不同：请求头，请求报文。其中关键字是boundary这个属性。 请求头： 必须包含content-Type，且值为：multipart/form-data;boundary=${bond},其中${bound}为具体分割符，在AFNetworking中，如果不指定是Boundary+${random}。 请求体:内容不再是用name=value的形式，而是使用上面的boundary进行分割的一段一段的结构体。具体示例： 12345678910111213141516171819202122232425262728293031 POST /btoa/work/common/uploadImage HTTP/1.1Host: www.example.comContent-Type: multipart/form-data; boundary=Boundary+49F77F66A65EEA58Cookie: BIGipServerPOOL_PACLOUD_STGR2016080900646=1274288556.52384.0000; FF_SESSION2_ID=Sf503bee3691b4a31a53c6e3c5ae1c1f00912e8Connection: keep-aliveAccept: */*User-Agent: FFProject/2.0.0 (iPhone; iOS 10.3.1; Scale/3.00)Accept-Language: zh-Hans-CN;q=1, th-TH;q=0.9Content-Length: 418864Accept-Encoding: gzip, deflate--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="ffAppID"10004--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="imageSeq"1--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="imageType"5--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="image"; filename="xxxx.jpg"Content-Type: image/jpeg***image hex data***--Boundary+49F77F66A65EEA58-- 看到上面的例子可以知道，有几个参数是必须的，name、filename、Content-Type、具体资源数据 ，对应的AF接口： 1234- (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType; HTTPS简介苹果ATS政策出来之前，后端极少使用HTTPS协议，而是使用HTTP协议+自定义的安全数据加密策略来保证安全性。这是因为虽然HTTPS更安全，但是也更加耗费性能。如今苹果强推HTTPS（有说法是苹果可能会全面禁止HTTP的使用），使得HTTPS大范围使用，并且使用HTTPS作为安全扫描项，被安全机构接纳。但是如果不正确的使用HTTPS，还是会带来安全风险。 SSL/TLS简介HTTPS的关键字就是SSL（TLS）。和HTTP唯一的不同就是加入了SSL（TLS）协议，这一层在TCP之上，负责保证安全连接和数据传输安全。 注：来自 深入解析HTTPS SSL实际上是一套加密通信机制。SSL和TLS两者的协议基本一致，区别简单可以理解是TLS是SSL的升级版本。但是使用SSL所有协议版本都不再安全。请勿使用SSL协议 具体可以参考SSL与TLS的区别以及介绍 ios加入了ATS限制，强制原来HTTP必须使用HTTPS传输，也强制要求服务器必须使用TLS v1.2版本以上。所以简化为： 要使用支持TLS1.2及以上协议的HTTPS传输数据 PS：后面如无特殊说明，不再区分TLS和SSL，统一称为SSL HTTPS原理建议看下浅析HTTPS中间人攻击与证书校验和阮一峰：图解SSL/TLS协议和SSL、TLS协议格式入门学习 - .Little Hann 下面是协议流程图： 注：来自http://blog.csdn.net/muzhengjun/article/details/53379593 简单描述： TCP握手 SSL握手，握手成功就开始传输，失败就断开链接 数据传输 下面也是只讲一些有意思的点和注意的地方。 HTTPS加密流程整个加密的流程，体现了一个非常安全的信息加密的方案。 简化的流程如下： 客户发送一个随机数给服务端：random-c（明文） 服务端发送自己SSL证书给客户端。发送服务端随机数：random-s（明文） 客户端验证SSL证书有效性，如果判定有效，生成一个随机数random-p,然后使用证书中的公钥进行非对称加密，发送给服务端。 （这一步是整个安全环节最重要也是最薄弱的环节） 服务端拿到加密后的秘钥，通过私钥解密，得到random-p ，将random-c、random-s、random-p三个随机数做因子，两端都按照一定算法生成会话对称秘钥secret_key。 客户端计算之前的握手消息（除了Change Cipher Spec外）的Hash值，利用secret_key做对称加密后发给服务端。 服务端拿到后，利用secret_key解密，然后利用同样的算法计算之前的握手消息的Hash值，如果能解密成功，且验证Hash值正确则说明客户端的加密算法和秘钥没问题。 服务端再计算之前的握手消息的Hash值，利用secret_key做对称加密后发给客户端，客户端如果能够解密出来，且与自己计算的Hash值相同，则最后链接正式建立成功。 注明：上面是以RSA为基础的秘钥加密流程，即需要客户端将随机数加密传输给后端。还有一种基于秘钥交换的形式，双方的对称秘钥是通过交换的参数本地的，不会通过信道传输，会更安全些。具体参考TLS/SSL 高级进阶 先简单说明几个概念，详细的会专门抽出来分享： 对称加密：双方使用的秘钥是相同的，使用同一个秘钥进行加解密。 非对称加密：加密使用公钥加密，解密使用私钥加密。或者私钥加密，使用公钥解密。但是公钥和私钥是不同的。公钥是公开的，可以被第三方拿到而不会引起任何安全问题，因为通过公钥是无法得到私钥的，因而没办法解密使用公钥加密的数据。 散列（hash）：散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。好的散列算法是一对一的，不同的原文生成的一定是不同的散列。 这其中使用的加密策略： 传输数据应该加密，整个加密过程使用了两种加密方案，一种对称加密，一种非对称加密。 传输数据使用了对称加密，而秘钥生成中使用了非对称加密。 使用了散列算法（hash）来做数据验证。 回答这里面常见的几个问题： 为什么又要用非对称加密，又要用对称加密，只使用一个不可以么？ 不能只是用对称加密，因为对称加密，两个使用的秘钥是一致的，有一端的秘钥泄露了，两端的通信就不再安全了，尤其是客户端的对称秘钥非常容易泄露，拿到秘钥后，整个系统就不安全了。 也不只用非对称加密，主要是因为性能，非对称加密相对于对称加密，计算时间要长非常多，对于性能要求很高的场景，会明显降低性能。RSA算法和AES算法性能测试 所以设计者结合了两种方案。两端通过非对称加密协商秘钥，攻击者因为拿不到私钥，是无法解开通信秘钥的。一旦协商成功，通过对称加密又解决了性能问题。 为什么使用三个随机数 还是为了进一步加强安全，客户端或者服务端生成的随机数可能是伪随机的，有可能被攻击者猜出，但是如果三个伪随机的数一起使用就大大加强了随机性，这样攻击者就很难破解了。 为什么最后要做hash验证 为了保证两端通信中的数据不会做篡改，由于HASH算法，可以保证唯一性，所以如果中间消息被人篡改，就可以断开链接。 如果对原理不感兴趣，那建议记住下面推荐的加密方案，完全可以解决大部分的加密需求： 使用随机数做对称加密秘钥，将对称加密秘钥使用公钥进行非对称加密传给后端。这样因为秘钥随机，所以即使客户端被破解，也拿不到任何对称秘钥。而公钥建议老客户过3456让她进行动态获取，避免私钥泄露带来的问题。 使用非对称加密秘钥，可以保证网络数据即使劫持，因为没有私钥，也解不出来对应的加密秘钥，所以加密的隐私数据也是安全的 两者结合，可以保证一定的性能要求。 对数据进行加签（加盐+hash算法），保证中间的数据不会篡改。 ps:用户的密码，因为保密性要求更高。建议的算法是做HMAC哈希做脱敏，然后使用非对称加密给后端。 常用的网络传输攻击手段先思考下，刚才的通信链路有三个参与者： 客户端 传输信道 服务端 如果新加入一个攻击者，他想要窃取用户的隐私数据，他该怎么做？常见的做法： 攻击客户端。对于IOS系统来说，非越狱手机，由于权限问题，几乎无法攻击（之前XcodeGhost真的是很nb的攻击思路）。对于越狱手机，通过HOOK API，然后重新打包应用，诱导用户下载。或者劫持系统的输入框等常用控件可以达到攻击目的。相关的以后整理输出。但是从移动APP来说，直接攻击APP带来的危害和利用性很低，通常只会泄露很少的用户信息。大多是利用来薅羊毛的。 攻击传输信道。攻击手段有中间人攻击，DNS劫持等。 攻击服务端。也非常难做到。一般是模板注入，撞库等。 这里面其实最容易的就是攻击传输信道。排除技术术语，手段有： 伪装成正常的客户端攻击服务端 伪装成正常的服务端，劫持客户端数据 监听修改信道数据 这几种怎么解决？ 问：如何处理伪装成正常的客户端攻击服务端 在认为客户端app本身是无法攻破的前提下： 请求中一定加入签名策略。攻击者不知道签名策略是无法仿造请求的，也防止劫持者修改。发现签名不对，服务端认为是假的客户端。 请求中一定加入请求防重放策略。服务端发现是之前的请求，重复发送过来的（可能只有签名不一致），应该忽略 加入风险控制策略。比如异地登陆，同一设备ip反复请求，一些金融类app也会加入公安部认证的风控系统，防止一些有金融犯罪前科的用户注册。后端使用风控策略，禁止用户登录，或者强制要求用户再次身份认证，比如手机验证码认证。 问：如何处理监听修改信道数据&gt; 请求关键数据做加密，加密方案建议使用上面提到的加密方案。这样即使被监听，拿到数据也无法处理 加入请求签名，防止数据篡改。 问：如何处理伪装成正常的服务端，劫持客户端数据 这一种方式是目前攻击最常见且有效的手段。使用http的时候，因为没有任何认证措施，通过ARP或者DNS劫持，非常容易将网址定向到其他攻击者的地址，攻击者可以做劫持和修改相关数据。所以HTTP现在已经被各大平台所抛弃。很多开发遇到的访问一个h5页面，被运营商强插入广告就是这么做的。解决办法就是正确的使用HTTPS HTTPS，很大一部分作用就是解决上述问题。也就是通过SSL握手，校验服务端证书，达到验证是否是伪装的服务端的目的。HTTPS握手阶段算法原理都是安全的，只有验证身份这一步有漏洞，即只要想办法让客户端认为证书是可信的，证书里面的公钥就是生成者的公钥，自然就有相对应的私钥，后面非对称加密生成的对称秘钥就可以被截取到，造成整个链路不安全。如何攻击这个策略，行业上主要称为中间人攻击。 SSL证书可以说验证SSL证书是整个HTTPS的关键，如果这一步出问题，后面的就没有任何安全可言。而对于我们前端开发来说，SSL证书也是最需要关注的地方。 这里讲两个问题。SSL证书是什么？为什么通过SSL证书可以防止攻击者伪装成服务端。 SSL证书是什么SSL证书是一个文件。里面的内容包括：用户的信息、用户的公钥、还有CA中心对该证书里面的信息的签名。一个证书的实例： 打开safari，打开百度，https://www.baidu.com,在地址栏点击锁按钮，然后选显示证书。 里面的内容只有几个需要关注的： 常用名称：baidu.com 。客户端或浏览器，根据常用名称和访问的域名做匹配，访问的域名和证书的域名不一致，就会拒绝访问，达到防止域名劫持的目的。这个信息可以被伪造。 公共密钥：SSL握手生成的第二段随机串是通过这个公钥来加密的。这个信息可以被伪造，但是伪造没有异议。（想知道为啥的可以看看证书生成的步骤。） 签名：是对整个证书内容做hash之后，使用颁发机构的私钥加密的值。这个信息可以被伪造，但是伪造没有异议。 签名者信息：颁发机构的信息，由于验证上一级的证书信息。这个信息可以被伪造。 证书有效期。这个信息可以被伪造。 可以看到在百度这个证书上面还有两个证书，这是因为百度这个证书是有GS这个机构的二级机构颁发的，而GS这个二级机构是由GS的CA根证书颁发的。 也就是证书有证书链的概念，即这个证书可能是上一层机构颁发的，从CA根证书开始-&gt;二级CA证书-&gt;三级CA证书-&gt;…。 注：来自SSL 之证书链 SSL证书如何验证的推荐这篇文章，是目前看到讲的最清楚。浅析HTTPS中间人攻击与证书校验 根据HTTPS协议，服务端会在握手的时候将证书传送给客户单，而且是将整个证书链发过来。 通常的验证传过来的证书是否有效的步骤为： 验证证书的常用名称是否是访问的域名，是否在有效期内。（域名校验+有效期校验） 计算这个证书内容的散列值得到MD5-a，然后用颁发机构的公钥解密这个证书的签名得到MD5-b，比较两个值是否相同，如果相同说明这个证书确实是上个颁发机构颁发的。 重复上面的操作，直到验证到CA根证书。CA证书是自签名的，也就是签名是用自己的私钥签名的。可是CA根证书签名是用自己的私钥做签名，怎么去验证这个证书是否正确呢？ 最终上面的问题简化为： 如何验证CA根证书有效性最终层层拨茧，HTTPS的安全性关键钥匙就在这一章了。 CA根证书有两种生成方式： 由可信的颁发机构颁发 本地自己生成 对于第一种，因为可信的颁发机构很少，这些机构的CA证书会默认保存在浏览器里或者手机操作系统里，由可信的机构颁发的证书的有效性会由颁发机构保证。不过这种证书需要向颁发机构申请，颁发机构会花时间去进行公司域名身份等信息验证，所以花费也不少。 对于第二种，本地生成的证书（后面会附录如何生成自签名证书），证书常用的信息都可以生成，可以认为证书信息内容都不可靠，尤其是证书中的域名。使用自制证书在浏览器会弹出警告不可信，用户可以手动添加到信任列表里，之后可信了才可以访问，12306之前让下载证书导入，就是这个原因。在应用APP里，如果使用默认配置，会拒绝，返回SSL验证失败。 在应用内信任自生成证书有两种办法： 第一种 安装描述文件到系统里。在安装charles过程中，其中一步就是打开一个网址，在弹出安装的时候，安装这个证书，也可以把这个证书下载到云盘里，然后打开。这个过程需要用户手动授权。这个起效后是全局的，任何应用都会影响。 第二种 把这个根证书，埋入APP里,然后设置为证书锚点（可以设置多个），然后在SSL握手需要验证证书的时候，系统会认为这个证书是有效的。这个方案也是很多自签名证书进行校验的方法。这个只会在本应用里起作用。 中间人攻击中间人攻击是最常见的攻击HTTPS手段。 建议看这篇文章：iOS安全系列之二：HTTPS进阶 看到上面的验证手段，其实关键就在于如何信任CA根证书上面。攻击者就是想尽一切办法让客户端安装他自己的CA证书到你的手机里。 如果手机没有越狱，一定会引诱你去安装这个证书，并且手动设为可信。一旦信任，在访问服务器的时候，攻击者通过代理劫持，通过这个信任的CA证书，生成对应的域名的证书。最终因为域名可信，有效期可信，证书可信整个HTTPS建立成功，攻击者拿到相关的数据。 使用charles抓包的整个过程，其实就是中间人攻击的过程。 附：下面是charles开启SSL代理后，访问新浪弹出的证书信息，可以看到charles生成了新浪域名的证书： 提示：对于用户来说，不要信任任何CA证书，不安装任何描述文件是最安全的方法。比如安装飙车软件，让你信任一个证书。比如链接外部wifi，提示你安装证书才可以链接。比如翻墙设置代理，提示你安装信任证书。描述文件在通用-&gt;描述文件与设备管理中找到。 校验证书的姿势校验证书有两种方案： 弱校验 对于服务端证书，校验下面的case。 校验证书的域名 校验证书的有效期 校验证书链和证书的有效性 保证这三者有效，已经可以解决大部分的攻击了。唯一的风险就是中间人攻击，被安装CA证书之后，一个被信任的CA根证书可以生成符合上面要求的任何域名的证书。存在着风险，但是攻击难度已经大大增加了。AFNetworking框架默认采用的就是这个策略。 强校验 将证书放入APP中作为证书锚点。在上面的基础上再验证证书。这样可以完全保证服务端的证书是真正需要的证书，从而真正解决中间人攻击。 下面主要讲下强校验面临的坑，各位开发一定要注意。 证书强校验的坑证书是有有效期的，尤其是非自制证书，通常都在三年以内（很多资料根本不谈这个问题）。一旦有效期过了，服务端就需要更换证书,但是由于APP存在发版的情况，老的APP由于所有链接失败，导致老APP任何请求都失效，然后无法通知用户更新，老用户也不知道因为什么访问失败。（这些都是血的教训啊） 有几个建议的地方： 尽量埋CA证书，因为CA证书的有效期要长，有足够的时间准备。 有些通道不要使用证书强校验，比如检查升级，一些热修复策略，尽量使用自有的安全逻辑保证安全。 如果是自制证书，建议有效期设置长一些。 上面的是尽量降低风险，该出问题的时候还是会出，有一些不完美的方案大家可以参考下： 方案1：动态更新证书。 在APP中放入RSA公钥，应用启动的时候，证书信息通过私钥加密，发送给前端保存，前端把这个新证书和埋入的证书一起做锚点，进行验证。这样可以保证老APP可以使用一段时间。缺点是这个下发的机制要尽量安全可靠，有可能被攻击者利用，而且后续的请求需要依赖这个请求，所以方案复杂一些。 方案2：只验证证书的公钥 只使用证书的公钥进行验证，因为更换证书，一般是通过.csr文件生成crt证书文件的（也就是证书文件），在.csr文件没变的情况下，生成的证书的公钥是一致的，也就即使服务端更换了证书，只要公钥不变，依然可以通过验证。所以验证公钥也是相对安全的。缺点是如果新的证书换了公钥还是出问题。我遇到的case就是需要更换私钥和证书算法，公钥也不一样了。 其他不太靠谱的方案： 方案3： 在弱校验的基础上，加上验证颁发机构。只要读到颁发机构是可信的，证书就认为是有效的。可以解决第三方抓包工具的抓包问题，因为第三方抓包工具，一般使用自己的颁发机构，和实际的颁发机构不一致。缺点是，证书是可以完全伪造的，包括颁发结构的名字，有效期等等都可以伪造。 方案4： 信任无效的证书。 信任无效的证书，但是做本地证书校验，在失效的一段时间内，后端先不部署新证书，在新版本里面提前埋入新证书，在几个版本后再上线新的证书。优点是简单，不怕哪天忘了更换证书导致出问题。缺点是信任失效的证书，如果真的有需求要强制更换证书，就没办法处理。 附录:如何生成自签名证书参考 深入解析HTTPS和利用OpenSSL创建自签名的SSL证书 和 自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名 生成私钥 openssl genrsa -out ca.key 4096 利用私钥创建根证书 openssl req -new -x509 -days 36500 -key ca.key -out ca.crt 弹出的对话框按照提示填写： 1234567 Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangdongLocality Name (eg, city) []:ShenzhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:BL.incOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:BLEmail Address []: 创建SSL证书私钥 openssl genrsa -out server.key 4096 使用刚才的私钥签名 openssl req -new -key server.key -out server.csr 弹出的对话框按照提示填写： 12345678910111213 Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangdongLocality Name (eg, city) []:ShenzhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:BL.incOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:*.sina.com.cnEmail Address []:Please enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:1111An optional company name []: 注意，这里的Common Name 应该和实际的域名匹配。而且生成的.csr这个文件最好长期保留，下次过期的时候，建议直接用这个文件做签名。如果是向CA颁发机构申请，提交的文件也是这个文件。 对上一步的csr使用CA进行签名生成证书 openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt 如果是向CA机构申请，提交这个文件就可以了。 如果有必要可以重复上面必要步骤，使用上一步的证书的.crt和.key继续签名下一级证书。 一些常用命令： 12345 openssl s_client -connect www.google.com:443 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer //获取www.google.com:443的ssl证书，地址可以换成自己的openssl rsa -noout -text -in server.key 查看私钥信息openssl req -noout -text -in server.csr 查看签名请求信息openssl x509 -noout -text -in ca.crt 查看证书信息 MAC下使用Charles抓包参考 深入解析HTTPS 和 iOS安全系列之二：HTTPS进阶 安装Charles CA根证书 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certification …，会弹出如下提示，链接代理，手机浏览器输入chls.pro/ssl，就可以安装根证书了。 设置SSL代理 点击Proxy-&gt;SSL Proxying Setting，勾选Enable SSL Proxying，然后点击Add输入要SSL代理的请求Host和Port，可以使用通配符来表示某一类请求。 或者在对应的请求上右键选择Enable SSL Proxying，就会把这一个请求加入到上面的SSL代理列表中（类似于点击Add的效果）。 做完上述步骤后重新请求就能得到解密后的信息了。ps:抓取PC端的HTTPS包也类似，在Help-&gt;SSL Proxying中下载证书，双击安装证书，并选择始终信任即可。 在iPhone端设置HTTP代理 在Mac上获取当前机器的IP地址： ifconfig en0: ch将iPhone连接到与电脑相同的WiFi，在iPhone设置中：无线局域网 -&gt; 已连接WiFi右边的Info详情图标 -&gt; HTTP代理 -&gt; 手动 -&gt; 设置HTTP代理： 设置完成之后，打开Safari随便访问一个网页，初次设置代理的话，Charles会弹出一个iPhone请求代理的确认框，点击Allow即可。然后在Charles上就可以看到iPhone上的HTTP请求了。为了避免Mac上的请求过多影响对被代理iPhone上HTTP请求的查看和调试，可以在Charles取消Mac的代理：Menu -&gt; Proxy -&gt; 取消勾选Mac OS X Proxy 即可。 参考文献 HTTP协议详解（真的很经典） MQTT_github 说说http协议中的编码和解码 HTTP协议之multipart/form-data请求分析 苹果文档翻译 iOS10 NSAppTransportSecurity iOS中的HTTPS, 你知道多少? 阮一峰：图解SSL/TLS协议 SSL与TLS的区别以及介绍 浅析HTTPS中间人攻击与证书校验 SSL、TLS协议格式入门学习 - .Little Hann iOS安全系列之二：HTTPS进阶 HTTPS 理论详解与实践 利用OpenSSL创建自签名的SSL证书 自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名 深入解析HTTPS TLS/SSL 高级进阶]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>HTTPS</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
</search>