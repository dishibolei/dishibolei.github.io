<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[fishhook源代码解析]]></title>
    <url>%2F2017%2F11%2F13%2FfishHooker%2F</url>
    <content type="text"><![CDATA[导读在做网络性能监听的时候，需要对网络状态进行监听，OC的代码可以通过runtime机制做hook，但是其中涉及到C代码函数，如何进行hook？通过查资料，使用fishhook可以解决这个问题 官方内容：fishhookfishhook is a very simple library that enables dynamically rebinding symbols in Mach-O binaries running on iOS in the simulator and on device. This provides functionality that is similar to using DYLD_INTERPOSE on OS X. At Facebook, we’ve found it useful as a way to hook calls in libSystem for debugging/tracing purposes (for example, auditing for double-close issues with file descriptors). UsageOnce you add fishhook.h/fishhook.c to your project, you can rebind symbols as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;dlfcn.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &quot;AppDelegate.h&quot;#import &quot;fishhook.h&quot; static int (*orig_close)(int);static int (*orig_open)(const char *, int, ...); int my_close(int fd) &#123; printf(&quot;Calling real close(%d)\n&quot;, fd); return orig_close(fd);&#125; int my_open(const char *path, int oflag, ...) &#123; va_list ap = &#123;0&#125;; mode_t mode = 0; if ((oflag &amp; O_CREAT) != 0) &#123; // mode only applies to O_CREAT va_start(ap, oflag); mode = va_arg(ap, int); va_end(ap); printf(&quot;Calling real open(&apos;%s&apos;, %d, %d)\n&quot;, path, oflag, mode); return orig_open(path, oflag, mode); &#125; else &#123; printf(&quot;Calling real open(&apos;%s&apos;, %d)\n&quot;, path, oflag); return orig_open(path, oflag, mode); &#125;&#125; int main(int argc, char * argv[])&#123; @autoreleasepool &#123; rebind_symbols((struct rebinding[2])&#123;&#123;&quot;close&quot;, my_close, (void *)&amp;orig_close&#125;, &#123;&quot;open&quot;, my_open, (void *)&amp;orig_open&#125;&#125;, 2); // Open our own binary and print out first 4 bytes (which is the same // for all Mach-O binaries on a given architecture) int fd = open(argv[0], O_RDONLY); uint32_t magic_number = 0; read(fd, &amp;magic_number, 4); printf(&quot;Mach-O Magic Number: %x \n&quot;, magic_number); close(fd); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; Sample output1234Calling real open(&apos;/var/mobile/Applications/161DA598-5B83-41F5-8A44-675491AF6A2C/Test.app/Test&apos;, 0)Mach-O Magic Number: feedface Calling real close(3)... How it worksdyld binds lazy and non-lazy symbols by updating pointers in particular sections of the __DATA segment of a Mach-O binary. fishhook re-binds these symbols by determining the locations to update for each of the symbol names passed to rebind_symbols and then writing out the corresponding replacements. For a given image, the __DATA segment may contain two sections that are relevant for dynamic symbol bindings: __nl_symbol_ptr and __la_symbol_ptr. __nl_symbol_ptr is an array of pointers to non-lazily bound data (these are bound at the time a library is loaded) and __la_symbol_ptr is an array of pointers to imported functions that is generally filled by a routine called dyld_stub_binder during the first call to that symbol (it’s also possible to tell dyld to bind these at launch). In order to find the name of the symbol that corresponds to a particular location in one of these sections, we have to jump through several layers of indirection. For the two relevant sections, the section headers (struct sections from &lt;mach-o/loader.h&gt;) provide an offset (in the reserved1 field) into what is known as the indirect symbol table. The indirect symbol table, which is located in the __LINKEDIT segment of the binary, is just an array of indexes into the symbol table (also in __LINKEDIT) whose order is identical to that of the pointers in the non-lazy and lazy symbol sections. So, given struct section nl_symbol_ptr, the corresponding index in the symbol table of the first address in that section is indirect_symbol_table[nl_symbol_ptr-&gt;reserved1]. The symbol table itself is an array of struct nlists (see &lt;mach-o/nlist.h&gt;), and each nlist contains an index into the string table in __LINKEDIT which where the actual symbol names are stored. So, for each pointer __nl_symbol_ptr and __la_symbol_ptr, we are able to find the corresponding symbol and then the corresponding string to compare against the requested symbol names, and if there is a match, we replace the pointer in the section with the replacement. The process of looking up the name of a given entry in the lazy or non-lazy pointer tables looks like this: 源码解析调用方法：使用非常简单，可以用下面的方式hook printf的方法，来执行自定义的printf方法。 12345678910111213141516static int (*orig_printf)(const char * __restrict, ...);int my_printf(const char * __restrict result,...) &#123; return orig_printf("%s+custom\n",result);&#125;- (IBAction)btAction:(id)sender &#123; printf("测试1"); // 调用绑定 rebind_symbols((struct rebinding[1])&#123;&#123;"printf", my_printf, (void *)&amp;orig_printf&#125;&#125;, 1); printf("测试2"); &#125; 绑定的函数定义为：12int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) 调用非常简单，其中传入的参数是一个结构体数组，其中结构体定义为： 123456789/* * A structure representing a particular intended rebinding from a symbol * name to its replacement */struct rebinding &#123; const char *name; //需要hook的方法名称 void *replacement; //替换后的函数实现 void **replaced; //保存替换后函数实现&#125;; rebind_symbols方法详解外部调用的方法，用于重新绑定实现 12345678910111213141516171819int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) &#123; int retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel); //预绑定方法，主要是实现相关的结构体和内存地址。 if (retval &lt; 0) &#123; return retval; &#125; // If this was the first call, register callback for image additions (which is also invoked for // existing images, otherwise, just run on existing images // 第一次调用的时候注册回调处理，否则直接加载当前的images内存处理 if (!_rebindings_head-&gt;next) &#123; _dyld_register_func_for_add_image(_rebind_symbols_for_image); &#125; else &#123; uint32_t c = _dyld_image_count(); for (uint32_t i = 0; i &lt; c; i++) &#123; _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i)); &#125; &#125; return retval;&#125; prepend_rebindings的作用是做一些初始化的工作，生成需要的数据结构,赋值给_rebindings_head，最终是一个链表结构。实现为： 12345678910111213141516171819static int prepend_rebindings(struct rebindings_entry **rebindings_head, struct rebinding rebindings[], size_t nel) &#123; struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry)); if (!new_entry) &#123; return -1; &#125; new_entry-&gt;rebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel); if (!new_entry-&gt;rebindings) &#123; free(new_entry); return -1; &#125; memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel); new_entry-&gt;rebindings_nel = nel; new_entry-&gt;next = *rebindings_head; *rebindings_head = new_entry; return 0;&#125; 其中最主要的是这个rebindings_entry数据结构,保留了后续需要绑定的数据： 12345struct rebindings_entry &#123; struct rebinding *rebindings; //需要绑定的数拒数组 size_t rebindings_nel; //绑定的数量 struct rebindings_entry *next; //下一个节点&#125;; _dyld_register_func_for_add_image是这段代码关键的函数，这个函数的作用是注册一个回调，调用这个函数后，首先系统会返回所有已经加载的镜像的数据，然后之后会回调新加入的镜像的数据。通过这个函数就能获取到镜像加载的数据情况。 接着调用_rebind_symbols_for_image方法来解析image数据。 rebind_symbols_for_image 方法详解这段代码之前，先讲相关联的的一些知识，更详细的可以看我的另外一篇文章，mach-o parser。 程序在解析完Mach64 Header后，开始加载命令（Segment commands），每个命令记录了相关数据的地址信息和命令类型，下面是几个用到的命令。 LC_SEGMENT_64(_LINKEDIT) : 用于处理动态链接的段命令，在程序里，主要用这个段里的数据算出起始偏移地址：base_address = vmaddress - file_offset + slide（ps：动态偏移，是程序运行时动态计算出来的，保证地址空间随机）。比如下图的起始地址计算为：base_address = 0x10000C000 - 0x00000C000 + 0（静态分析是0偏移） = 0x100000000 LC_SYMTAB : 记录加载symbol table和string table的命令，symbol table记录了函数更详细的数据,程序中主要是利用这个表来从string table表中找到具体的方法名称。程序中用于定位symbol table和string table的起始地址。计算公式为：symbol_addr = base_address + symbol_table_offset、string_addr = base_address + string_table_offset。比如下图的起始地址计算为：symbol_addr = 0x100000000 + 0x00000C4D8 = 0x10000C4D8,string_addr = 0x100000000 + 0x00000D02C = 0x10000D02C LC_DYSYMTAB : 记录加载动态链接信息的命令。程序中主要是用来计算Dynamic Symbol Table的地址。利用Dynamic Symbol Table地址可以定位到对应方法在symbol table的地址，从而定位到方法名称。起始地址计算公式为：dynamic_symbol_addr = base_address + indsym_table_offset,比如下图的起始地址计算为：dynamic_symbol_addr = 0x100000000 + 0000CF78 = 0x10000CF78 下面的程序主要是定位出symbol table、string table和dynamic symbol table的起始地址，最终交给perform_rebinding_with_section方法来真正做替换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) &#123; //rebindings是一个链表结构，保存了所有需要绑定的数据 Dl_info info; if (dladdr(header, &amp;info) == 0) &#123; return; &#125;// 解析加载指令，找到需要的几个加载命令：SEG_LINKEDIT、LC_SYMTAB、LC_DYSYMTAB segment_command_t *cur_seg_cmd; segment_command_t *linkedit_segment = NULL; struct symtab_command* symtab_cmd = NULL; struct dysymtab_command* dysymtab_cmd = NULL;// header的数据结构为/**/* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;;**/ uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t); // 头部之后是加载指令 for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; //解析__LINKEDIT的cmd命令 if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) &#123; linkedit_segment = cur_seg_cmd; &#125; &#125; else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123; //解析__SYMTAB的cmd命令 symtab_cmd = (struct symtab_command*)cur_seg_cmd; &#125; else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123; //解析__DYSYMTAB的cmd命令 dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd; &#125; &#125; // 如果没找到就退出 if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment || !dysymtab_cmd-&gt;nindirectsyms) &#123; return; &#125; // Find base symbol/string table addresses // 找到对应的基础地址，使用__LINKEDIT中的vmaddress - file_offset + slide（动态偏移），通过这个地址算出symbol/string table的地址。 uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff; //计算symbol table的地址 = linkedit_base + symbol_table_offset nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff); //计算string table的地址 = linkedit_base + string_table_offset char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff); // Get indirect symbol table (array of uint32_t indices into symbol table) //计算indirect symbols table地址 = linkedit_base + dysymtab-&gt;indSym_table_offset uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff); // 再次遍历加载命令,用于定位`__DATA`段中的`__la_symbol_ptr`或`__nl_symbol_ptr`节的加载命令 cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp; strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) &#123; continue; &#125; for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123; section_t *sect = (section_t *)(cur + sizeof(segment_command_t)) + j; //如果是_la_symbol_ptr或者__nl_symbol_ptr就调用hook方法进行hook if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123; perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123; perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; &#125; &#125; &#125;&#125; perform_rebinding_with_section这段代码是查找符号表的数据，如果名字和要代替的方法名称相同，就把实现用替换的方法做替换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static void perform_rebinding_with_section(struct rebindings_entry *rebindings, section_t *section, intptr_t slide, nlist_t *symtab, char *strtab, uint32_t *indirect_symtab) &#123; //通过节中保存的reserved1来定位在Dynamic Symbol Table的起始地址。Dynamic Symbol Table是一个数组结构，数组的元素保存了symbol table中的的index值 uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1; //算出对应的在DATA区的数据的地址（__DATA__got节对应的是__nl_symbol_ptr指针，__DATA__la_symbol_prt节对应的是_la_symbol_ptr），这个节对应的是一个数组列表，数组元素为具体的方法实现的函数指针，最终的目的就是把这个实现的函数指针替换成需要替换的函数指针 void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr); //indirect_symbol_indices和indirect_symbol_bindings都是数组结构，而且一一对应，通过数组index就可以找到成对的对应关系,数组长度是节的长度/指针的长度 for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123; //从Dynamic Symbol Table表中取出对应在symbol table中的的index。 uint32_t symtab_index = indirect_symbol_indices[i]; if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL || symtab_index == (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) &#123; continue; &#125; //通过index从symbol table取出nlist_t数据结构，在这个结构了保存了在string table中的偏移量 nlist_t symtablist = symtab[symtab_index]; uint32_t strtab_offset = symtablist.n_un.n_strx; //通过偏移量可以找到对应的方法名称 char *symbol_name = strtab + strtab_offset; if (strnlen(symbol_name, 2) &lt; 2) &#123; continue; &#125; struct rebindings_entry *cur = rebindings; while (cur) &#123; //遍历传进来的替换结构体里是否有和现在数据方法名匹配 for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123; if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123; if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp; indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123; //保存原始实现 *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; &#125; //如果匹配到了，将indirect_symbol_bindings保存的函数指针替换成要绑定的函数指针 indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement; goto symbol_loop; &#125; &#125; cur = cur-&gt;next; &#125; symbol_loop:; &#125;&#125; 分解下替换的步骤： 找到加载__nl_symbol_ptr和__la_symbol_prt的节命令,其中__nl_symbol_ptr是程序启动就会加载的symbol，__la_symbol_prt代表懒加载。 对应的数据结构为： 1234567891011121314struct section_64 &#123; /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */&#125;; __nl_symbol_ptr 对应的节加载命令如下： __la_symbol_prt对应的节加载命令如下： 利用这个加载命令，可以定位到__DATA段中的地址，比如上图中__la_symbol_prt节，对应的起始地址为100008018，这个地址在__DATA__la_symbol_ptr。 每个数据记录了具体实现的函数地址，比如__printf函数,对应的实现地址为100006BDC，这个地址指向__stub__helper,也就是利用__stub__helper来调用__printf函数。把这个地址替换后就可以调用自己的函数了。对应的地址在程序中赋给**indirect_symbol_bindings 通过section加载命令，定位这个节对应的在Indirect Symbols中的起始位置，计算公式为:*indirect_symbol_indices = indirect_symtab + section-&gt;reserved1, 上图中的起始index就是：24。在Indirect Symbols找到第24位（起始从0开始）， 确定好起始位置后，Indirect Symbols表和前面确定的__DATA端中地址就是一一对应的。如下图，第一个是NSStringFromClass，上图第一个也是NSStringFromClass。 利用第三步中的Indirect Symbols表中的数据定位对应Symbol table中的index,比如下图中printf对应偏移地址00000A6,对应10进制为166。 上面计算的Symbol table起始地址为10000C4D8,这是一个数组，找到index为166的数据： 利用第五步得到的结果，取出在String table中的偏移值，上图中的_printf偏移值为00002CC，String table起始地址为0x10000D02C,则对应的地址为10000D2F8,这样就可以获得函数名，如果和传入的函数名相同，则将第二步获取的函数实现的地址和传入要改变的地址进行替换，并把原地址保存下来。 查找方法名参考官方的图： 参考文章： fishhook源码分析 动态修改 C 语言函数的实现]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>fishhook</tag>
        <tag>hook</tag>
        <tag>machO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios优化-包大小分析-MACHO文件解析]]></title>
    <url>%2F2017%2F10%2F26%2Fmach-o-parser%2F</url>
    <content type="text"><![CDATA[导读在分析linkMap文件的时候，遇到一个有趣的问题：获取类名可以用_objc_classname, 获取方法名可以用_objc_methname。可是怎么将方法名称和对象名称对应起来，程序是如何对应这两部分数据的。带着这个疑问研究了下macho的文件结构。 MACHO文件说明macho文件是mac os或ios系统可执行文件的格式，系统通过加载这个格式来执行代码。 相关结构如图： 注：来源于：（http://www.jianshu.com/p/f1a61b53398f） 具体每部分的含义可以参考这个定义： mach-0 loader.h 这里简单讲几个我比较关注的： 注：下面都是以64位做演示说明，cpu结构为arm64。 MachO Header的结构 数据结构为： 1234567891011121314/* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;; 第一个四字节数叫做magic number,可以得到使用的是64位还是32位系统 第二个字节和第三个字节是CPU类型 第四个字节是文件类型。MH_EXECUTE表示可执行文件 第五个字节和第六个字节表示load commands的个数和长度 第7个字节是加载的flag信息。具体参考loader.h中的文件 MachO load command程序检索完Header之后就开始加载和解析Load Commands了。 相关代码在mach_loader.c,通过递归调用加载命令。 load_comand的数据结构为: 12345678910111213141516171819202122/* * The load commands directly follow the mach_header. The total size of all * of the commands is given by the sizeofcmds field in the mach_header. All * load commands must have as their first two fields cmd and cmdsize. The cmd * field is filled in with a constant for that command type. Each command type * has a structure specifically for it. The cmdsize field is the size in bytes * of the particular load command structure plus anything that follows it that * is a part of the load command (i.e. section structures, strings, etc.). To * advance to the next load command the cmdsize can be added to the offset or * pointer of the current load command. The cmdsize for 32-bit architectures * MUST be a multiple of 4 bytes and for 64-bit architectures MUST be a multiple * of 8 bytes (these are forever the maximum alignment of any load commands). * The padded bytes must be zero. All tables in the object file must also * follow these rules so the file can be memory mapped. Otherwise the pointers * to these tables will not work well or at all on some machines. With all * padding zeroed like objects will compare byte for byte. */struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;; 每一个command都需要包含 cmd：加载类型 cmdsize:加载的大小 相关的最主要的解析源码在mach_loader.c里的parse_machfile方法里.最主要的代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146 /* * Act on struct load_command&apos;s for which kernel * intervention is required. */ switch(lcp-&gt;cmd) &#123; case LC_SEGMENT: if (pass != 2) break; if (abi64) &#123; /* * Having an LC_SEGMENT command for the * wrong ABI is invalid &lt;rdar://problem/11021230&gt; */ ret = LOAD_BADMACHO; break; &#125; ret = load_segment(lcp, header-&gt;filetype, control, file_offset, macho_size, vp, map, slide, result); break; case LC_SEGMENT_64: if (pass != 2) break; if (!abi64) &#123; /* * Having an LC_SEGMENT_64 command for the * wrong ABI is invalid &lt;rdar://problem/11021230&gt; */ ret = LOAD_BADMACHO; break; &#125; ret = load_segment(lcp, header-&gt;filetype, control, file_offset, macho_size, vp, map, slide, result); break; case LC_UNIXTHREAD: if (pass != 1) break; ret = load_unixthread( (struct thread_command *) lcp, thread, slide, result); break; case LC_MAIN: if (pass != 1) break; if (depth != 1) break; ret = load_main( (struct entry_point_command *) lcp, thread, slide, result); break; case LC_LOAD_DYLINKER: if (pass != 3) break; if ((depth == 1) &amp;&amp; (dlp == 0)) &#123; dlp = (struct dylinker_command *)lcp; dlarchbits = (header-&gt;cputype &amp; CPU_ARCH_MASK); &#125; else &#123; ret = LOAD_FAILURE; &#125; break; case LC_UUID: if (pass == 1 &amp;&amp; depth == 1) &#123; ret = load_uuid((struct uuid_command *) lcp, (char *)addr + mach_header_sz + header-&gt;sizeofcmds, result); &#125; break; case LC_CODE_SIGNATURE: /* CODE SIGNING */ if (pass != 1) break; /* pager -&gt; uip -&gt; load signatures &amp; store in uip set VM object &quot;signed_pages&quot; */ ret = load_code_signature( (struct linkedit_data_command *) lcp, vp, file_offset, macho_size, header-&gt;cputype, result); if (ret != LOAD_SUCCESS) &#123; printf(&quot;proc %d: load code signature error %d &quot; &quot;for file \&quot;%s\&quot;\n&quot;, p-&gt;p_pid, ret, vp-&gt;v_name); ret = LOAD_SUCCESS; /* ignore error */ &#125; else &#123; got_code_signatures = TRUE; &#125; break;#if CONFIG_CODE_DECRYPTION case LC_ENCRYPTION_INFO: case LC_ENCRYPTION_INFO_64: if (pass != 3) break; ret = set_code_unprotect( (struct encryption_info_command *) lcp, addr, map, slide, vp, header-&gt;cputype, header-&gt;cpusubtype); if (ret != LOAD_SUCCESS) &#123; printf(&quot;proc %d: set_code_unprotect() error %d &quot; &quot;for file \&quot;%s\&quot;\n&quot;, p-&gt;p_pid, ret, vp-&gt;v_name); /* * Don&apos;t let the app run if it&apos;s * encrypted but we failed to set up the * decrypter. If the keys are missing it will * return LOAD_DECRYPTFAIL. */ if (ret == LOAD_DECRYPTFAIL) &#123; /* failed to load due to missing FP keys */ proc_lock(p); p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL; proc_unlock(p); &#125; psignal(p, SIGKILL); &#125; break;#endif default: /* Other commands are ignored by the kernel */ ret = LOAD_SUCCESS; break; &#125; 其中几个比较重要的加载命令: LC_SEGMENT(LC_SEGMENT_64),用于加载段（segment）的命令，有下面段用下面加载:__PAGEZERO、__TEXT、DATA、__LINKEDIT。其中__PAGEZERO程序保留区,用于处理NULL异常，__TEXT保存程序代码和字符，DATA保存程序使用的二进制数据，__LINKEDIT保存动态库需要原始数据如符号、字符串、重定位条目等。也保留了起始地址信息，后续的LC_SYMTAB和LC_DYSYMTAB也是基于起始地址来算出相关偏移的值 LC_LOAD_DYLINKER,用来读取动态加载库路径，通常在usr/lib/dyld，然后使用这个命令加载后面的动态库（最终还是递归调用parse_machfile）。 LC_MAIN，用来读取程序入口 LC_CODE_SIGNATURE 用来验证程序签名 LC_DYSYMTAB加载Dynamic Symbol Table,保存了C Function相关的链接信息，通过数据偏移，可以查询LC_SYMTAB保存的C Function相关的信息，比如方法名和实现等。fishhook,利用这个机制可以找到C对应的方法实现，并动态替换成要hook的函数，具体参考我的fishHooker源码解析。 经过LoadCommand，程序正式被加载到内存中，最终运行起来。 MACHO Section下面的主要是相关的节数据，主要有： __TEXT段节名含义 123456789101112131. __text: 代码节，存放机器编译后的代码2. __stubs: 用于辅助做动态链接代码（dyld）.3. __stub_helper:用于辅助做动态链接（dyld）.4. __objc_methname:objc的方法名称5. __cstring:代码运行中包含的字符串常量,比如代码中定义`#define kGeTuiPushAESKey @&quot;DWE2#@e2!&quot;`,那DWE2#@e2!会存在这个区里。6. __objc_classname:objc类名7. __objc_methtype:objc方法类型8. __ustring:9. __gcc_except_tab:10. __const:存储const修饰的常量11. __dof_RACSignal:12. __dof_RACCompou:13. __unwind_info: __DATA段节名含义 1234567891011121314151617181920211. __got:存储引用符号的实际地址，类似于动态符号表，存储了`__nl_symbol_ptr`相关函数指针。2. __la_symbol_ptr:lazy symbol pointers。懒加载的函数指针地址（C代码实现的函数对应实现的地址）。和__stubs和stub_helper配合使用。具体原理暂留。3. __mod_init_func:模块初始化的方法。4. __const:存储constant常量的数据。比如使用extern导出的const修饰的常量。5. __cfstring:使用Core Foundation字符串6. __objc_classlist:objc类列表,保存类信息，映射了__objc_data的地址7. __objc_nlclslist:Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行。8. __objc_catlist: categories9. __objc_nlcatlist:Objective-C 的categories的 +load函数列表。10. __objc_protolist:objc协议列表11. __objc_imageinfo:objc镜像信息12. __objc_const:objc常量。保存objc_classdata结构体数据。用于映射类相关数据的地址，比如类名，方法名等。13. __objc_selrefs:引用到的objc方法14. __objc_protorefs:引用到的objc协议15. __objc_classrefs:引用到的objc类16. __objc_superrefs:objc超类引用17. __objc_ivar:objc ivar指针,存储属性。18. __objc_data:objc的数据。用于保存类需要的数据。最主要的内容是映射__objc_const地址，用于找到类的相关数据。19. __data:暂时没理解，从日志看存放了协议和一些固定了地址（已经初始化）的静态量。20. __bss:存储未初始化的静态量。比如：`static NSThread *_networkRequestThread = nil;`其中这里面的size表示应用运行占用的内存，不是实际的占用空间。所以计算大小的时候应该去掉这部分数据。21. __common:存储导出的全局的数据。类似于static，但是没有用static修饰。比如KSCrash里面`NSDictionary* g_registerOrders;`, g_registerOrders就存储在__common里面 这部分数据会在上一步LoadCommand命令时，加载到内存里。 解析__objc_classlist在看linkMap的时候，很奇怪的是，获取类名可以用_objc_classname, 获取方法名可以用_objc_methname，但是两个数据怎么匹配起来的，根据查相关资料，是通过__objc_classlist来映射的。 在解析的时候需要两个工具：MachOView和Hopper， 加载可执行文件选用真机编译,编译选项选择Build Active Architecture Only,这样只生成一个CPU类型的文件，方便后续分析，然后在工程的DerivedData/**/Build/Products/**-iphonesos/**.app中显示包内容，把和工程同名的文件copy到自己的目录下。 打开`MachOview,打开刚才的可执行文件。 解析__objc_class结构直接看__objc_classlist节， 然后看下__objc_classlist数据结构，这个是个内存地址占用64位,经过分析，__objc_classlist,保存的地址，映射的是__objc_data的地址，在MachOView中，对应的数据为： 使用Hopper打开可执行文件，按G，在搜索框里输入这个地址，比如输入0000000100009278 之后显示了一个数据结构。 这个数据对应的数据结构为： 12345678typedef struct objc_class&#123; struct __objc_class* isa; struct __objc_class* wuperclass; struct __objc_cache* cache; struct __objc_vtable* vtable; struct __objc_ data* data;&#125;objc_class; 第一个是64位指针，保存isa指针，指向了MetaClass指针，对应的地址为00000001000092A0,在Hopper中搜索这个地址，得到的数据为: 第二个指向父类的指针，对应地址为0000000000000000 第5个指向data,对应的地址为：00000001000082C8, 这个数据保存在__objc_const节,对应的数据结构为__objc_data,在Hopper中搜索这个地址，得到的数据为： 对应的具体数据为： `` 解析__objc_data对应的数据结构为： 12345678910111213typedef struct objc_data&#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; uint32_t reserved; void* ivarlayout; char* name; struct __objc_method_list* baseMethod; struct __objc_protos* baseProtocol; struct __objc_ivars* ivars; struct __objc_ivars weakIvarLayout; struct __objc_ivars baseProperties;&#125; 主要的几个数据结构: name 保存的类名称。这个地址为：00000001000076B6,对应的数据在__objc_classname段里,用Hopper查看这个地址，对应的名称为ViewController baseMethod,保存了类所有方法，这个地址为：0000000100008278 , 对应数据在__objc_const,可以在这里找到对应的数据。对应数据结构为__objc_method_list,在Hopper,查看： 解析__objc_method_list对应的数据结构为: 1234typedef struct objc_method_list&#123; uint32_t flags; uint32_t count;&#125; 使用到的数据主要是count，对应数据为00000003,对应10进制数为3，说明有3个方法。具体方法对应的数据结构为： 123456typedef struct objc_method&#123; char* name; char* signature; void* implementation;&#125; 这个数据结构占用24(8*3)字节。objc_method_list结构体占用8字节，所以从0000000100008278开始，偏移8个字节，到0000000100008280就是第一个方法的起始位置，再偏移24个字节到0000000100008298,就是第二个方法起始地址位置，以此类推，最后一个方法占用地址为00000001000082b0 ~ 00000001000082c7。 先看第一个方法存储的数据为： 然后分别解析这些地址: 0000000100006924,在__objc_methname段里，对应方法名称。 000000010000770F,在__objc_methtype段里，对应方法签名，这里的值为v16@0:8,代表含义可以参考这里关于type encodings的理解–runtime programming guide 0000000100004A20,在__text节里，对应的数据为： 最终类需要的数据完全解析完成。 ps：想要知道数据结构是什么，可以在Hopper的右侧导航栏下，点击Manager type查看。 参考 iOS安全–从Mach-o文件结构分析类名和方法名 从macho中解析类名 深入理解Macho文件（二）- 消失的OBJC段与新生的DATA段 mach-o文件格式分析 Macho kern main.m 方法之前的优化 OSX内核加载mach-o流程分析 iOS程序启动-&gt;dyld加载-&gt;runtime初始化(初识)]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>machO</tag>
        <tag>iOS</tag>
        <tag>包大小</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iSee使用说明]]></title>
    <url>%2F2017%2F10%2F25%2Fios-isee%2F</url>
    <content type="text"><![CDATA[导读为了方便对linkMap做解析，参考zyangSir的iSee工程，做了linkMap文件解析的工具，欢迎使用。 ios包大小分析工具iSeegithub地址 简介iSee是一款分析iOS可执行文件成分的工具，通过加载XCode在项目编译期间产生的linkMap文件，能够输出项目中每个类(包括第三方静态库)，在最终可执行文件中占用的长度信息。本工具根据zyangSir的代码做了部分修改。主要功能有： 各个可执行文件占用大小 可执行文件中，各个段占用的大小（包括方法+常量字符串等） 未使用到的类 未使用到的方法 使用方法建议使用真机生成的文件测试，目前看对arm64架构支持最好。优先使用arm64相关文件检测。 导出生成linkmap文件 在XCode编译选项中打开”WriteLinkMapFile” 选择好真机/模拟器,Debug/Release。编译项目,进入项目的Derived Data目录 依次进入Build/Intermediates/项目名.build/ 目录, 找到相应模式下的编译产物文件夹 可以看到一个名为 项目名-LinkMap-normal-CPU架构.txt的文件，在iSee中点击linkMap文件按钮，导入这个文件 导出生成的可执行文件 在上一步的Derived Data目录下, 看到.app结尾的文件，邮件显示包内容，找到和工程名称一样的一个可执行文件，把这个文件copy到相关目录 在iSee中点击可执行文件，导入刚才的文件 之后程序会自动执行分析。 简单说明 现在对arm64支持比较好，所以建议用这个格式测试。 对于未使用方法和未使用类，使用otool工具来做辅助分析 未使用方法和未使用类，有误报可能，主要误报的是一些实现协议的类，这一部分是动态使用的，所以静态分析不出来。 详细技术细节可以参考我的博客：https://dishibolei.github.io/]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>包大小</tag>
        <tag>linkmap解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS优化-包大小分析-linkMap]]></title>
    <url>%2F2017%2F08%2F17%2Fios-linkmap%2F</url>
    <content type="text"><![CDATA[LinkMap解析 导读IOS在做包大小优化的时候，需要分析包大小组成，然后通过包大小组成来有针对的做优化。其中最主要的工具就是linkmap文件的解析，下面文章讲简单说明如何解析linkmap文件。 如何生成linkMap文件 Xcode开启编译选项Write Link Map File XCode -&gt; Project -&gt; Build Settings -&gt; 搜map -&gt; 把Write Link Map File选项设为yes，并指定好linkMap的存储位置 编译后，到编译目录里找到该txt文件，文件路径就是上面设定的路径，我的位于： ~/Library/Developer/Xcode/DerivedData/FFProject-gdxobffdqcwvyleustpwgfdxslqp/Build/Intermediates/FFProject.build/Debug-iphonesimulator/FFProject.build linkMap文件结构解析1. 基础信息123# Path: /Users/bolei/Library/Developer/Xcode/DerivedData/FFProject-gdxobffdqcwvyleustpwgfdxslqp/Build/Products/Debug-iphonesimulator/FFProject.app/FFProject //路径# Arch: x86_64 //架构 2.类表1234# Object files: //类文件[ 0] linker synthesized[ 1] dtrace[ 2] /Users/bolei/Library/Developer/Xcode/DerivedData/FFProject-gdxobffdqcwvyleustpwgfdxslqp/Build/Intermediates/FFProject.build/Debug-iphonesimulator/FFProject.build/Objects-normal/x86_64/PAFFConfig.o 这里保存了所有用到的类生成的.o文件，也包括用到的dylib库。前面[num]是序号，类是按照顺序保存的，后续可以通过序号查到具体对应的哪个类。 3.段表123456789101112131415161718192021222324252627282930313233343536373839# Sections:# Address Size Segment Section0x100002460 0x00E382DF __TEXT __text0x100E3A740 0x000019D4 __TEXT __stubs0x100E3C114 0x0000273E __TEXT __stub_helper0x100E3E860 0x0009D78B __TEXT __cstring0x100EDBFEB 0x00089F7A __TEXT __objc_methname0x100F65F65 0x0000CFCD __TEXT __objc_classname0x100F72F32 0x00012A27 __TEXT __objc_methtype0x100F8595A 0x000122E8 __TEXT __ustring0x100F97C44 0x00067DA8 __TEXT __gcc_except_tab0x100FFF9F0 0x000259C8 __TEXT __const0x1010253B8 0x0000017C __TEXT __entitlements0x101025534 0x0000037B __TEXT __dof_RACSignal0x1010258AF 0x000002E8 __TEXT __dof_RACCompou0x101025B98 0x00016928 __TEXT __unwind_info0x10103C4C0 0x00013B40 __TEXT __eh_frame0x101050000 0x00000010 __DATA __nl_symbol_ptr0x101050010 0x00000D30 __DATA __got0x101050D40 0x00002270 __DATA __la_symbol_ptr0x101052FB0 0x00000030 __DATA __mod_init_func0x101052FE0 0x00036580 __DATA __const0x101089560 0x0005EB20 __DATA __cfstring0x1010E8080 0x000040A8 __DATA __objc_classlist0x1010EC128 0x00000448 __DATA __objc_nlclslist0x1010EC570 0x00000AA8 __DATA __objc_catlist0x1010ED018 0x00000048 __DATA __objc_nlcatlist0x1010ED060 0x00000780 __DATA __objc_protolist0x1010ED7E0 0x00000008 __DATA __objc_imageinfo0x1010ED7E8 0x001A2B80 __DATA __objc_const0x101290368 0x00020CE8 __DATA __objc_selrefs0x1012B1050 0x00000168 __DATA __objc_protorefs0x1012B11B8 0x00003B80 __DATA __objc_classrefs0x1012B4D38 0x00002620 __DATA __objc_superrefs0x1012B7358 0x00010AF0 __DATA __objc_ivar0x1012C7E48 0x000286E0 __DATA __objc_data0x1012F0530 0x0000BB48 __DATA __data0x1012FC080 0x00011A40 __DATA __bss0x10130DAC0 0x00000538 __DATA __common 接下来是段表，描述了不同功能的数据保存的地址，通过这个地址就可以查到对应内存里存储的是什么数据。 其中第一列是起始地址，第二列是段占用的大小，第三个是段类型，第四列是段名称，每一行初始地址 = 上一行的初始地址+占用大小 其中： __TEXT 表示代码段,用于执行，可读不可以写，可以被执行 __DATA 表示数据段，用于存储数据，可以读写，不可以执行 其中： 第一个段是__PAGEZERO 地址从0到0x100000000，程序保留字段。 3.1 段表内容含义__TEXT段节名含义 123456789101112131. __text: 代码节，存放机器编译后的代码2. __stubs: 用于辅助做动态链接代码（dyld）.3. __stub_helper:用于辅助做动态链接（dyld）.4. __objc_methname:objc的方法名称5. __cstring:代码运行中包含的字符串常量,比如代码中定义`#define kGeTuiPushAESKey @&quot;DWE2#@e2!&quot;`,那DWE2#@e2!会存在这个区里。6. __objc_classname:objc类名7. __objc_methtype:objc方法类型8. __ustring:9. __gcc_except_tab:10. __const:存储const修饰的常量11. __dof_RACSignal:12. __dof_RACCompou:13. __unwind_info: __DATA段节名含义 1234567891011121314151617181920211. __got:存储引用符号的实际地址，类似于动态符号表2. __la_symbol_ptr:lazy symbol pointers。懒加载的函数指针地址。和__stubs和stub_helper配合使用。具体原理暂留。3. __mod_init_func:模块初始化的方法。4. __const:存储constant常量的数据。比如使用extern导出的const修饰的常量。5. __cfstring:使用Core Foundation字符串6. __objc_classlist:objc类列表,保存类信息，映射了__objc_data的地址7. __objc_nlclslist:Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行。8. __objc_catlist: categories9. __objc_nlcatlist:Objective-C 的categories的 +load函数列表。10. __objc_protolist:objc协议列表11. __objc_imageinfo:objc镜像信息12. __objc_const:objc常量。保存objc_classdata结构体数据。用于映射类相关数据的地址，比如类名，方法名等。13. __objc_selrefs:引用到的objc方法14. __objc_protorefs:引用到的objc协议15. __objc_classrefs:引用到的objc类16. __objc_superrefs:objc超类引用17. __objc_ivar:objc ivar指针,存储属性。18. __objc_data:objc的数据。用于保存类需要的数据。最主要的内容是映射__objc_const地址，用于找到类的相关数据。19. __data:暂时没理解，从日志看存放了协议和一些固定了地址（已经初始化）的静态量。20. __bss:存储未初始化的静态量。比如：`static NSThread *_networkRequestThread = nil;`其中这里面的size表示应用运行占用的内存，不是实际的占用空间。所以计算大小的时候应该去掉这部分数据。21. __common:存储导出的全局的数据。类似于static，但是没有用static修饰。比如KSCrash里面`NSDictionary* g_registerOrders;`, g_registerOrders就存储在__common里面 3.2 后续符号表内容3.2.1 代码节123456# Symbols:# Address Size File Name0x100002460 0x00000080 [ 2] +[PAFFConfig instance]0x1000024E0 0x00000050 [ 2] ___22+[PAFFConfig instance]_block_invoke0x100002530 0x00000090 [ 2] -[PAFFConfig init]apiType] 这里面保存里类里面的方法内存情况。其中 第一列是起始地址位置，通过这个地址我们可以查上面的段表，可以知道，对应的节为__text。 第二列是大小，通过这个可以算出方法占用的大小。 第三列是归属的类（.o文件），这里序号是2，通过查类表可以知道对应的类是PAFFConfig。 通过这部分我们可以分析出来每个类对应的方法的大小是多少。 3.2.3 方法名节(__objc_methname)12345678910110x100EDBFEB 0x00000006 [ 2] literal string: alloc0x100EDBFF1 0x00000005 [ 2] literal string: init0x100EDBFF6 0x0000000B [ 2] literal string: mainBundle0x100EDC001 0x0000000F [ 2] literal string: infoDictionary0x100EDC010 0x0000000E [ 2] literal string: objectForKey:0x100EDC01E 0x0000000C [ 2] literal string: setAppName:0x100EDC02A 0x0000000C [ 2] literal string: setVersion:0x100EDC036 0x0000000C [ 2] literal string: setApiType:0x100EDC042 0x00000009 [ 2] literal string: instance0x100EDC04B 0x00000008 [ 2] literal string: isDebug 这部分保存了类里方法的字符串信息(所以原则上方法名起短一些，是可以减少占用的 - -!) 分析步骤： 查看第一列起始地址，然后在上面的段表中查看这个地址在那个节里，可以看到在__objc_methname中。 通过第二列对比大小 通过第三列解析对应的类和对应方法名称 类列表节（__objc_classlist）1234567891011121314151617180x1010E8080 0x00000008 [ 2] anon0x1010E8088 0x00000008 [ 3] anon0x1010E8090 0x00000008 [ 4] anon0x1010E8098 0x00000008 [ 5] anon0x1010E80A0 0x00000008 [ 7] anon0x1010E80A8 0x00000008 [ 9] anon0x1010E80B0 0x00000008 [ 10] anon0x1010E80B8 0x00000008 [ 11] anon0x1010E80C0 0x00000008 [ 12] anon0x1010E80C8 0x00000008 [ 13] anon0x1010E80D0 0x00000008 [ 14] anon0x1010E80D8 0x00000008 [ 15] anon0x1010E80E0 0x00000008 [ 16] anon0x1010E80E8 0x00000008 [ 17] anon0x1010E80F0 0x00000008 [ 18] anon0x1010E80F8 0x00000008 [ 19] anon0x1010E8100 0x00000038 [ 20] anon0x1010E8138 0x00000030 [ 21] anon __objc_classlist存储了所有类的虚拟地址。即__objc_data地址。这里都是二进制数据，具体保存了什么，看下对应的数据结构 __objc_data的数据结构为： 1234567891011typedef struct objc_class&#123; unsigned long long isa; unsigned long long wuperclass; unsigned long long cache; unsigned long long vtable; unsigned long long data; unsigned long long reserved1; unsigned long long reserved2; unsigned long long reserved3;&#125;objc_class; 其中最主要的是data字段，保存了_objc_const节对应的数据地址。数据结构为: 12345678910111213typedef struct objc_classdata&#123; long long flags; long long instanceStart; long long instanceSize; long long reserved; unsigned long long ivarlayout; unsigned long long name; unsigned long long baseMethod; unsigned long long baseProtocol; unsigned long long ivars; unsigned long long weakIvarLayout; unsigned long long baseProperties;&#125; 这里面保存了类名，方法名，协议名，ivar指针和属性对应的地址。最后对应到相应的TEXT段里就能找到。比如类名在__objc_classname可以找到，方法名可以在__objc_methname。应用程序就是通过这个结构来寻找哪个类对应的那个方法，从而执行相关逻辑 如何找到没有用到的类和方法？通过__objc_classrefs和_objc_classname对比就可以知道哪些类没用。其中__objc_classrefs的解析需要通过otool命令才能解析 同理：通过__objc_selrefs和_objc_methname对比可以知道哪些方法没有使用到。其中__objc_selrefs需要用otool命令才能解析。 otool -v -s __DATA __objc_selrefs &lt;path&gt; otool使用这个用来做反汇编的，比如分析哪些类被使用了，需要用这个工具。 比如获取使用到的方法可以用这个命令： otool -V -s __DATA __objc_selrefs &lt;path&gt; -arch arm64 | open -f 其中path是你的应用编译后生成的可执行文件。通常在项目的DerivedData目录下的Build/Products//.app文件，然后显示包内容，有个和工程同名的可执行文件。比如我的目录： /Users/bolei/Library/Developer/Xcode/DerivedData/FFProject-gqpkbetfhlofkxcmyfwpmkfqubun/Build/Products/Release-iphoneos/FFProject.app/FFProject 打印使用到的类： _objc_classrefs otool -V -o FFProject -arch arm64 | open -f 可以打印出来objc Section中的所有数据 otool说明 代码参考相关代码欢迎fork：https://github.com/dishibolei/iSee.git 主要功能包含了 代码占用分析 未使用类分析 未使用方法分析 参考 IOS Section Document IOS 官方Section介绍 mach-o文件结构分析类名方法名 load 方法全程跟踪 iOS APP可执行文件的组成]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>包大小</tag>
        <tag>linkmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS安全-切换后台背景模糊]]></title>
    <url>%2F2017%2F08%2F17%2Fsafe-backgroud-blurry%2F</url>
    <content type="text"><![CDATA[导读我们在双击切换到后台的时候，背景会有缩略图，而缩略图会暴漏用户的部分敏感数据，所以要求切换到后台后，缩略图需要做毛玻璃模糊处理。一些银行类的应用会要求这么做。比如招商银行。 切换到后台效果，可以看到时钟是没有模糊的。 实现思路也很简单在切换后台前，截取当前页面，然后做高斯模糊，然后加在window上。切到前台前，将这个加的页面移除出去。 关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175//// PAFFBlurryView.m// Pods//// Created by bolei on 16/10/9.////#import "BLBlurryView.h"#import &lt;Accelerate/Accelerate.h&gt;#define kBlurryTag 10009@implementation BLBlurryView- (instancetype)initWithFrame:(CGRect)frame blurryView:(UIView *)view &#123; self = [super initWithFrame:frame]; if (self) &#123; UIImage *sourceImage = [self getCurrentImageWithView:view]; if (sourceImage) &#123; UIImage *image = [UIImage imageWithData:UIImageJPEGRepresentation(sourceImage, 1.0)]; UIImage *sImage = [self blurryImage:image withBlurLevel:0.1]; UIImageView *bgView = [[UIImageView alloc] initWithFrame:frame]; bgView.image = sImage; [self addSubview:bgView]; &#125; &#125; return self;&#125;+ (void)showBlurryViewInWindow &#123; UIWindow *window = [UIApplication sharedApplication].delegate.window; BLBlurryView *view = [[BLBlurryView alloc] initWithFrame:window.frame blurryView:nil]; view.tag = kBlurryTag; for (UIWindow *window in [[UIApplication sharedApplication] windows]) &#123; if (window.windowLevel == UIWindowLevelNormal) &#123; UIView *preView = [window viewWithTag:kBlurryTag]; if (preView) &#123; [preView removeFromSuperview]; &#125; [window addSubview:view]; &#125; &#125;&#125;+ (void)removeBlurryViewInWindow &#123; for (UIWindow *window in [[UIApplication sharedApplication] windows]) &#123; if (window.windowLevel == UIWindowLevelNormal) &#123; UIView *view = [window viewWithTag:kBlurryTag]; if (view) &#123; [view removeFromSuperview]; &#125; &#125; &#125;&#125;- (UIImage *)getCurrentImageWithView:(UIView *)view&#123; UIView *sourceView = view; if (sourceView == nil) &#123; sourceView = [self getCurrentVisibleView]; &#125; if (sourceView == nil) &#123; return nil; &#125; UIGraphicsBeginImageContext(sourceView.bounds.size); [sourceView.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125;- (UIImage *)blurryImage:(UIImage *)image withBlurLevel:(CGFloat)blur &#123; if (blur &lt; 0.f || blur &gt; 1.f) &#123; blur = 0.5f; &#125; int boxSize = (int)(blur * 100); boxSize = boxSize - (boxSize % 2) + 1; CGImageRef img = image.CGImage; vImage_Buffer inBuffer, outBuffer; vImage_Error error; void *pixelBuffer; CGDataProviderRef inProvider = CGImageGetDataProvider(img); CFDataRef inBitmapData = CGDataProviderCopyData(inProvider); inBuffer.width = CGImageGetWidth(img); inBuffer.height = CGImageGetHeight(img); inBuffer.rowBytes = CGImageGetBytesPerRow(img); inBuffer.data = (void*)CFDataGetBytePtr(inBitmapData); pixelBuffer = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img)); if(pixelBuffer == NULL) NSLog(@"No pixelbuffer"); outBuffer.data = pixelBuffer; outBuffer.width = CGImageGetWidth(img); outBuffer.height = CGImageGetHeight(img); outBuffer.rowBytes = CGImageGetBytesPerRow(img); error = vImageBoxConvolve_ARGB8888(&amp;inBuffer, &amp;outBuffer, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend); if (error) &#123; NSLog(@"error from convolution %ld", error); &#125; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef ctx = CGBitmapContextCreate( outBuffer.data, outBuffer.width, outBuffer.height, 8, outBuffer.rowBytes, colorSpace, kCGImageAlphaNoneSkipLast); CGImageRef imageRef = CGBitmapContextCreateImage (ctx); UIImage *returnImage = [UIImage imageWithCGImage:imageRef]; //clean up CGContextRelease(ctx); CGColorSpaceRelease(colorSpace); free(pixelBuffer); CFRelease(inBitmapData); CGColorSpaceRelease(colorSpace); CGImageRelease(imageRef); return returnImage;&#125;- (UIView *)getCurrentVisibleView &#123; UIWindow *window = [[UIApplication sharedApplication].delegate window]; UIViewController *rootViewController = window.rootViewController; if ([rootViewController isKindOfClass:[UINavigationController class]]) &#123; return ((UINavigationController *)rootViewController).visibleViewController.view; &#125; return rootViewController.view;&#125;/*// Only override drawRect: if you perform custom drawing.// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect &#123; // Drawing code&#125;*/@end 逻辑并不复杂，主要麻烦的点在于什么时候调用，切到后台涉及到四个周期： applicationWillResignActive 失去焦点的时候会首先调用 applicationDidEnterBackground 切换到后台后调用。在WillResignActive之后调用 applicationWillEnterForeground 将要回到前台的时候调用 applicationDidBecomeActive 已经到前台后调用 其中点击home，切换到后台，四个状态都会调用。但是双击home的话只会调用applicationWillResignActive和applicationDidBecomeActive 一般调用显示和消失需要成对调用。所以两个方案： 方案1：applicationWillResignActive调用消失，然后applicationWillEnterForeground调用显示 方案2：applicationDidEnterBackground调用消失，然后applicationDidBecomeActive调用显示 方案1的问题是：在调用applicationWillResignActive，需要截屏需要做模糊效果，如果这个调用时间过长，就不会显示模糊的效果，对于复杂的页面经常会出现这个问题，需要找更好的算法去解决，目前没找到好的方案。而且进入到APP会有比较久的时间的模糊效果。 方案2的问题是：在双击home的时候，这个模糊效果不会生效。相对来说更推荐方案二。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全-秘钥硬编码解决]]></title>
    <url>%2F2017%2F06%2F26%2Fsafe-hard-code%2F</url>
    <content type="text"><![CDATA[导读程序中经常用到需要用对称加密算法加解密，通常的做法是在代码中写死，硬编码到代码里。但是通过工具分析代码，是可以看到编码信息的，所以安全的做法是做一次变换，再硬编码进去。 秘钥硬编码是常见的安全问题。攻击者拿到编译后的包后，经过分析是可以拿到所有使用到的字符串的（可以使用ida），很容易泄露对称秘钥，导致安全问题。(非对称算法的公钥是可以公开的) 最安全的解决方案是：对称秘钥按照会话随机生成。通过非对称的（比如RSA）算法，两边交换秘钥。 不过大部分场景还是需要把秘钥写在程序中的，对称秘钥如何存储一直是安全的大难题，目前没有什么方案可以保证安全存储对称秘钥的方案，相关的方案只是增加了破解难度而已。 相对安全的方案是：对秘钥进行变换。 使用的数学方法有： 移位和循环移位 移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。 置换 就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。 扩展 就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。 压缩 就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。 异或 这是一种二进制布尔代数运算。异或的数学符号为⊕ ，它的运算法则如下：1⊕1 = 00⊕0 = 01⊕0 = 10⊕1 = 1 也可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。 迭代 迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。 通常是对秘钥进行变形，然后程序里面提供相关接口在运算过程中获取真实的秘钥。下面是几种常见的简单方案： 方案1：使用RSA加密保存方案很简单，使用RSA的私钥进行加密，RSA的公钥写死在客户端里，使用的时候使用RSA进行一次解密操作。 优点： 简单容易实现，一般项目里都需要使用非对称的加密方法，利用公开的秘钥做一次解密。缺点： 如果知道了算法很容易破解。 方案2：使用Base64进行编码，再保存对秘钥进行Base64编码，然后再解码。 方案3：使用AES再次加密再使用一次对称加密，两次不要使用相同的秘钥 方案4：自定义方案下面给一个方案，对数据进行变形。算法如下： 对每一个字节做一次循环右移 对每一个字节用一个表的数据做位异或操作 转为16进制数 相关代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//// Utils.m// Safe//// Created by bolei on 2017/7/18.// Copyright © 2017年 bolei. All rights reserved.//#import "Utils.h"#import "NSData+HexString.h"//使用自己的映射表char changeMap[16] = &#123;'w','o','s','h','i','b','o','l','e','i','s','h','a','i','g','e'&#125;;@implementation Utils+ (NSString *)hardKeyEncode:(NSString *)key &#123; if ([key length] == 0) &#123; return @""; &#125; NSData *data = [key dataUsingEncoding:NSUTF8StringEncoding]; NSUInteger i, len; unsigned char *bytes; len = data.length; bytes = (unsigned char*)data.bytes; for (i = 0; i &lt; len; i++) &#123; NSUInteger index = i % 16; unsigned char p = bytes[i]; p = (p &lt;&lt; 7 || p &gt;&gt; 1); //公式：循环左移n位： (x&gt;&gt;(N - n) ) | (x&lt;&lt;n)；循环右移n位： (x&lt;&lt;(N - n) ) | (x&gt;&gt;n)。 p ^= changeMap[index]; &#125; NSData *changeData = [NSData dataWithBytes:bytes length:len]; NSString *keyHex = [data hexStringFromData:changeData]; return keyHex;&#125;+ (NSString *)hardKeyDecode:(NSString *)key &#123; if ([key length] == 0) &#123; return @""; &#125; NSData *data = [NSData dataFromHexString:key]; if ([data length] == 0) &#123; return @""; &#125; NSUInteger i, len; unsigned char *bytes; len = data.length; bytes = (unsigned char*)data.bytes; for (i = 0; i &lt; len; i++) &#123; NSUInteger index = i % 16; unsigned char p = bytes[i]; p = (p &gt;&gt; 7 || p &lt;&lt; 1); //公式：循环左移n位： (x&gt;&gt;(N - n) ) | (x&lt;&lt;n)；循环右移n位： (x&lt;&lt;(N - n) ) | (x&gt;&gt;n)。 p ^= changeMap[index]; &#125; NSData *changeData = [NSData dataWithBytes:bytes length:len]; NSString *result = [NSString stringWithUTF8String:changeData.bytes]; return result;&#125;@end 参考 IDA使用 IOS安全– 字符串加密那点小事]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS应用安全-加解密算法简述]]></title>
    <url>%2F2017%2F05%2F25%2Fsave-encode%2F</url>
    <content type="text"><![CDATA[导读客户端经常遇到需要对数据进行加密的情况，那应该如何加密，选用什么样的加密算法，是本文想要讨论的问题。 如果把我们的数据比作笔记，那数据加密相当于给笔记本上了锁，解密相当于打开锁看到笔记。而打开锁的钥匙一定是在私人手里的，外人是打不开的。所以数据加密一定有三个关键字： 1.加密2.解密3.秘钥 所以有些常见的算法不是数据加密的范围，这个开发需要注意。比如Base64编码，MD5算法。 Base64只是把数据编码，通俗讲只是把原来用汉语写的笔记内容，改成用英语写的内容，只要懂转换规则的任何人都能得到数据。所以老板说把数据加下密，一定不是让你Base64一下或者用其他编码重新编码下，编码算法不涉及到数据安全。 MD5算法也是数据处理的一种方式，更多的被用在数据验证身上。用上面的例子来讲，MD5算法把整本书的内容变成了一句标题，通过标题是没办法推算出整个书讲什么的。因为根本没有解密的步骤，所以也不属于加密算法。 字符编码计算机的所有数据，最终都是由多个二进制bit(0/1)来存储和传输的，但是怎么从0/1转化成我们可读的文字，就涉及到编码的知识了。下面是基础的编码概念。 ASCII （NSASCIIStringEncoding）使用一个字节大小表示的128个字符。其中这些字符主要是因为字符，现在很少使用这个编码，因为不够用。ASCII字符占用一个字节。ASCII码表 主要使用到的是英文字母的大小写转换。大写的A~Z编码+32等于小写的a~z。 UNICODE (NSUnicodeStringEncoding)ASCII只能表示128个字符，对于英文国家来说足够了，对于我们中国来说，我们有几万个汉字不够啊。于是我们创造出了GB2312等等我们自己的字符集。日本也觉得我也不够啊，我也搞个字符集。这些字符集彼此是不兼容的，没办法转换，同样的字符ABCD,我们可能表示好,日本就可能就表示坏。于是程序猿们觉得我要搞个标准，大家都按照标准来。 于是就有了UNICODE编码。它是所有字符的国际标准编码字符集。这个是为了解决ASCII字符不够的问题。同时让所有组织使用同一套编码规则，解决编码不兼容的问题。所以现在通用的编码规则都是UNICODE编码。UNICODE向下兼容ASCII编码。UNICODE最大长度可以到4个字节。不过通常只使用两个字节表示。所以通常认为UNICODE占用2字节数据。 UTF-8 （NSUTF8StringEncoding）其实UNICODE已经足够使用了，不过因为如果是ASCII表示的字符（比如英文）只需要1字节就可以了，UNICODE表示的话其中一个字节全是0，这个字节浪费了，英语国家的程序猿觉得：我靠，我又不需要那么多复杂的字符,浪费我流量和空间啊，不行！！，于是出现了对UNICODE的转换，也就是UTF-8格式，可以保证原ASCII字符依然用一个字节表示，非ASCII字符使用多个字符表示。 UNICODE到UTF-8的规则如下： 按照UNICODE编码的范围，算出需要几个字节，比如1个字节数，2个字数节，3个字节数，4个字节数。具体范围参考下面的图。 单字节和ASCII码完全相同， 对于其他字节数，字节1的前面用1填充，几个字节数就添加几个1，后面补一个0。其他字节都用10开头。 剩余的位置，按照顺序把原始数据补齐。 例子： “汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 对于UTF-8编码的文件，会在文件头写入EF BB BF,表明是UTF-8编码。 UTF-16 （NSUTF16StringEncoding）UTF-16的编码方法是： 如果二进制（流b小于0x10000，也就是十进制的0到65535之内，则直接使用两字节表示。 如果二进制流b大于等于0x10000，将b-0x10000的结果中的前 10 位作为高位和0xD800进行逻辑或操作，将后10 bit作为低位和0xDC00做逻辑或操作，这样组成的4个字节就构成了b的编码。 举个例子。假设要算（U+2A6A5，四个繁体字龙）在UTF-16下的值，因为它超过 U+FFFF，所以 2A6A5-10000=0x1A6A5=。 前10位0001 1010 01 | 0xD800 = 0xD896。 后10位10 1010 0101 | 0xDC00 = 0xDEA5。 所以U+ 2A6A5 在UTF-16中的像是D8 96 DE A5。 注：上文参考：精确解释Unicode 在IOS程序里面NSUTF16StringEncoding和NSUnicodeStringEncoding是等价的。 UTF-16大端/小端（NSUTF16BigEndianStringEncoding/NSUTF16LittleEndianStringEncoding）大小端主要表明了，系统存储数据的顺序。因为UTF-16至少两个字节，这两个字节传输过来后，接收的人需要知道哪个字节是在前，哪个字节在后。然后系统才知道改如何存取。 Unicode规范中用字节序标记字符（BOM）来标识字节序，它的编码是FEFF。这样如果接收者收到FEFF，就表明这个字节流是高位在前的；如果收到FFFE，就表明这个字节流是低位在前的。 比如“汉”字的Unicode编码是0x6C49。 对于大端的文件数据为：FE FF 6c 49对于小端的文件数据为：FF FE 49 6c 对于大小端的概念，本人经常搞混，什么高地址存低字节的，绕一绕就晕了。下面是我的理解： 对于一个16进制数0x1234,我们知道这个数对应的是两个字节，占用16个比特。 系统中是按照字节为单位去保存数据的。一个地址空间对应1个字节。比如0x1234如果要存储在计算机里，需要占用两个地址空间。我们假设这个地址空间起始是0x00，因为需要两个字节，所以还需要一个地址空间来保存，即0x01。其中明显0x01是高地址空间。 所以问题就在于，对于0x1234这个数据保存，是0x01地址保存0x12还是保存0x24。 如果把0x1234看成字符串形式，按照正常顺序存储，先存0x12,后存0x34,对应的就是大端模式。 如果按照字节顺序，0x12是高位，0x34是低位，应该0x12存储在高位地址0x02,低位字节0x34存储在低位地址0x01。这种方式就是小端模式。 为了怕记混，可以这么记：我最大，按字符串顺序存储，我看的最舒服所以是大端。反面的就是小端的。 地址偏移 大端模式 小端模式 0x00 12 34 0x01 34 12 附：代码判断大小端的代码。 原理是生成一个两字节的数据，然后转为1字节的char数据。大端取到的是第一个高字节，小端取到的是第二个低字节。 123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; short x = 1; //0x0001 char *p = (char *)&amp;x; if(*p) &#123; printf(&quot;little\n&quot;); &#125; else &#123; printf(&quot;large\n&quot;); &#125; return 0;&#125; UTF-32详细的本人没看懂，实际中没有用到这个编码，这个编码使用4字节存储。也有大小端之分 总结 字符编码就是把可读的字符转化为二进制数据方法，字符解码就是把二进制数据转化为可读的方法。 ASCII占用1个字节，只有128个字符，主要是英文字符。 UNICODE是国际标准编码字符集，包含了所有已知符号。 UTF-8是UNICODE编码的一种实现方式，兼容ASCII码，也就是英文字符占1个字节，汉字可能占两个字节或三个字节。 UTF-16也是UNICODE编码的一种实现方式，通常和UNICODE编码一致，占用两个字节，分大小端。 Base64编码Base64编码的作用是把非ASCII的字符转换为ASCII的字符。很多加密算法，很喜欢做一次Base64转换。原因是使用Base64编码后，所有的数据都是ASCII字符，方便在网络上传输。 设计思路是：Base64把每三个8Bit的字节转换为四个6Bit的字节（38 = 46 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节。所以Base64算法生成的数据会比原数据大1/3左右。 比如： 图片这种二进制数据就可以转换为Base64作为文本传输。 比如有中文的数据，可以通过Base64转为可以显示的ASCII数据 简单说明： 将字符按照文字编码转化为二进制字节。 每3字节化为一组（24bit），如果字节不够，最后输出结果补=。然后再把每一组拆分成4个组，每个组6bit,如果不足6bit后面补0。 将每个6bit前面补足两个0，凑够8位。 然后按照新分出来的每8位转成10进制数，按照表里面的查找，转为对应的ASCII字符。 举例： 字符bl如何转化为Base64编码： bl对应的ASCII码为： 01100010和01101100,因为只有两个，所以有一个输出结果是= 按照每三个字节分组：0110001001101100 按照每个组6bit分4个组,不足6位的补0：011000,100110,110000 在前面补0,凑够8位：00011000,00100110,00110000 转为10进制：24,38,48。 查表得到：Y,m,w 最后补=,所以结果为Ymw= 标准的程序实现可以参考：GTMBase64.m。 说明： Base64是一种编码算法，不是加密算法,他的作用不是加密，而是用最简的ASCII码来传输文本数据，屏蔽掉设备网络差异，是为了方便传输的一种算法。很多加密算法，最后生成的是二进制数据，不是可见字符，而传输的一般是通过字符传输，所以常见的二进制转化方式就是Base64算法。 哈希散列算法一个萝卜一个坑这个俗语形容这个算法很贴切。官方的定义为： 散列（Hash）函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。 安全的哈希算法要满足下面条件： 固定长度。不同长度的数据，生成的固定长度的数据 唯一性。不同的数据，生成的结果一定不同。相同的数据，每次输出的结果一定一样。 不可逆。对于生成后的数据，反推回原数据，通过算法是不可能的。 防篡改。两个输出的散列值相同，则原数据一定相同。如果两个输出的散列值不同，则原数据一定不同。 从上面的特点可以知道散列值主要使用的场景： 生成唯一的值做索引，比如哈希表 用作数据签名，校验数据完整性和有效性。 密码脱敏处理。 MD5算法MD5算法是最常用的散列算法。 对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为十六个32位子分组，经过了一系列的处理后，算法的输出由4个32位分组组成，将这4个32位分组级联后将生成1个128位散列值。 算法有点复杂，没有看懂，放下不表。 下面是本人的简单理解： MD5算法效率是比较快的。 MD5防碰撞能力比较强，只有少数的几个例子有出现碰撞的情况。但也不影响安全性。 MD5生成的是固定128位,16个字节。 MD5算法安全性目前主流看法是MD5逐渐有被攻克的风险。但是目前还没有有效算法破解。 主要的破解方法是使用数据库保存常见的字符串的MD5值，然后通过反查得到原始数据。也就是如果用户的密码很常见就很容易破解。如果用户密码是随机的，那就没什么平台可以破解了。 下面对于是用MD5的观点： MD5不是加密算法，重要的用户密码应该加密存储。做MD5只是为了脱敏，也就是不让相关人员知道原文是什么（包括内鬼）。 极重要数据是用更安全的算法：比如用户密码数据使用更安全的算法，比如SHA1算法。传输过程中也进一步加密。 如果使用MD5算法，在原始值里面加入盐值。盐值要尽量随机。因为如果加入随机值后原始值也变得随机，使用暴力破解就基本不可能了。即result = MD5(password + salt) 关于加盐这里有个破解的网站，大家可以看下常用的策略其实都可以破解。安全性主要是盐如何选择。 盐值要是随机字符，数据尽量长一些，只有这样才能保证最后数据的随机。 盐值尽量保证每个用户不一样，增加破解的难度。 盐值的保存可以是前后端约定,固化在APP里，但是也应该和用户相关，比如salt=(固化的值+用户信息)。可以是通过一些随机值变化得来：比如用户注册时间等信息做盐值。可以是每次随机生成，当做参数带给后端，后端保存密码+盐值。安全性从低到高。还有做多次MD5的，个人觉得意义不大。 个人推荐的一个方案。result = MD5 (password + salt)。salt的计算方法是：MD5(Random(128)+ uid)。其中Random(128)表示一个随机128位字符串，两端可以一致，固化在代码里。uid是用户唯一标示，比如登陆用的用户名。这样对于破解者来说就需要先拿到这个salt值，然后对每个用户都要生成一个唯一的128位的盐值，去生成对应的库，破解成本就非常高了。 其实目前暴漏出来的是攻击者把整个数据库的内容拿到后，暴力解密出原文。但是MD5加盐也好变换也好都是可以通过前端代码查到算法的，通过算法就可以生成常用数据对应的MD5库。所以密码做MD5更重要的是脱敏处理，不能做为安全的加密使用，重要的用户密码持久化或传输过程中一定是要通过加密算法处理的。这样只要安全保存私钥就可以了。在很多金融公司，大量使用硬件加密机做加密处理，然后保存，更加大了破解难度。所以如果你的密码是使用加密再保存的，使用固定盐值的已经可以满足要求了。如果担心可以加上用户的注册时间或服务器时间戳做盐值。 SHA1SHA1也是一种HASH算法。是MD5的替代方案。生成的数据是160位，20个字节。 目前SHA1也被认为不安全,google找到了算法进行了碰撞,所以普遍推荐使用新的SHA2代替。Google已经开始废弃这个算法了。 SHA2 SHA-224、SHA-256、SHA-384，和SHA-512并称为SHA-2。 新的散列函数并没有接受像SHA-1一样的公众密码社区做详细的检验，所以它们的密码安全性还不被大家广泛的信任。 虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。 所以目前推荐使用SHA2相关的算法做散列算法。 其中SHA-256输出为256位，32字节。SHA-512输出为512位，64字节。 HMacHMac是秘钥相关的哈希算法。和之前的算法不同的在于需要一个秘钥，才能生成输出。主要是基于签名散列算法。可以认为是散列算法加入了加密逻辑，所以相比SHA算法更难破解，包含下面的算法。 1234567891011121314151617181920/*! @enum CCHmacAlgorithm @abstract Algorithms implemented in this module. @constant kCCHmacAlgSHA1 HMAC with SHA1 digest @constant kCCHmacAlgMD5 HMAC with MD5 digest @constant kCCHmacAlgSHA256 HMAC with SHA256 digest @constant kCCHmacAlgSHA384 HMAC with SHA384 digest @constant kCCHmacAlgSHA512 HMAC with SHA512 digest @constant kCCHmacAlgSHA224 HMAC with SHA224 digest */enum &#123; kCCHmacAlgSHA1, kCCHmacAlgMD5, kCCHmacAlgSHA256, kCCHmacAlgSHA384, kCCHmacAlgSHA512, kCCHmacAlgSHA224&#125;;typedef uint32_t CCHmacAlgorithm; HMAC主要应用场景： 密码的散列存储，因为需要散列的时候需要密码，实际上相当于算法里加了盐值。使用的密码要随机和用户相关，请参考盐值的生产规则。 用于数据签名。双方使用共同的秘钥，然后做签名验证。秘钥可以固化，也可以会话开始前协商，增加签名篡改和被破解的难度。 PS：目前项目中的密码散列算法，采用的就是HMac算法。 总结 密码保存和传输需要做散列处理。但是散列算法主要是脱敏，不能替代加密算法。 如今常用的Md5算法和SHA1算法都不再安全。所以推荐使用SHA-2相关算法。 散列算法应该加入盐值即：result=HASH(password+salt)。其中盐值应该是随机字符串且每个用户不一样。 HMac引入了秘钥的概念，如果不知道秘钥，秘钥不同，散列值也不同，相当于散列算法加入了盐值。可以把它当做更安全的散列算法使用。 算法实现算法都是使用苹果自己的Security.framework框架实现的，只需要调用相关算法就可以了。推荐一个github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229//// NSData+KKHASH.m// SecurityiOS//// Created by cocoa on 16/12/15.// Copyright © 2016年 dev.keke@gmail.com. All rights reserved.//#import &quot;NSData+KKHASH.h&quot;#include &lt;CommonCrypto/CommonDigest.h&gt;#import &lt;CommonCrypto/CommonHMAC.h&gt;@implementation NSData (KKHASH)- (NSData *)hashDataWith:(CCDIGESTAlgorithm )ccAlgorithm&#123; NSData *retData = nil; if (self.length &lt;1) &#123; return nil; &#125; unsigned char *md; switch (ccAlgorithm) &#123; case CCDIGEST_MD2: &#123; md = malloc(CC_MD2_DIGEST_LENGTH); bzero(md, CC_MD2_DIGEST_LENGTH); CC_MD2(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_MD2_DIGEST_LENGTH]; &#125; break; case CCDIGEST_MD4: &#123; md = malloc(CC_MD4_DIGEST_LENGTH); bzero(md, CC_MD4_DIGEST_LENGTH); CC_MD4(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_MD4_DIGEST_LENGTH]; &#125; break; case CCDIGEST_MD5: &#123; md = malloc(CC_MD5_DIGEST_LENGTH); bzero(md, CC_MD5_DIGEST_LENGTH); CC_MD5(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_MD5_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA1: &#123; md = malloc(CC_SHA1_DIGEST_LENGTH); bzero(md, CC_SHA1_DIGEST_LENGTH); CC_SHA1(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA224: &#123; md = malloc(CC_SHA224_DIGEST_LENGTH); bzero(md, CC_SHA224_DIGEST_LENGTH); CC_SHA224(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA224_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA256: &#123; md = malloc(CC_SHA256_DIGEST_LENGTH); bzero(md, CC_SHA256_DIGEST_LENGTH); CC_SHA256(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA256_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA384: &#123; md = malloc(CC_SHA384_DIGEST_LENGTH); bzero(md, CC_SHA384_DIGEST_LENGTH); CC_SHA384(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA384_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA512: &#123; md = malloc(CC_SHA512_DIGEST_LENGTH); bzero(md, CC_SHA512_DIGEST_LENGTH); CC_SHA512(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA512_DIGEST_LENGTH]; &#125; break; default: md = malloc(1); break; &#125; free(md); md = NULL; return retData; &#125;- (NSData *)hmacHashDataWith:(CCHmacAlgorithm )ccAlgorithm key:(NSString *)key &#123; NSData *retData = nil; if (self.length &lt;1) &#123; return nil; &#125; unsigned char *md; const char *cKey = [key cStringUsingEncoding:NSUTF8StringEncoding]; switch (ccAlgorithm) &#123; case kCCHmacAlgSHA1: &#123; md = malloc(CC_SHA1_DIGEST_LENGTH); bzero(md, CC_SHA1_DIGEST_LENGTH); CC_SHA1(self.bytes, (CC_LONG)self.length, md); CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH]; &#125; break; case kCCHmacAlgSHA224: &#123; md = malloc(CC_SHA224_DIGEST_LENGTH); bzero(md, CC_SHA224_DIGEST_LENGTH); CCHmac(kCCHmacAlgSHA224, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA224_DIGEST_LENGTH]; &#125; break; case kCCHmacAlgSHA256: &#123; md = malloc(CC_SHA256_DIGEST_LENGTH); bzero(md, CC_SHA256_DIGEST_LENGTH); CCHmac(kCCHmacAlgSHA256, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA256_DIGEST_LENGTH]; &#125; break; case kCCHmacAlgSHA384: &#123; md = malloc(CC_SHA384_DIGEST_LENGTH); bzero(md, CC_SHA384_DIGEST_LENGTH); CCHmac(kCCHmacAlgSHA384, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA384_DIGEST_LENGTH]; &#125; break; case kCCHmacAlgSHA512: &#123; md = malloc(CC_SHA512_DIGEST_LENGTH); bzero(md, CC_SHA512_DIGEST_LENGTH); CCHmac(kCCHmacAlgSHA512, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA512_DIGEST_LENGTH]; &#125; break; case CCDIGEST_MD5: &#123; md = malloc(CC_MD5_DIGEST_LENGTH); bzero(md, CC_MD5_DIGEST_LENGTH); CCHmac(kCCHmacAlgMD5, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_MD5_DIGEST_LENGTH]; &#125; break; default: md = malloc(1); break; &#125; free(md); md = NULL; return retData;&#125;- (NSString *)hexString&#123; NSMutableString *result = nil; if (self.length &lt;1) &#123; return nil; &#125; result = [[NSMutableString alloc] initWithCapacity:self.length * 2]; for (size_t i = 0; i &lt; self.length; i++) &#123; [result appendFormat:@&quot;%02x&quot;, ((const uint8_t *) self.bytes)[i]]; &#125; return result;&#125;+ (NSData *)dataWithHexString:(NSString *)hexString &#123; NSMutableData * result; NSUInteger cursor; NSUInteger limit; NSParameterAssert(hexString != nil); result = nil; cursor = 0; limit = hexString.length; if ((limit % 2) == 0) &#123; result = [[NSMutableData alloc] init]; while (cursor != limit) &#123; unsigned int thisUInt; uint8_t thisByte; if ( sscanf([hexString substringWithRange:NSMakeRange(cursor, 2)].UTF8String, &quot;%x&quot;, &amp;thisUInt) != 1 ) &#123; result = nil; break; &#125; thisByte = (uint8_t) thisUInt; [result appendBytes:&amp;thisByte length:sizeof(thisByte)]; cursor += 2; &#125; &#125; return result;&#125;@end 对称加密算法对称加密，指双方使用的秘钥是相同的。加密和解密都使用这个秘钥。 对称加密的优点为： 加密效率高 加密速度快 可以对大数据进行加密 缺点为： 秘钥安全性无法保证，以现在的技术手段来说，默认对称秘钥的秘钥是非安全的，可以被拿到的。 加密方法 DES ：数据加密标准。 是一种分组数据加密技术，先将数据分成固定长度64位的小数据块，之后进行加密。 速度较快，适用于大量数据加密。DES密钥为64位,实际使用56位。将64位数据加密成64位数据。 3DES：使用三组密钥做三次加密。 是一种基于 DES 的加密算法，使用3个不同密钥对同一个分组数据块进行3次加密，如此以使得密文强度更高。3DES秘钥为DES两倍或三倍，即112位或168位。其实就是DES的秘钥加强版。 AES ：高级加密标准。 是美国联邦政府采用的一种区块加密标准。 相较于 DES 和 3DES 算法而言，AES 算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准。AES秘钥长度为128、192、256位。 使用到的基础数学方法： 移位和循环移位 移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。 置换 就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。 扩展 就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。 压缩 就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。 异或 这是一种二进制布尔代数运算。异或的数学符号为⊕ ，它的运算法则如下：1⊕1 = 00⊕0 = 01⊕0 = 10⊕1 = 1 也可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。 迭代 迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。 对于对称加密来说，有几个共同要点： 密钥长度；（关系到密钥的强度） 加密模式；（ecb、cbc等等） 块加密算法里的块大小和填充方式区分； 加密模式ECB 模式ECB ：电子密本方式，最古老,最简单的模式，将加密的数据分成若干组，每组的大小跟加密密钥长度相同；然后每组都用相同的密钥加密。OC对应的为kCCOptionECBMode ECB的特点为： 每次Key、明文、密文的长度都必须是64位； 数据块重复排序不需要检测； 相同的明文块(使用相同的密钥)产生相同的密文块，容易遭受字典攻击； 一个错误仅仅会对一个密文块产生影响，所以支持并行计算； CBC模式 CBC ：密文分组链接方式。与ECB相比，加入了初始向量IV。将加密的数据分成若干组，加密时第一个数据需要先和向量异或之后才加密。后面的数据需要先和前面的数据异或，然后再加密。是OC默认的加密模式。 CBC的特点为： 每次加密的密文长度为64位(8个字节); 当相同的明文使用相同的密钥和初始向量的时候CBC模式总是产生相同的密文; 密文块要依赖以前的操作结果,所以，密文块不能进行重新排列; 可以使用不同的初始化向量来避免相同的明文产生相同的密文,一定程度上抵抗字典攻击; 一个错误发生以后,当前和以后的密文都会被影响; 块大小和填充方式对称算法的第一步就是对数据进行分组，每一个组的大小称为快大小，比如DES需要将数据分组为64位（8个字节），如果数据不够64位就需要进行补位。 PKCS7Padding填充OC中指定的填充方法只有kCCOptionPKCS7Padding，对应JAVA的PKCS5Padding填充方式。算法为计算缺几位数，然后就补几位数，数值为下面的公式： value=k - (l mod k) ,K=块大小，l=数据长度，如果l=8, 则需要填充额外的8个byte的8 比如块大小为8字节，数据为DD DD DD DD4个字节，带入公式，l=4,k=8,计算 8 - （4 mod 8）= 4 ,所以补充4个4，补位后得到DD DD DD DD 04 04 04 04。 唯一特别的是如果最后位数是够的，也需要额外补充，比如数据是DD DD DD DD DD DD DD DD8个字节,带入公式，l=8,k=8,计算 8 - （8 mod 8）= 8，所以补位后得到DD DD DD DD DD DD DD DD 08 08 08 08 08 08 08 08。 所以如果考虑补位，实际输出buffer大小要加上快大小，防止buffer不够。 Zero Padding（No Padding）补位的算法和PKCS7Padding一致，只不过补的位为0x00,比如数据为DD DD DD DD4个字节，带入公式，l=4,k=8,计算 8 - （4 mod 8）= 4 ,所以补充4个00，补位后得到DD DD DD DD 00 00 00 00。 非常不建议用这种模式，因为解密后的数据会多出补的00。如果原始数据以00结尾(ASCII码代表空字符)，就没办法区分出来了。 几种算法比较 算法 秘钥长度（字节） 分组长度（字节） 加密效率 破解难度 DES 8 8 较快（22.5MB/S） 简单 3DES 24 8 慢（12MB/S） 难 AES 16/24/32 16 快（51.2MB/s） 难 IOS 代码实现解析下面以AES代码实现为例，说明下IOS加解密算法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131+ (NSString *)AES128Encrypt:(NSString *)plainText key:(NSString *)gkey iv:(NSString *)gIv padding:(BOOL)padding&#123; //先处理秘钥，如果秘钥不够算法长度，就用0填充，如果长于算法长度就截断。 char keyPtr[kCCKeySizeAES128+1]; //申请秘钥buffer，这里根据不同算法导入需要的key长度。AES128是16个字节，对应的值kCCKeySizeAES128。 memset(keyPtr, 0, sizeof(keyPtr)); //使用0填充，保证秘钥长度达到要求。 [gkey getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; //将传入的秘钥copy进秘钥buffer里 //注意这个只在模式为CBC下有效， //处理向量值，默认模式为CBC。如果指定了kCCOptionECBMode模式，就不需要这个向量。 char ivPtr[kCCBlockSizeAES128+1]; //申请向量的buffer，长度为块长度。AES128块长度为kCCBlockSizeAES128。 memset(ivPtr, 0, sizeof(ivPtr)); [gIv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding]; //将传入的值copy进向量buffer NSData* data = [plainText dataUsingEncoding:NSUTF8StringEncoding]; NSUInteger dataLength = [data length]; //注意这个只在不指定padding的情况下有效，需要填充0，算法为num_to_fill= k - (length mod k)，如果指定了kCCOptionPKCS7Padding，就不需要人为填充。 long long newSize = dataLength; int diff = padding ? 0 : kCCKeySizeAES128 - (dataLength % kCCKeySizeAES128); if(diff &gt; 0) &#123; newSize = dataLength + diff; &#125; char dataPtr[newSize]; memcpy(dataPtr, [data bytes], [data length]); for(int i = 0; i &lt; diff; i++) &#123; dataPtr[i + dataLength] = 0x00; &#125; //输出的buffer size_t bufferSize = newSize + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); memset(buffer, 0, bufferSize); size_t numBytesCrypted = 0; CCOptions option = padding ? kCCOptionPKCS7Padding : 0x0000; option = gIv.length &gt; 0 ? option : option | kCCOptionECBMode; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, option,// 0x0000, //No padding | CBC模式 需要补零且需要iv向量// kCCOptionPKCS7Padding, // kCCOptionPKCS7Padding | CBC模式 需要iv向量 //kCCOptionPKCS7Padding | kCCOptionECBMode, // kCCOptionPKCS7Padding | kCCOptionECBMode 不需要iv向量，也不需要补零// kCCOptionECBMode, // No padding | kCCOptionECBMode 不需要补零，不需要iv向量 keyPtr, kCCKeySizeAES128, ivPtr, dataPtr, sizeof(dataPtr), buffer, bufferSize, &amp;numBytesCrypted); if (cryptStatus == kCCSuccess) &#123; NSData *resultData = [NSData dataWithBytesNoCopy:buffer length:numBytesCrypted]; resultData = [resultData base64EncodedDataWithOptions:(NSDataBase64EncodingOptions)0]; NSString *encryptedString = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding]; return encryptedString; &#125; free(buffer); return nil;&#125;+ (NSString *)AES128Decrypt:(NSString *)encryptText key:(NSString *)gkey iv:(NSString *)gIv padding:(BOOL)padding&#123; //复制秘钥buffer char keyPtr[kCCKeySizeAES128 + 1]; memset(keyPtr, 0, sizeof(keyPtr)); [gkey getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; //复制向量buffer char ivPtr[kCCBlockSizeAES128 + 1]; memset(ivPtr, 0, sizeof(ivPtr)); [gIv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding]; NSData *data = [[NSData alloc] initWithBase64EncodedString:encryptText options:0]; NSUInteger dataLength = [data length]; size_t bufferSize = dataLength + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); //计算采用哪种模式和填充方式 CCOptions option = padding ? kCCOptionPKCS7Padding : 0x0000; option = gIv.length &gt; 0 ? option : option | kCCOptionECBMode; size_t numBytesCrypted = 0; //解密 CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, option,// 0x0000, //No padding | CBC模式 需要补零且需要iv向量// kCCOptionPKCS7Padding, // kCCOptionPKCS7Padding | CBC模式 需要iv向量 //kCCOptionPKCS7Padding | kCCOptionECBMode, // kCCOptionPKCS7Padding | kCCOptionECBMode 不需要iv向量，也不需要补零// kCCOptionECBMode, // No padding | kCCOptionECBMode 不需要补零，不需要iv向量 keyPtr, kCCBlockSizeAES128, ivPtr, [data bytes], dataLength, buffer, bufferSize, &amp;numBytesCrypted); if (cryptStatus == kCCSuccess) &#123; NSData *resultData = [NSData dataWithBytesNoCopy:buffer length:numBytesCrypted]; NSString *result = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding]; if ([result length] &gt; 0 &amp;&amp; !padding) &#123; //如果是非填充模式，解析后的数据会多出填充的'\0',所以需要去掉。 long byteWithoutZero = numBytesCrypted; const char *utf8Str = [result UTF8String]; //从后开始扫描，查到需要截断的长度 for (long i = byteWithoutZero - 1; i &gt; 0; i --) &#123; if (utf8Str[i] != '\0') &#123; break; &#125; byteWithoutZero --; &#125; NSString *finalReslut = [[NSString alloc] initWithBytes:utf8Str length:byteWithoutZero encoding:NSUTF8StringEncoding]; return finalReslut; &#125; return result; &#125; free(buffer); return nil;&#125; 建议和说明 建议使用ECB模式（kCCOptionECBMode），填充采用kCCOptionPKCS7Padding。这种使用最广泛，和PHP、JAVA（AES/ECB/PKCS5Padding）都适配。联调的时候需要注意两端是否一致，不一致是调不通的。 通常数据加密后，会做一次Base64编码进行传输，有些应用也会将数据转为二进制字符串传输。 如果不指定模式，则默认是CBC模式，需要用到向量IV。 如果不指定填充格式，则需要自行补0x00处理，在解码后也需要把补的0x00去除掉，网上很多资料解码后没有去除，会多出\0。 说明和总结 建议对称加密使用AES加密。DES无论安全性和效率都不如AES算法。 加密建议用kCCOptionPKCS7Padding填充方式，对应的JAVA模式为PKCS5Padding 如果用CBC模式，需要使用初始向量，初始向量两端应该一致。如果不使用应该指定kCCOptionECBMode。也建议用这个模式，兼容性最好。 秘钥应该用随机数生成对应的位数。AES128为16个字节，也就是16个字符。不要用短密码,比如：111111,这样真的很蠢。 对称加密的安全隐患主要在于秘钥的保存。重要会话的秘钥应该随机生成，使用非对称加密来沟通交换秘钥，策略可以参考我的另一篇文章IOS应用安全-HTTP/HTTPS网络安全(一)。 如果秘钥需要硬编码到程序里，应该做脱敏运算，比如做位运算进行变形等。后面会专门写怎么解决秘钥硬编码问题。 非对称加密算法非对称秘钥加密算法的特点是：加密和解密使用不同的秘钥。 非对称加密需要两个秘钥：公开秘钥和私有秘钥。两个秘钥是不同的，而且通过公钥是无法推算出私钥的，使用公钥加密的数据只有用私钥解密。 非对称算法的特点： 解决了秘钥保存的问题。公钥可以发布出去，任何人都可以使用，也不用担心被人获取到，只要保证私钥的安全就可以了。而对称加密，因为秘钥相同，客户端泄露了就不安全了。 加密和解密的效率不高，只适合加解密少量的数据。而对称加密效率要高。这里有一篇文章对比AES和RSA算法的性能对比。 RSA算法RSA是目前最常用的非对称加密算法。 算法原理可以看下这篇文章：RSA算法原理。 RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。RSA的秘钥长度在2048位，现有的技术手段是无法破解的（实际的可以暴力破解的位数为768位，也就是768位的大数才有可能暴力进行因数分解）。 RSA算法优点： 算法原理简单，我都快看懂了。 安全性也足够高，目前没有证据和方案可以破解1048位以上秘钥的RSA算法。 缺点： 安全性取决于秘钥长度，推荐的要至少1048位，但是这么高位数的秘钥生成速度很慢，所以没法做一次会话一次秘钥。 加解密的效率很低，相对于对称加密，差好几个量级，而且也不支持加密长数据。 国密算法SM2中国特有的算法，国家强制要求金融机构使用国密算法。包括SM1/SM2/SM3/SM4。其中SM4为对称加密算法。SM3是哈希算法。SM2为非对称加密算法。但是国家只给算法原理，没有给出常用的算法实现，所以是件蛋疼的事情。 算法我也没看懂。因为项目中使用到了，所以做了一些研究。相关代码可以参考我的github,IOS SM2开源实现非常少，而且都有些问题，要么基于openSSL，代码特别大。要么基于libtommath库，但是有一些问题，SM2无法调通。所以两个结合重新整理的下代码。这个代码只保证SM2算法有效性，因为经过实际使用过，其他的项目未用到。 SM2的加密流程 抛出掉数学方法，下面是本人的一些理解： SM2需要依赖于一个曲线，一般使用国家推荐曲线。如果曲线不对，肯定是无法加解密的。曲线参数 #define SM2_P "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF" #define SM2_A "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC" #define SM2_B "28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93" #define SM2_N "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123" #define SM2_G_X "32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7" #define SM2_G_Y "BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0" SM2公钥分为两部分：Pub_x和Pub_y。每个都是32字节，总共是64字节。私钥长度现在还不清楚是多少，有资料说是要32位，但是文档里面未提到。字节数如果不对说明生成秘钥算法有问题。 输出数据分为3段：C1C2C3,其中C1是64个字节，C2和原始数据大小相同，即原文是6个字节，C2就是6个字节，C3是32个字节。所以总长度是64+32+原文长度（字节）。如果长度不对，要看下是否是人为添加了其他字段。 算法涉及到哈希算法，标准是使用SM3的hash算法，SM3的Hash算法生成的字节为32字节，这个联调的时候一定要保证一致。 加密步骤说明： 第一步计算随机数，如果这个不是随机的,是固定的，那后面的结果每次输出就是唯一的。 通过随机数rank和曲线的G_x、G_y、P、A五个参数，通过ECC算法C1=[k]G = (x1,y1)生成一个点（x1,y1）。拼接起来就是C1数据。C1数据应该是64个字节。有些算法里面会在前面填充0x04，变成65个字节 通过公钥的P_x和P_y,随机数rank,A,P，通过ECC算法[k]PukeyB = [k](XB,YB) = (x2,y2)计算出(x2,y2)，x2和y2的大小为分别为32字节 将上面的(x2,y2)拼接，然后做KDF（密码派生算法）计算，输出原文长度（klen）的t值。t= KDF(x2||y2, klen),KDF一般使用的是SM3的算法。结果t的大小和原文的大小一致。 然后将t和原文做异或运算，得到C2,C2的大小和原文一致。 然后将(x2,原文,x3)拼接，计算一次SM3的Hash算法,生成的数据放入C3中，C3的大小为32字节。 最后把C1C2C3拼接到一起，长度为64+原文长度+32字节。注意，老的标准为C1C3C2,有些实现的是这种模式。 注：这其中ECC算法是标准算法，大部分第三方实现的都没有问题。主要是KDF算法和Hash算法会有不同。这个联调的时候需要搞清楚。 SM2解密流程流程图如下： 解密步骤说明 先判断C1是否在曲线上。C1长度为64字节，取数据的前64字节就可以了。所以两端一定要用同样的曲线。 使用C1的数据,曲线参数（A,P）,私钥dA，使用ECC算法生成(x2,y2)，dA*C1 = dA*(x2,y2) = dA*[k]*(Xg,Yg) 使用(x2,y2)和C2的长度（总长度-64-32），使用KDF计算t。 使用c2异或t，达到M’ 计算(x2,M’,y2)的hash值U。 比较U和C3数据是否是一致的，如果一致就输出M’ KDF算法说明：文档里的描述 密钥派生函数的作用是从一个共享的秘密比特串中派生出密钥数据。在密钥协商过程中，密钥派生函数作用在密钥交换所获共享的秘密比特串上，从中产生所需的会话密钥或进一步加密所需的密钥数据。密钥派生函数需要调用密码杂凑函数。设密码杂凑函数为Hv( )，其输出是长度恰为v比特的杂凑值。密钥派生函数KDF(Z, klen)：输入：比特串Z，整数klen(表示要获得的密钥数据的比特长度，要求该值小于(232-1)v)。输出：长度为klen的密钥数据比特串K。a)初始化一个32比特构成的计数器ct=0x00000001；b)对i从1到⌈klen/v⌉执行：b.1)计算Hai=Hv(Z ∥ ct)；b.2) ct++；c)若klen/v是整数，令Ha!⌈klen/v⌉ = Ha⌈klen/v⌉，否则令Ha!⌈klen/v⌉为Ha⌈klen/v⌉最左边的(klen −(v × ⌊klen/v⌋))比特；d)令K = Ha1||Ha2|| · · · ||Ha⌈klen/v⌉−1||Ha!⌈klen/v⌉。 简化下说明： 先分组,分组的大小为klen/v,向上取整,其中klen是数据长度，v是HASH算法输出长度。SM3的输出长度为32字节。 然后每一组循环，把原始数据Z和计数器ct拼接，做SM3_Hash运算得到Hai。然后计数器ct+1。 最终生成的数据Ha1,Ha2…拼接起来，然后截断到klen长度也就是数据长度。 HASH算法说明官方使用的是SM3密码杂凑算法，输入为小于2的64次方bit，输出为256bit（32字节）。 总结： 国密算法的基础是使用曲线计算。曲线应该使用官方推荐的曲线，曲线不同加解密肯定失败。 国密算法生成的数据为C1C2C3,其中C1为固定的64字节，c2和原始数据一样长，C3为固定的32字节。有些要求数据前面加上’0x04’,旧的版本输出是C3C1C2，这两点要注意。 公钥分为P_x和P_y,都是32字节长度。私钥长度从资料上看没有限制，是一个随机数[1,N-2]。N为曲线参数。 加密过程中使用了SM3的散列算法(官方叫杂凑算法)，这个算法输出为32字节的数据。如果对端没有用这个算法，两端也无法加解密成功。 总结 字符编码是为了把可见字符和二进制之间做一层转化。其中UNICODE编码是国际编码标准。UTF-8是这种编码格式的实现方式。特点是ASCII码的字符占用一个字节，其他的比如中文字符占用两到三个字符。 Base64也是一种编码方式，主要用于把二进制数据转化为ASCII字符，方便传输。现在很多加密算法习惯在加密后把二进制数做一次Base64进行传输。相对于原文，长度会多出1/3。也有把二进制转为字符串的形式，不过长度是原文的2倍。 哈希散列算法，主要用于脱敏处理和信息签名防篡改，做哈希运算应该加盐处理。盐值应该是随机值，而且和用户相关，建议使用（随机数 + 用户名）。 对称加密两端秘钥相同，加密速度快，可以加密大数据，但是秘钥保存一直是个难题。 非对称加密分为公钥和私钥，公钥可以公开。加密速度慢，只能加密小数据，但是只需要妥善保存私钥就可以了。 通常一个信息加密传输流程为： 双方约定好使用的编码格式。通常常用的是UTF-8编码。 客户端随机生成对称秘钥作为会话秘钥。使用非对称加密传输给后端，后端保存这个对称秘钥用于之后的加解密过程。 用户使用对称加密（通常为RSA）加密整个数据，结果通常使用Base64做编码（通常还要做一次URLEncode操作）,整个相关数据按照规则使用Hash算法（通常为SHA256算法）做数据签名。最后做传输 如果是用户密码的话建议用HMac做Hash脱敏处理，然后单独使用非对称加密进一步加强安全性。 参考： 字符编码笔记：ASCII，Unicode和UTF-8 百度百科-ASCII 深入浅出大小端 Base64 编码 MD5+Salt安全浅析 哈希加密算法 MD5,SHA-1,SHA-2,SHA-256,SHA-512,SHA-3,RIPEMD-160 - aTool DES加密模式详解 DES加密算法原理 关于PKCS5Padding与PKCS7Padding的区别 各种加密算法比较 AES在线加解密 iOS - Safe iOS 加密安全 RSA算法原理 SM2国密算法官方说明]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>iOS</tag>
        <tag>加解密</tag>
        <tag>字符编码</tag>
        <tag>大小端</tag>
        <tag>国密算法</tag>
        <tag>HASH</tag>
        <tag>对称加密</tag>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS应用安全-HTTP/HTTPS网络安全(二)]]></title>
    <url>%2F2017%2F05%2F15%2Fhttps-safe-2%2F</url>
    <content type="text"><![CDATA[导读 本文主要讲解IOS中ATS相关的配置说明和使用AFNetworking框架来实现证书验证的方法。讲解了AFNetworking各个配置试用的场景和注意点。 ATSIOS9之后，苹果开启了App Transport Security（简称ATS）特性,即禁止HTTP请求，必须使用支持TLS1.2的HTTPS请求。但是也支持在Info.plist中做一些配置，来做缓冲。需要在info.plist中加入App Transport Security Settings字段。 plist里面的结构如下 123456789101112131415NSAppTransportSecurity : Dictionary &#123; NSAllowsArbitraryLoads : Boolean NSAllowsArbitraryLoadsForMedia : Boolean NSAllowsArbitraryLoadsInWebContent : Boolean NSAllowsLocalNetworking : Boolean NSExceptionDomains : Dictionary &#123; &lt;domain-name-string&gt; : Dictionary &#123; NSIncludesSubdomains : Boolean NSExceptionAllowsInsecureHTTPLoads : Boolean NSExceptionMinimumTLSVersion : String NSExceptionRequiresForwardSecrecy : Boolean // Default value is YES NSRequiresCertificateTransparency : Boolean &#125; &#125;&#125; ATS整体配置（NSAllowsArbitraryLoads） 配置ATS生效或不生效 在App Transport Security Settings字段下加入Allow Arbitrary Loads，或NSAllowsArbitraryLoads，配置为NO。PS：如果要禁用则为YES。但是如果配置为YES会导致审核失败，需要单独向APPStrore申诉说明。 配置web(H5)访问限制生效或不生效 在App Transport Security Settings字段下加入Allow Arbitrary Loads in Web Content或NSAllowsArbitraryLoadsInWebContent，默认配置生效为NO。如果要容许访问任意web网页内容，配置为YES。但是如果配置为YES会导致审核失败，需要单独向APPStrore申诉说明。 配置多媒体访问限制生效或不生效 在App Transport Security Settings字段下加入Allow Arbitrary Loads in Web Content，默认配置生效为NO。设置YES，容许访问通过AVFoundation框架访问媒体内容。 ATS根据域名配置（Exception Domains）在App Transport Security Settings字段下加入Exception Domains或NSExceptionDomains,系统优先响应NSExceptionDomains中的配置。比如之前设置NSAllowsArbitraryLoadsInMedia为 YES，然而NSExceptionDomain所代表的域名，如果没有特殊配置，依然默认不能访问不安全的媒体内容。 加入域名配置 在Exception Domains下，添加字典。其中key为域名的名称，比如baidu.com。 容许访问HTTP 在步骤1对应的域名字典下，加入字段NSExceptionAllowsInsecureHTTPLoads.默认为NO，如果设置YES，则容许访问HTTP 容许TLS支持非正向保密算法（Perfect Forward Secrecy） 在步骤1对应的域名字典下，加入字段NSExceptionRequiresForwardSecrecy.默认为YES。如果设置为NO，则支持非正向保密的加密算法。 正向保密算法（Forward Secrecy），指如果通信密钥泄露，使用FS算法，可以保证这个密钥泄露只会影响之后的加密数据，之前的加密数据无法解密。主要防止攻击者保存之前的数据，等到私钥泄露之后再解密数据。这个算法的基础是基于椭圆曲线向前保密的秘钥交换算法ECDHE（Elliptic Curve Diffie-Hellman Ephemeral）。这些算法有： 1234567891011TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHATLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHATLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 如果设置为NO，则非正向保密算法，有下面几种： 123456TLS_RSA_WITH_AES_256_GCM_SHA384TLS_RSA_WITH_AES_128_GCM_SHA256TLS_RSA_WITH_AES_256_CBC_SHA256TLS_RSA_WITH_AES_256_CBC_SHATLS_RSA_WITH_AES_128_CBC_SHA256TLS_RSA_WITH_AES_128_CBC_SHA 具体原理参考TLS/SSL 高级进阶。 容许支持低版本的TLS算法。 在步骤1对应的域名字典下，加入字段NSExceptionMinimumTLSVersion。值为对应的支持的最低版本。包含下面值 123TLSv1.0TLSv1.1TLSv1.2 包含域名下的所有子域名。 在步骤1对应的域名字典下，加入字段NSIncludesSubdomains。默认为NO。如果配置为YES则包含域名下的所有子域名。 开启Certificate Transparency 在步骤1对应的域名字典下，加入字段NSRequiresCertificateTransparency,这个默认为NO.如果设为YES，则开启Certificate Transparency。这个是IETF启动的一个开源项目，目的是进一步验证证书是否安全。个人觉得没什么用，没必要开启。 ATS各种字段含义说明主要的几个key： NSAllowsArbitraryLoads 默认NO。如果设置为YES，则不生效ATS规则。但是配置在NSExceptionDomains里面的规则，按照里面的规则生效。配置为YES，提交APP Strore需要说明 NSAllowsArbitraryLoadsForMedia 默认NO.如果设置为YES，那使用AVFoundation加载资源不生效ATS。 NSAllowsArbitraryLoadsInWebContent 默认NO.如果设置为YES.使用webview加载的页面资源不生效ATS。 NSExceptionDomains 用于单独配置其他域名ATS策略的键。值应该是字典类型。 下面是NSExceptionDomains相关的key NSIncludesSubdomains 默认NO。如果设置为YES，则生效此域名下的子域名 NSExceptionAllowsInsecureHTTPLoads 默认NO。如果设置为YES，则容许HTTP请求。设置YES，在审核时需要提供说明。 NSExceptionMinimumTLSVersion 默认TLSv1.2。可以设置为：TLSv1.0、TLSv1.1。在审核时需要提供说明 NSExceptionRequiresForwardSecrecy 默认YES。设置为NO标示不支持正向保密。 NSRequiresCertificateTransparency 默认NO。如果设置为YES，开启Certificate Transparency。 上面的是方便本人查找，详细设置case也可以参考[ATS 官方文档] (https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35)。目前过渡阶段最多出现的是第三方不兼容的问题+不支持NSExceptionRequiresForwardSecrecy+TLS版本不到1.2+h5访问的链接不支持ATS。按照要求配置就可以了，最重要的是推动第三方和自己后台使用HTTPS。自己的后台如果要求不高，可以用自制证书。 推荐的一个配置： 自己的域名使用最安全的方案，防止被苹果拒绝。第三方可以按照需求配置，但是审核时也建议进一步说明。 123456789101112NSAppTransportSecurity NSExceptionDomains &quot;domain-i-control.example.com&quot; // 后台的域名 NSExceptionAllowsInsecureHTTPLoads = NO //不容许HTTP NSExceptionRequiresForwardSecrecy = YES //支持正向加密 NSExceptionMinimumTLSVersion = &quot;TLSv1.2&quot; //使用1.2版本 NSIncludesSubdomains = YES //包含子域名 &quot;other-domain-i-control.example.com&quot; //部分不支持的第三方域名 NSExceptionAllowsInsecureHTTPLoads = NO //支持http NSExceptionRequiresForwardSecrecy = YES //不支持正向加密 NSExceptionMinimumTLSVersion = &quot;TLSv1.0&quot; //第三方支持的TLS版本 NSAllowsArbitraryLoads = NO 使用AFNetworking配置HTTPS安全AFNetworking是最常用的网络框架。所以以这个为基础说明一些配置信息。本人是使用2.6版本的。3.x版本和2.6相比安全验证的逻辑没有变化，可以参考。2.6之前的版本，建议所有配置项显示配置，不要用默认配置（因为有个版本有漏洞，默认不校验域名）。下面先讲解下配置参数，清楚之后再讲解代码实现。 AFSecurityPolicy说明AFNetworking使用AFSecurityPolicy类来管理安全策略。 主要的属性和方法： 12345@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode; //证书验证的策略@property (nonatomic, assign) BOOL allowInvalidCertificates; //是否容许无效的证书@property (nonatomic, assign) BOOL validatesDomainName; //是否验证证书的域名@property (nonatomic, strong, nullable) NSArray *pinnedCertificates; //app自己导入的证书文件，默认情况下主bundle里面的.cer文件都会导入到这个数组里。 validatesDomainName 说明是否容许证书包含的域名和实际访问的域名不匹配，默认为YES。采用的策略为： 如果validatesDomainName == YES，则开启域名验证。如果allowInvalidCertificates == NO，则不容许所用的证书里面的域名和实际域名不一致。如果allowInvalidCertificates == YES，则忽略域名验证，直接按照AFSSLPinningMode方式验证。 如果validatesDomainName == NO,则不对证书做域名验证。 allowInvalidCertificates 说明是否容许无效证书，默认为NO。采用的策略为： 如果allowInvalidCertificates == YES，则容许使用自制证书，或容许CA颁发的证书或系统信任的第三方证书（比如手动信任Charles证书）无效（包括域名无效和超过有效期） 如果allowInvalidCertificates == NO，那无法使用自制证书，且不容许CA颁发的证书或系统信任的第三方证书（比如手动信任Charles证书）超过有效期。如果配置了validatesDomainName == YES，则容许证书的域名不匹配，否则也不容许域名不匹配。 SSLPinningMode 说明证书文件实体验证策略，默认为AFSSLPinningModeNone。AFSSLPinningMode包括的值为： 123456typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, AFSSLPinningModePublicKey, AFSSLPinningModeCertificate &#125;; AFSSLPinningModeNone。AFNetworking默认配置模式。采用的策略为： 如果容许无效证书（allowInvalidCertificates == YES），则直接返回验证成功（YES） 如果不容许无效证书（allowInvalidCertificates == YES），则验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。 AFSSLPinningModePublicKey。验证证书公钥模式。采用的策略为： 如果容许无效证书（allowInvalidCertificates == YES），则比对服务端发来的证书链中的公钥和自己加入的所有证书的的公钥是否匹配，只要有一个证书匹配就返回成功。 如果不容许无效证书（allowInvalidCertificates == YES），则先验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。验证通过后，则比对服务端发来的证书链中的公钥和自己加入的所有证书的的公钥是否匹配，只要有一个证书匹配就返回成功。 AFSSLPinningModeCertificate。证书完全匹配模式。采用的策略为： 如果容许无效证书（allowInvalidCertificates == YES），则将自己导入的所有证书作为锚点，判断服务端是否有效。如果有效，判断服务端证书链中的证书中，是否有证书包含在导入的证书里（使用二进制比较，也就是必须完全一样）。 如果不容许无效证书（allowInvalidCertificates == YES），则先验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。验证通过后，则将自己导入的所有证书作为锚点，判断服务端证书是否有效。如果有效，判断服务端证书链中的证书中，是否有证书包含在导入的证书里（使用二进制比较，也就是必须完全一样）。 上面的比较绕，其实就是三个配置的组合。下面把这几种组合起来，看看验证了什么，使用于什么策略。其中AC表示allowInvalidCertificates，VD表示validatesDomainName。需要的可以去查这个表来决定方案。 table th:first-of-type {width: 10px;} th:nth-of-type(2) {width: 70px;} th:nth-of-type(3) {width: 20px;} th:nth-of-type(4) {width: 40px;} 场景 mode AC VD 验证策略 适用场景 不适用场景 1 None NO YES 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期3.验证证书域名是否匹配 1.AF默认的安全策略2.对于安全有基础的要求3.使用CA机构颁发的证书 1.使用自制证书的 2.不容许使用第三方抓包工具抓包的应用 2 None NO NO 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期 1.证书是正规CA颁发的。但是使用的域名不是证书中的域名 1.存在风险，会导致攻击方使用自己的合法的CA证书进行攻击 2.使用自制证书的 3.不容许使用第三方抓包工具抓包的应用 3 None YES YES /NO 不对证书做任何验证 请勿使用这儿配置。 1.对安全没有要求的 1.对安全有要求的 4 PublicKey NO YES 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期 3.验证证书域名是否匹配4.验证证书和埋入的证书的公钥是否一致 1.证书是正规CA颁发的。2.对安全有比较高的需求 3.需要本地APP中导入证书 4.禁止第三方工具抓包 5.证书过期后只要保证公钥一致，就可以保证请求有效 1.使用自制证书的2.害怕攻击者拿到私钥或公钥文件，伪造证书（概率极低，因为需要CA机构再签发） 3.证书过期需要更换，但是新旧证书公钥不同 5 PublicKey NO NO 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书 2.验证证书是否过期 3.验证证书和埋入的证书的公钥是否一致 1.证书是正规CA颁发的。 2.需要本地APP中导入证书 3.禁止第三方工具抓包 4.使用的域名和证书域名不一致 5.证书过期后只要保证公钥一致，就可以保证请求有效 1.使用自制证书的 2.害怕攻击者拿到私钥或公钥文件，伪造证书（概率极低，因为需要CA机构再签发） 3.证书过期需要更换，但是新旧证书公钥不同 6 PublicKey YES YES/NO 1.验证证书和埋入的证书公钥是否一致 1.使用自制证书 2.需要本地APP中导入证书 3.禁止第三方工具抓包 4.不需要关心证书的有效期 1.攻击者可以拿到私钥或公钥文件，伪造证书。相对于场景4和5，更容易攻击一些。 2.攻击者可以用不在有效期的证书对进行攻击 7 Certificate NO YES 1.验证证书域名是否匹配2.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书3.验证证书是否过期4.验证证书和埋入的证书是否完全一致 1.证书是正规CA颁发的。2.对安全有最高的需求3.需要本地APP中导入证书4.禁止第三方工具抓包 1.需要考虑证书更新的场景 2.证书如果失效，客户端网络请求将会失效 3.自制证书 8 Certificate NO NO 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期3.验证证书和埋入的证书是否完全一致 1.证书是正规CA颁发的。2.对安全有最高的需求3.需要本地APP中导入证书4.禁止第三方工具抓包5.证书域名和实际域名不一致 1.需要考虑证书更新的场景2.证书如果失效，客户端网络请求将会失效3.自制证书4.攻击者拿到公私钥的前提下，可以利用不校验域名，攻击或重定向其他域名。 9 Certificate YES YES 1.验证证书的域名是否匹配？ 2.验证证书是否过期？ 3.验证证书和埋入的证书是否完全一致 1.使用自制证书2.需要本地APP中导入证书3.禁止中间人攻击 1.需要考虑证书更新的场景2.证书如果失效，客户端网络请求将会失效3.无法作废不安全的证书。在攻击者拿到公私钥的前提下,可以监听数据。 10 Certificate YES NO 1.验证证书是否过期？2.验证证书和埋入的证书是否完全一致 1.使用自制证书2.需要本地APP中导入证书3.禁止禁止中间人攻击 1.需要考虑证书更新的场景2.证书如果失效，客户端网络请求将会失效3.攻击者拿到公私钥的前提下，可以利用不校验域名，定位到其他域名。 相关问题下面是一些疑问： 如何选择合适的方案? 建议对安全没有特别要求的或在测试环境下方便抓包，采用默认规则就可以了，重要的数据单独做加密。即选场景1 要校验域名，即：validatesDomainName不要设置为NO。如果设为NO，不校验域名，也最好自己加一层验证方法。 如果是自制证书，allowInvalidCertificates设置为YES。如果是ca颁发的证书则建议设置为YES。 无论是使用AFSSLPinningModePublicKey还是AFSSLPinningModeCertificate都应该考虑证书失效需要更换的问题。 如果用AFSSLPinningModePublicKey方式，使用场景6只要保证后续更换的证书公钥不变化就可以了。个人觉得是安全和方便性最平衡的一种模式，只要私钥不泄露就可以了。这个要求公司的证书管理机构知道这点，不过如果出了意外，也可以延缓部署。 最安全的方案是7。也就是强校验，漏洞最少，安全防护最高。但是必须考虑证书失效更换的问题。 如何防止证书过期导致不过的问题？有以下方案： 可以用场景6，保证后续更换的证书公钥不变化就可以了 APP强制升级，全局通知，热更新等保护通道，建议不要使用强校验策略，使用强的加密手段保证安全，作为最后手段。 加入证书更新的通道，每次应用启动的时候访问，查看是否有证书更新，如果有就去下载证书。 证书更新有什么方案？ 建议启动检查是否有证书更新，可以合并在检查APP更新或热更新里面。 发现有更新的时候，服务端把证书二进制数据转为16进制字符串下发给客户端。服务端对数据使用私钥签名，客户端使用公钥对数据进行验签。 客户端将下载的文件按照签名等规则保存。下次加载前，继续对文件验证签名，保证没有篡改。 对于场景9，容许无效的证书，使用AFSSLPinningModeCertificate模式，为什么说明里面还说会验证证书过期？ 我个人也不确定，但是这个模式在加入证书锚点后，代码里还是会调用AFServerTrustIsValid()方法，然后再匹配证书数据是否一致。这个AFServerTrustIsValid()最终调用的是系统验证的方法，不确定系统是否还是会验证有效期，还是只验证包含证书就可以了，目前没有手段验证，大概率认为系统还是会验证是否过期。所以相对来说验证AFSSLPinningModePublicKey需要考虑更新的情况更少。 如果使用AFSSLPinningModePublicKey模式，更换证书怎么保证公钥不变？ 参考上一篇文章的附录，有一步是使用私钥.key文件生成.csr。只要.key和.csr，下次签发的时候直接用这两文件，签发就可以了。这样能保证下次的证书公钥也不变化。建议生产私钥的时候使用位数在2048位以上，可以保证安全性。 代码具体实现导出证书建议向自己公司的网络管理员导出对应的crt文件。或者使用命令： openssl s_client -connect www.google.com:443 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer //获取www.google.com:443的ssl证书，地址可以换成自己的 建议最好导出根证书的crt文件。因为根证书crt文件有效期长，很少更换。 如果是crt格式，使用时需要转化为cer格式。两种转化方式都可以： 命令行 openssl x509 -in 你的证书.crt -out 你的证书.cer -outform der 通过电脑导出。 双击crt，安装到钥匙链中。 钥匙链中选中需要导出的证书，鼠标右键，菜单中选择&gt;&gt;导出，点击存储即可。 然后将.cer文件导入到工程中。注意选Copy items if needed . 设置生效规则代码实现其实非常简单，重要的是规则的设置，建议认真搞清楚上面讲的配置说明，然后再配置。 12345678910111213141516171819202122232425262728293031//设置模式 AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; //设置是否验证域名，不建议设置为NO policy.validatesDomainName = YES; //设置是否容许无效的证书，自制证书选YES policy.allowInvalidCertificates = NO; //AF如果模式为AFSSLPinningModeCertificate或AFSSLPinningModePublicKey会默认导入mainBundle里的所有cer文件，如果没有特别需求，没必要实现下面加载cer的代码 //先导入证书路径 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@"myCer" ofType:@"cer"];//证书的路径 // 有多个加多个 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; policy.pinnedCertificates = @[certData]; AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; //生效policy manager.securityPolicy = policy; //调用 NSString *host = @"exmple"; NSDictionary *params = @&#123;&#125;; [manager GET:host parameters:params success:^(AFHTTPRequestOperation *_Nonnull operation, id _Nonnull responseObject) &#123; &#125; failure:^(AFHTTPRequestOperation *_Nonnull operation, NSError *_Nonnull error)&#123; _hasUpdating = NO; &#125;]; 具体配置请参考上面AFSecurityPolicy的介绍。通常测试环境下使用默认模式，其他环境使用校验模式。 验证策略源码解读AF 2.6版本，在系统框架需要进行证书验证的时候会调用AFURLCOnnectionOpeation.m中的evaluateServerTrust:forDomain方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain&#123; //自制证书且验证域名不能用AFSSLPinningModeNone模式 if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123; // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html // According to the docs, you should only trust your provided certs for evaluation. // Pinned certificates are added to the trust. Without pinned certificates, // there is nothing to evaluate against. // // From Apple Docs: // "Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors). // Instead, add your own (self-signed) CA certificate to the list of trusted anchors." NSLog(@"In order to validate a domain name for self signed certificates, you MUST use pinning."); return NO; &#125; NSMutableArray *policies = [NSMutableArray array]; if (self.validatesDomainName) &#123; //如果要验证域名需要把域名加入到规则里 [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; //设置验证规则，如果有域名验证就加入域名验证 SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); if (self.SSLPinningMode == AFSSLPinningModeNone) &#123; //AFSSLPinningModeNone下，如果容许无效证书或者证书通过验证就返回成功，否则返回失败 return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123; //其他模式，如果没有容许无效证书，就做证书验证，失效了就返回失败 return NO; &#125; //抽取服务端的所有证书链数据 NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust); switch (self.SSLPinningMode) &#123; //不会进入到这个case case AFSSLPinningModeNone: default: return NO; case AFSSLPinningModeCertificate: &#123; //将导入的证书加入到锚点里 NSMutableArray *pinnedCertificates = [NSMutableArray array]; for (NSData *certificateData in self.pinnedCertificates) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; &#125; // PS:查看相关文档发现，如果只调用了SecTrustSetAnchorCertificates而没有调用SecTrustSetAnchorCertificatesOnly(serverTrust,false)方法，会导致只信任SecTrustSetAnchorCertificatesOnly设置的锚点的证书，不信任系统默认内置的锚点证书 SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); //验证是否证书是否在加入的锚点证书列表里。猜测会验证证书的有效期，如果有域名验证，验证域名。 if (!AFServerTrustIsValid(serverTrust)) &#123; return NO; &#125; //查看证书链中的证书是否和埋入的证书完全一致。 NSUInteger trustedCertificateCount = 0; for (NSData *trustChainCertificate in serverCertificates) &#123; if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123; trustedCertificateCount++; &#125; &#125; return trustedCertificateCount &gt; 0; &#125; case AFSSLPinningModePublicKey: &#123; NSUInteger trustedPublicKeyCount = 0; //从证书链中抽取所有公钥列表 NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust); //验证证书链中的公钥是否在导入的证书里面的公钥链中 for (id trustChainPublicKey in publicKeys) &#123; for (id pinnedPublicKey in self.pinnedPublicKeys) &#123; if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123; trustedPublicKeyCount += 1; &#125; &#125; &#125; return trustedPublicKeyCount &gt; 0; &#125; &#125; return NO;&#125; 里面实际验证是否有效的方法为：AFServerTrustIsValid(SecTrustRef serverTrust)。实现： 12345678910111213static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123; BOOL isValid = NO; SecTrustResultType result; // 具体实现，因为看不到源码无法确认，应该是标准的证书链验证方式，验证证书有效性，验证证书链的对应的CA根证书是否在颁发机构里或者是否是用户手动同意或拒绝的证书。如果设置了SecTrustSetAnchorCertificates,则验证是否在SecTrustSetAnchorCertificates方法设置的锚点证书里（不包含系统的证书） __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); //kSecTrustResultUnspecified:证书通过验证，但用户没有设置这些证书是否被信任 //kSecTrustResultProceed:证书通过验证，用户有操作设置了证书被信任，例如在弹出的是否信任的alert框中选择always trust isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);_out: return isValid;&#125; WebView进行证书验证如果不配置，webview执行系统默认的策略。因为项目中没用到，暂时不敢评判，下面是相关博客供参考。 参考文献 iOS 10 适配 ATS（app支持https通过App Store审核） [ATS 官方文档] (https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35) RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密? iOS安全系列之二：HTTPS进阶]]></content>
      <categories>
        <category>iOS</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>HTTPS</tag>
        <tag>iOS</tag>
        <tag>ATS</tag>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS应用安全-HTTP/HTTPS网络安全(一)]]></title>
    <url>%2F2017%2F05%2F11%2Fhttps-safe-1%2F</url>
    <content type="text"><![CDATA[导读： 本文主要讲在HTTP和HTTPS实际开发中有用和有意思的地方，希望读者能够有所启发。 主要包括：HTTP和HTTPS的简单介绍。介绍HTTPS加密逻辑。介绍SSL证书和SSL证书校验的规则。 本文简化了相关的技术细节，主要关注于前端开发需要关注的点和可以借鉴的地方，希望能对开发能有所帮助。开发更关心的技术代码实现细节，会单独文章中说明。 HTTP简介具体细节可以参考后面的参考文献，只写我觉得有意思和实际中可以参考的地方。 HTTP协议构建于TCP之上。意味着http是可靠的数据传输。所以不用担心丢包和乱序的问题。 HTTP协议是基于请求和响应的协议。与之对比MQTT协议是基于订阅的协议。 比如我想要一个资源的种子，如果知道哪个老司机有，我直接问他，他有就给我，没有也告诉我没有。这种模式就是请求和响应，好处是一对一，可以准确完整的按照自己的需求拿到需要的数据，但是坏处是消息会滞后，我想知道老司机后面是不是有资源了，我就只能一遍遍重复的问，直到拿到想要的结果为止（循环延迟请求，之前专门写个looperRequest就是为了解决这种问题）。 另外一种方案，我发布消息到一个论坛，然后留下邮箱，求好人一生平安。然后很多好人有资源就发给我，这样也能拿到数据。这种模式就是订阅模式，好处是可以一对多，可以快速实时拿到数据。但是坏处是：需要长链接，且推送消息时不清楚客户端的状态，推送的东西不一定需要，比如这个种子可能我已经有了，再发给我就浪费大家的流量了。 总结下。利用请求应答的模式，可以快速的和服务端同步数据，保证当前请求数据的有效性，有时候我们也叫拉（pull）数据。订阅模块可以快速的更新需要保证实时性的数据，比如聊天数据，交易结果，账户异常，有时候我们也叫推送（push）数据。 这两种方案是和服务端常用的两种交互方案，有些交互可以考虑两者结合的方式解决。比如之前项目中解决聊天数据的实时有效性，就采用后端推送当前有新消息或其他状态信息，前端收到状态信息后，主动拉取消息到本地，既能保证能够快速更新消息或状态，又能通过本地的状态，按照需求拉取需要的消息。 推/拉这种设计思路也可以用于应用间的数据同步，应用于模块间数据通信来进行模块解耦等。现在的项目工程模块化设计方案也借鉴了这两种思想。 URL。URL定义了一个资源的地址。大部分格式如下 protocol :// hostname[:port] / abs_path / [;parameters][?query]#fragment 详细说明参考 其中query用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。例如：http://www.joes.com/inventory-check.cgi?item=12731&amp;color=blue。唯一需要注意的是，URL里面不容许有非ASCII字符（常见的就是汉字），也不容许有保留字符比如：!*&#39;\&quot;();:@&amp;=+$,/?%#[]%,所以通常拼接请求时（GET），需要对传进来的参数做一次URLEncode操作。 可以参考这个做私有协议跳转，比如push消息协议，模块跳转协议，外部跳转协议等。 http请求由三部分组成，分别是：请求行、消息报头、请求正文.详细的建议使用charles抓一个请求看下就知道了。 注：来源于http://www.cnblogs.com/ranyonsue/p/5984001.html. 重要的几个请求报头字段： Accept: 指定客户端接受的消息类型（通常没人使用,因为客户端大量使用json做数据解析） Host:请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 User-Agent:用于附加操作系统名称和浏览器版本，通常给H5使用的，UA很容易被修改，项目中有遇到修改UA导致H5页面识别不出来当前操作系统和版本的问题，遇到这种可以查下UA被谁篡改了。 Referer:用于标示请求来源，一般用于防盗链，这个实际中也遇到过。 http的响应一般由三个部分组成，分别是:状态行，消息报头，响应正文。 注：来源于http://www.cnblogs.com/ranyonsue/p/5984001.html. 重要的几个消息报头 Content-Type 正文媒体类型和编码格式，比如：Content-Type:text/html;charset=ISO-8859-1.Content-Type这个字段被AFNetworking框架用于决定用什么解析器，注意后端不要配置错了。charset被用于AFNetworking字符解码，也应该前后端配置正确。这个配置不正确是经常联调不过的原因。 具体实现参考AFURLResonseSerialization.m。 Content-Length 用于表示正文长度，下载长资源时，需要使用这个字段来计算进度，也可以用这个字段推算下载流量。 Content-Encoding 通常用于记录压缩方法，比如：gzip。 GET和POST的方法。HTTP有定义了几种常用的方法，不过通常前端只和这两个打交道。这两个区别： 通常认为get是获取消息，不改变数据，post是用来改变数据，不过实际中，并不是那么明确。 get参数是附在URL链接上的，参数拼接前需要做URLEncode，post是附在请求正文里的,格式为key=value，使用&amp;分割，所以对传入数据也要做URLEncode，拼接后和头部用回车换行隔开。 get的URL长度有一定限制，不过也取决于系统支持，具体长度需要实际调研，ie的限制为2083字节，post理论上不存在长度限制。 安全性，post相对安全，get相对不安全。不过post属于防君子不防小人的那种，实际没有什么安全可言。所以综合来说，如果没有技术洁癖，建议都用post处理。 上传图片等二进制资源。上传资源一般是post协议，但是通常post是用于传送文本的，如何传图片等资源呢？就需要multipart协议了。 mutipart和普通的post有两点不同：请求头，请求报文。其中关键字是boundary这个属性。 请求头： 必须包含content-Type，且值为：multipart/form-data;boundary=${bond},其中${bound}为具体分割符，在AFNetworking中，如果不指定是Boundary+${random}。 请求体:内容不再是用name=value的形式，而是使用上面的boundary进行分割的一段一段的结构体。具体示例： 12345678910111213141516171819202122232425262728293031 POST /btoa/work/common/uploadImage HTTP/1.1Host: www.example.comContent-Type: multipart/form-data; boundary=Boundary+49F77F66A65EEA58Cookie: BIGipServerPOOL_PACLOUD_STGR2016080900646=1274288556.52384.0000; FF_SESSION2_ID=Sf503bee3691b4a31a53c6e3c5ae1c1f00912e8Connection: keep-aliveAccept: */*User-Agent: FFProject/2.0.0 (iPhone; iOS 10.3.1; Scale/3.00)Accept-Language: zh-Hans-CN;q=1, th-TH;q=0.9Content-Length: 418864Accept-Encoding: gzip, deflate--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="ffAppID"10004--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="imageSeq"1--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="imageType"5--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="image"; filename="xxxx.jpg"Content-Type: image/jpeg***image hex data***--Boundary+49F77F66A65EEA58-- 看到上面的例子可以知道，有几个参数是必须的，name、filename、Content-Type、具体资源数据 ，对应的AF接口： 1234- (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType; HTTPS简介苹果ATS政策出来之前，后端极少使用HTTPS协议，而是使用HTTP协议+自定义的安全数据加密策略来保证安全性。这是因为虽然HTTPS更安全，但是也更加耗费性能。如今苹果强推HTTPS（有说法是苹果可能会全面禁止HTTP的使用），使得HTTPS大范围使用，并且使用HTTPS作为安全扫描项，被安全机构接纳。但是如果不正确的使用HTTPS，还是会带来安全风险。 SSL/TLS简介HTTPS的关键字就是SSL（TLS）。和HTTP唯一的不同就是加入了SSL（TLS）协议，这一层在TCP之上，负责保证安全连接和数据传输安全。 注：来自 深入解析HTTPS SSL实际上是一套加密通信机制。SSL和TLS两者的协议基本一致，区别简单可以理解是TLS是SSL的升级版本。但是使用SSL所有协议版本都不再安全。请勿使用SSL协议 具体可以参考SSL与TLS的区别以及介绍 ios加入了ATS限制，强制原来HTTP必须使用HTTPS传输，也强制要求服务器必须使用TLS v1.2版本以上。所以简化为： 要使用支持TLS1.2及以上协议的HTTPS传输数据 PS：后面如无特殊说明，不再区分TLS和SSL，统一称为SSL HTTPS原理建议看下浅析HTTPS中间人攻击与证书校验和阮一峰：图解SSL/TLS协议和SSL、TLS协议格式入门学习 - .Little Hann 下面是协议流程图： 注：来自http://blog.csdn.net/muzhengjun/article/details/53379593 简单描述： TCP握手 SSL握手，握手成功就开始传输，失败就断开链接 数据传输 下面也是只讲一些有意思的点和注意的地方。 HTTPS加密流程整个加密的流程，体现了一个非常安全的信息加密的方案。 简化的流程如下： 客户发送一个随机数给服务端：random-c（明文） 服务端发送自己SSL证书给客户端。发送服务端随机数：random-s（明文） 客户端验证SSL证书有效性，如果判定有效，生成一个随机数random-p,然后使用证书中的公钥进行非对称加密，发送给服务端。 （这一步是整个安全环节最重要也是最薄弱的环节） 服务端拿到加密后的秘钥，通过私钥解密，得到random-p ，将random-c、random-s、random-p三个随机数做因子，两端都按照一定算法生成会话对称秘钥secret_key。 客户端计算之前的握手消息（除了Change Cipher Spec外）的Hash值，利用secret_key做对称加密后发给服务端。 服务端拿到后，利用secret_key解密，然后利用同样的算法计算之前的握手消息的Hash值，如果能解密成功，且验证Hash值正确则说明客户端的加密算法和秘钥没问题。 服务端再计算之前的握手消息的Hash值，利用secret_key做对称加密后发给客户端，客户端如果能够解密出来，且与自己计算的Hash值相同，则最后链接正式建立成功。 注明：上面是以RSA为基础的秘钥加密流程，即需要客户端将随机数加密传输给后端。还有一种基于秘钥交换的形式，双方的对称秘钥是通过交换的参数本地的，不会通过信道传输，会更安全些。具体参考TLS/SSL 高级进阶 先简单说明几个概念，详细的会专门抽出来分享： 对称加密：双方使用的秘钥是相同的，使用同一个秘钥进行加解密。 非对称加密：加密使用公钥加密，解密使用私钥加密。或者私钥加密，使用公钥解密。但是公钥和私钥是不同的。公钥是公开的，可以被第三方拿到而不会引起任何安全问题，因为通过公钥是无法得到私钥的，因而没办法解密使用公钥加密的数据。 散列（hash）：散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。好的散列算法是一对一的，不同的原文生成的一定是不同的散列。 这其中使用的加密策略： 传输数据应该加密，整个加密过程使用了两种加密方案，一种对称加密，一种非对称加密。 传输数据使用了对称加密，而秘钥生成中使用了非对称加密。 使用了散列算法（hash）来做数据验证。 回答这里面常见的几个问题： 为什么又要用非对称加密，又要用对称加密，只使用一个不可以么？ 不能只是用对称加密，因为对称加密，两个使用的秘钥是一致的，有一端的秘钥泄露了，两端的通信就不再安全了，尤其是客户端的对称秘钥非常容易泄露，拿到秘钥后，整个系统就不安全了。 也不只用非对称加密，主要是因为性能，非对称加密相对于对称加密，计算时间要长非常多，对于性能要求很高的场景，会明显降低性能。RSA算法和AES算法性能测试 所以设计者结合了两种方案。两端通过非对称加密协商秘钥，攻击者因为拿不到私钥，是无法解开通信秘钥的。一旦协商成功，通过对称加密又解决了性能问题。 为什么使用三个随机数 还是为了进一步加强安全，客户端或者服务端生成的随机数可能是伪随机的，有可能被攻击者猜出，但是如果三个伪随机的数一起使用就大大加强了随机性，这样攻击者就很难破解了。 为什么最后要做hash验证 为了保证两端通信中的数据不会做篡改，由于HASH算法，可以保证唯一性，所以如果中间消息被人篡改，就可以断开链接。 如果对原理不感兴趣，那建议记住下面推荐的加密方案，完全可以解决大部分的加密需求： 使用随机数做对称加密秘钥，将对称加密秘钥使用公钥进行非对称加密传给后端。这样因为秘钥随机，所以即使客户端被破解，也拿不到任何对称秘钥。而公钥建议老客户过3456让她进行动态获取，避免私钥泄露带来的问题。 使用非对称加密秘钥，可以保证网络数据即使劫持，因为没有私钥，也解不出来对应的加密秘钥，所以加密的隐私数据也是安全的 两者结合，可以保证一定的性能要求。 对数据进行加签（加盐+hash算法），保证中间的数据不会篡改。 ps:用户的密码，因为保密性要求更高。建议的算法是做HMAC哈希做脱敏，然后使用非对称加密给后端。 常用的网络传输攻击手段先思考下，刚才的通信链路有三个参与者： 客户端 传输信道 服务端 如果新加入一个攻击者，他想要窃取用户的隐私数据，他该怎么做？常见的做法： 攻击客户端。对于IOS系统来说，非越狱手机，由于权限问题，几乎无法攻击（之前XcodeGhost真的是很nb的攻击思路）。对于越狱手机，通过HOOK API，然后重新打包应用，诱导用户下载。或者劫持系统的输入框等常用控件可以达到攻击目的。相关的以后整理输出。但是从移动APP来说，直接攻击APP带来的危害和利用性很低，通常只会泄露很少的用户信息。大多是利用来薅羊毛的。 攻击传输信道。攻击手段有中间人攻击，DNS劫持等。 攻击服务端。也非常难做到。一般是模板注入，撞库等。 这里面其实最容易的就是攻击传输信道。排除技术术语，手段有： 伪装成正常的客户端攻击服务端 伪装成正常的服务端，劫持客户端数据 监听修改信道数据 这几种怎么解决？ 问：如何处理伪装成正常的客户端攻击服务端 在认为客户端app本身是无法攻破的前提下： 请求中一定加入签名策略。攻击者不知道签名策略是无法仿造请求的，也防止劫持者修改。发现签名不对，服务端认为是假的客户端。 请求中一定加入请求防重放策略。服务端发现是之前的请求，重复发送过来的（可能只有签名不一致），应该忽略 加入风险控制策略。比如异地登陆，同一设备ip反复请求，一些金融类app也会加入公安部认证的风控系统，防止一些有金融犯罪前科的用户注册。后端使用风控策略，禁止用户登录，或者强制要求用户再次身份认证，比如手机验证码认证。 问：如何处理监听修改信道数据&gt; 请求关键数据做加密，加密方案建议使用上面提到的加密方案。这样即使被监听，拿到数据也无法处理 加入请求签名，防止数据篡改。 问：如何处理伪装成正常的服务端，劫持客户端数据 这一种方式是目前攻击最常见且有效的手段。使用http的时候，因为没有任何认证措施，通过ARP或者DNS劫持，非常容易将网址定向到其他攻击者的地址，攻击者可以做劫持和修改相关数据。所以HTTP现在已经被各大平台所抛弃。很多开发遇到的访问一个h5页面，被运营商强插入广告就是这么做的。解决办法就是正确的使用HTTPS HTTPS，很大一部分作用就是解决上述问题。也就是通过SSL握手，校验服务端证书，达到验证是否是伪装的服务端的目的。HTTPS握手阶段算法原理都是安全的，只有验证身份这一步有漏洞，即只要想办法让客户端认为证书是可信的，证书里面的公钥就是生成者的公钥，自然就有相对应的私钥，后面非对称加密生成的对称秘钥就可以被截取到，造成整个链路不安全。如何攻击这个策略，行业上主要称为中间人攻击。 SSL证书可以说验证SSL证书是整个HTTPS的关键，如果这一步出问题，后面的就没有任何安全可言。而对于我们前端开发来说，SSL证书也是最需要关注的地方。 这里讲两个问题。SSL证书是什么？为什么通过SSL证书可以防止攻击者伪装成服务端。 SSL证书是什么SSL证书是一个文件。里面的内容包括：用户的信息、用户的公钥、还有CA中心对该证书里面的信息的签名。一个证书的实例： 打开safari，打开百度，https://www.baidu.com,在地址栏点击锁按钮，然后选显示证书。 里面的内容只有几个需要关注的： 常用名称：baidu.com 。客户端或浏览器，根据常用名称和访问的域名做匹配，访问的域名和证书的域名不一致，就会拒绝访问，达到防止域名劫持的目的。这个信息可以被伪造。 公共密钥：SSL握手生成的第二段随机串是通过这个公钥来加密的。这个信息可以被伪造，但是伪造没有异议。（想知道为啥的可以看看证书生成的步骤。） 签名：是对整个证书内容做hash之后，使用颁发机构的私钥加密的值。这个信息可以被伪造，但是伪造没有异议。 签名者信息：颁发机构的信息，由于验证上一级的证书信息。这个信息可以被伪造。 证书有效期。这个信息可以被伪造。 可以看到在百度这个证书上面还有两个证书，这是因为百度这个证书是有GS这个机构的二级机构颁发的，而GS这个二级机构是由GS的CA根证书颁发的。 也就是证书有证书链的概念，即这个证书可能是上一层机构颁发的，从CA根证书开始-&gt;二级CA证书-&gt;三级CA证书-&gt;…。 注：来自SSL 之证书链 SSL证书如何验证的推荐这篇文章，是目前看到讲的最清楚。浅析HTTPS中间人攻击与证书校验 根据HTTPS协议，服务端会在握手的时候将证书传送给客户单，而且是将整个证书链发过来。 通常的验证传过来的证书是否有效的步骤为： 验证证书的常用名称是否是访问的域名，是否在有效期内。（域名校验+有效期校验） 计算这个证书内容的散列值得到MD5-a，然后用颁发机构的公钥解密这个证书的签名得到MD5-b，比较两个值是否相同，如果相同说明这个证书确实是上个颁发机构颁发的。 重复上面的操作，直到验证到CA根证书。CA证书是自签名的，也就是签名是用自己的私钥签名的。可是CA根证书签名是用自己的私钥做签名，怎么去验证这个证书是否正确呢？ 最终上面的问题简化为： 如何验证CA根证书有效性最终层层拨茧，HTTPS的安全性关键钥匙就在这一章了。 CA根证书有两种生成方式： 由可信的颁发机构颁发 本地自己生成 对于第一种，因为可信的颁发机构很少，这些机构的CA证书会默认保存在浏览器里或者手机操作系统里，由可信的机构颁发的证书的有效性会由颁发机构保证。不过这种证书需要向颁发机构申请，颁发机构会花时间去进行公司域名身份等信息验证，所以花费也不少。 对于第二种，本地生成的证书（后面会附录如何生成自签名证书），证书常用的信息都可以生成，可以认为证书信息内容都不可靠，尤其是证书中的域名。使用自制证书在浏览器会弹出警告不可信，用户可以手动添加到信任列表里，之后可信了才可以访问，12306之前让下载证书导入，就是这个原因。在应用APP里，如果使用默认配置，会拒绝，返回SSL验证失败。 在应用内信任自生成证书有两种办法： 第一种 安装描述文件到系统里。在安装charles过程中，其中一步就是打开一个网址，在弹出安装的时候，安装这个证书，也可以把这个证书下载到云盘里，然后打开。这个过程需要用户手动授权。这个起效后是全局的，任何应用都会影响。 第二种 把这个根证书，埋入APP里,然后设置为证书锚点（可以设置多个），然后在SSL握手需要验证证书的时候，系统会认为这个证书是有效的。这个方案也是很多自签名证书进行校验的方法。这个只会在本应用里起作用。 中间人攻击中间人攻击是最常见的攻击HTTPS手段。 建议看这篇文章：iOS安全系列之二：HTTPS进阶 看到上面的验证手段，其实关键就在于如何信任CA根证书上面。攻击者就是想尽一切办法让客户端安装他自己的CA证书到你的手机里。 如果手机没有越狱，一定会引诱你去安装这个证书，并且手动设为可信。一旦信任，在访问服务器的时候，攻击者通过代理劫持，通过这个信任的CA证书，生成对应的域名的证书。最终因为域名可信，有效期可信，证书可信整个HTTPS建立成功，攻击者拿到相关的数据。 使用charles抓包的整个过程，其实就是中间人攻击的过程。 附：下面是charles开启SSL代理后，访问新浪弹出的证书信息，可以看到charles生成了新浪域名的证书： 提示：对于用户来说，不要信任任何CA证书，不安装任何描述文件是最安全的方法。比如安装飙车软件，让你信任一个证书。比如链接外部wifi，提示你安装证书才可以链接。比如翻墙设置代理，提示你安装信任证书。描述文件在通用-&gt;描述文件与设备管理中找到。 校验证书的姿势校验证书有两种方案： 弱校验 对于服务端证书，校验下面的case。 校验证书的域名 校验证书的有效期 校验证书链和证书的有效性 保证这三者有效，已经可以解决大部分的攻击了。唯一的风险就是中间人攻击，被安装CA证书之后，一个被信任的CA根证书可以生成符合上面要求的任何域名的证书。存在着风险，但是攻击难度已经大大增加了。AFNetworking框架默认采用的就是这个策略。 强校验 将证书放入APP中作为证书锚点。在上面的基础上再验证证书。这样可以完全保证服务端的证书是真正需要的证书，从而真正解决中间人攻击。 下面主要讲下强校验面临的坑，各位开发一定要注意。 证书强校验的坑证书是有有效期的，尤其是非自制证书，通常都在三年以内（很多资料根本不谈这个问题）。一旦有效期过了，服务端就需要更换证书,但是由于APP存在发版的情况，老的APP由于所有链接失败，导致老APP任何请求都失效，然后无法通知用户更新，老用户也不知道因为什么访问失败。（这些都是血的教训啊） 有几个建议的地方： 尽量埋CA证书，因为CA证书的有效期要长，有足够的时间准备。 有些通道不要使用证书强校验，比如检查升级，一些热修复策略，尽量使用自有的安全逻辑保证安全。 如果是自制证书，建议有效期设置长一些。 上面的是尽量降低风险，该出问题的时候还是会出，有一些不完美的方案大家可以参考下： 方案1：动态更新证书。 在APP中放入RSA公钥，应用启动的时候，证书信息通过私钥加密，发送给前端保存，前端把这个新证书和埋入的证书一起做锚点，进行验证。这样可以保证老APP可以使用一段时间。缺点是这个下发的机制要尽量安全可靠，有可能被攻击者利用，而且后续的请求需要依赖这个请求，所以方案复杂一些。 方案2：只验证证书的公钥 只使用证书的公钥进行验证，因为更换证书，一般是通过.csr文件生成crt证书文件的（也就是证书文件），在.csr文件没变的情况下，生成的证书的公钥是一致的，也就即使服务端更换了证书，只要公钥不变，依然可以通过验证。所以验证公钥也是相对安全的。缺点是如果新的证书换了公钥还是出问题。我遇到的case就是需要更换私钥和证书算法，公钥也不一样了。 其他不太靠谱的方案： 方案3： 在弱校验的基础上，加上验证颁发机构。只要读到颁发机构是可信的，证书就认为是有效的。可以解决第三方抓包工具的抓包问题，因为第三方抓包工具，一般使用自己的颁发机构，和实际的颁发机构不一致。缺点是，证书是可以完全伪造的，包括颁发结构的名字，有效期等等都可以伪造。 方案4： 信任无效的证书。 信任无效的证书，但是做本地证书校验，在失效的一段时间内，后端先不部署新证书，在新版本里面提前埋入新证书，在几个版本后再上线新的证书。优点是简单，不怕哪天忘了更换证书导致出问题。缺点是信任失效的证书，如果真的有需求要强制更换证书，就没办法处理。 附录:如何生成自签名证书参考 深入解析HTTPS和利用OpenSSL创建自签名的SSL证书 和 自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名 生成私钥 openssl genrsa -out ca.key 4096 利用私钥创建根证书 openssl req -new -x509 -days 36500 -key ca.key -out ca.crt 弹出的对话框按照提示填写： 1234567 Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangdongLocality Name (eg, city) []:ShenzhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:BL.incOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:BLEmail Address []: 创建SSL证书私钥 openssl genrsa -out server.key 4096 使用刚才的私钥签名 openssl req -new -key server.key -out server.csr 弹出的对话框按照提示填写： 12345678910111213 Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangdongLocality Name (eg, city) []:ShenzhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:BL.incOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:*.sina.com.cnEmail Address []:Please enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:1111An optional company name []: 注意，这里的Common Name 应该和实际的域名匹配。而且生成的.csr这个文件最好长期保留，下次过期的时候，建议直接用这个文件做签名。如果是向CA颁发机构申请，提交的文件也是这个文件。 对上一步的csr使用CA进行签名生成证书 openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt 如果是向CA机构申请，提交这个文件就可以了。 如果有必要可以重复上面必要步骤，使用上一步的证书的.crt和.key继续签名下一级证书。 一些常用命令： 12345 openssl s_client -connect www.google.com:443 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer //获取www.google.com:443的ssl证书，地址可以换成自己的openssl rsa -noout -text -in server.key 查看私钥信息openssl req -noout -text -in server.csr 查看签名请求信息openssl x509 -noout -text -in ca.crt 查看证书信息 MAC下使用Charles抓包参考 深入解析HTTPS 和 iOS安全系列之二：HTTPS进阶 安装Charles CA根证书 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certification …，会弹出如下提示，链接代理，手机浏览器输入chls.pro/ssl，就可以安装根证书了。 设置SSL代理 点击Proxy-&gt;SSL Proxying Setting，勾选Enable SSL Proxying，然后点击Add输入要SSL代理的请求Host和Port，可以使用通配符来表示某一类请求。 或者在对应的请求上右键选择Enable SSL Proxying，就会把这一个请求加入到上面的SSL代理列表中（类似于点击Add的效果）。 做完上述步骤后重新请求就能得到解密后的信息了。ps:抓取PC端的HTTPS包也类似，在Help-&gt;SSL Proxying中下载证书，双击安装证书，并选择始终信任即可。 在iPhone端设置HTTP代理 在Mac上获取当前机器的IP地址： ifconfig en0: ch将iPhone连接到与电脑相同的WiFi，在iPhone设置中：无线局域网 -&gt; 已连接WiFi右边的Info详情图标 -&gt; HTTP代理 -&gt; 手动 -&gt; 设置HTTP代理： 设置完成之后，打开Safari随便访问一个网页，初次设置代理的话，Charles会弹出一个iPhone请求代理的确认框，点击Allow即可。然后在Charles上就可以看到iPhone上的HTTP请求了。为了避免Mac上的请求过多影响对被代理iPhone上HTTP请求的查看和调试，可以在Charles取消Mac的代理：Menu -&gt; Proxy -&gt; 取消勾选Mac OS X Proxy 即可。 参考文献 HTTP协议详解（真的很经典） MQTT_github 说说http协议中的编码和解码 HTTP协议之multipart/form-data请求分析 苹果文档翻译 iOS10 NSAppTransportSecurity iOS中的HTTPS, 你知道多少? 阮一峰：图解SSL/TLS协议 SSL与TLS的区别以及介绍 浅析HTTPS中间人攻击与证书校验 SSL、TLS协议格式入门学习 - .Little Hann iOS安全系列之二：HTTPS进阶 HTTPS 理论详解与实践 利用OpenSSL创建自签名的SSL证书 自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名 深入解析HTTPS TLS/SSL 高级进阶]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>HTTPS</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
</search>