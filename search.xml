<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IOS应用安全-加解密算法简述]]></title>
    <url>%2F2017%2F05%2F25%2Fsave-encode%2F</url>
    <content type="text"><![CDATA[导读客户端经常遇到需要对数据进行加密的情况，那应该如何加密，选用什么样的加密算法，是本文想要讨论的问题。 如果把我们的数据比作笔记，那数据加密相当于给笔记本上了锁，解密相当于打开锁看到笔记。而打开锁的钥匙一定是在私人手里的，外人是打不开的。所以数据加密一定有三个关键字： 1.加密2.解密3.秘钥 所以有些常见的算法不是数据加密的范围，这个开发需要注意。比如Base64编码，MD5算法。 Base64只是把数据编码，通俗讲只是把原来用汉语写的笔记内容，改成用英语写的内容，只要懂转换规则的任何人都能得到数据。所以老板说把数据加下密，一定不是让你Base64一下或者用其他编码重新编码下，编码算法不涉及到数据安全。 MD5算法也是数据处理的一种方式，更多的被用在数据验证身上。用上面的例子来讲，MD5算法把整本书的内容变成了一句标题，通过标题是没办法推算出整个书讲什么的。因为根本没有解密的步骤，所以也不属于加密算法。 字符编码计算机的所有数据，最终都是由多个二进制bit(0/1)来存储和传输的，但是怎么从0/1转化成我们可读的文字，就涉及到编码的知识了。下面是基础的编码概念。 ASCII （NSASCIIStringEncoding）使用一个字节大小表示的128个字符。其中这些字符主要是因为字符，现在很少使用这个编码，因为不够用。ASCII字符占用一个字节。ASCII码表 主要使用到的是英文字母的大小写转换。大写的A~Z编码+32等于小写的a~z。 UNICODE (NSUnicodeStringEncoding)ASCII只能表示128个字符，对于英文国家来说足够了，对于我们中国来说，我们有几万个汉字不够啊。于是我们创造出了GB2312等等我们自己的字符集。日本也觉得我也不够啊，我也搞个字符集。这些字符集彼此是不兼容的，没办法转换，同样的字符ABCD,我们可能表示好,日本就可能就表示坏。于是程序猿们觉得我要搞个标准，大家都按照标准来。 于是就有了UNICODE编码。它是所有字符的国际标准编码字符集。这个是为了解决ASCII字符不够的问题。同时让所有组织使用同一套编码规则，解决编码不兼容的问题。所以现在通用的编码规则都是UNICODE编码。UNICODE向下兼容ASCII编码。UNICODE最大长度可以到4个字节。不过通常只使用两个字节表示。所以通常认为UNICODE占用2字节数据。 UTF-8 （NSUTF8StringEncoding）其实UNICODE已经足够使用了，不过因为如果是ASCII表示的字符（比如英文）只需要1字节就可以了，UNICODE表示的话其中一个字节全是0，这个字节浪费了，英语国家的程序猿觉得：我靠，我又不需要那么多复杂的字符,浪费我流量和空间啊，不行！！，于是出现了对UNICODE的转换，也就是UTF-8格式，可以保证原ASCII字符依然用一个字节表示，非ASCII字符使用多个字符表示。 UNICODE到UTF-8的规则如下： 按照UNICODE编码的范围，算出需要几个字节，比如1个字节数，2个字数节，3个字节数，4个字节数。具体范围参考下面的图。 单字节和ASCII码完全相同， 对于其他字节数，字节1的前面用1填充，几个字节数就添加几个1，后面补一个0。其他字节都用10开头。 剩余的位置，按照顺序把原始数据补齐。 例子： “汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 对于UTF-8编码的文件，会在文件头写入EF BB BF,表明是UTF-8编码。 UTF-16 （NSUTF16StringEncoding）UTF-16的编码方法是： 如果二进制流b小于0x10000，也就是十进制的0到65535之内，则直接使用两字节表示。 如果二进制流b大于等于0x10000，将b-0x10000的结果中的前 10 位作为高位和0xD800进行逻辑或操作，将后10 bit作为低位和0xDC00做逻辑或操作，这样组成的4个字节就构成了b的编码。 举个例子。假设要算（U+2A6A5，四个繁体字龙）在UTF-16下的值，因为它超过 U+FFFF，所以 2A6A5-10000=0x1A6A5=。 前10位0001 1010 01 | 0xD800 = 0xD896。 后10位10 1010 0101 | 0xDC00 = 0xDEA5。 所以U+ 2A6A5 在UTF-16中的像是D8 96 DE A5。 注：上文参考：精确解释Unicode 在IOS程序里面NSUTF16StringEncoding和NSUnicodeStringEncoding是等价的。 UTF-16大端/小端（NSUTF16BigEndianStringEncoding/NSUTF16LittleEndianStringEncoding）大小端主要表明了，系统存储数据的顺序。因为UTF-16至少两个字节，这两个字节传输过来后，接收的人需要知道哪个字节是在前，哪个字节在后。然后系统才知道改如何存取。 Unicode规范中用字节序标记字符（BOM）来标识字节序，它的编码是FEFF。这样如果接收者收到FEFF，就表明这个字节流是高位在前的；如果收到FFFE，就表明这个字节流是低位在前的。 比如“汉”字的Unicode编码是0x6C49。 对于大端的文件数据为：FE FF 6c 49对于小端的文件数据为：FF FE 49 6c 对于大小端的概念，本人经常搞混，什么高地址存低字节的，绕一绕就晕了。下面是我的理解： 对于一个16进制数0x1234,我们知道这个数对应的是两个字节，占用16个比特。 系统中是按照字节为单位去保存数据的。一个地址空间对应1个字节。比如0x1234如果要存储在计算机里，需要占用两个地址空间。我们假设这个地址空间起始是0x00，因为需要两个字节，所以还需要一个地址空间来保存，即0x01。其中明显0x01是高地址空间。 所以问题就在于，对于0x1234这个数据保存，是0x01地址保存0x12还是保存0x24。 如果把0x1234看成字符串形式，按照正常顺序存储，先存0x12,后存0x34,对应的就是大端模式。 如果按照字节顺序，0x12是高位，0x34是低位，应该0x12存储在高位地址0x02,低位字节0x34存储在低位地址0x01。这种方式就是小端模式。 为了怕记混，可以这么记：我最大，按字符串顺序存储，我看的最舒服所以是大端。反面的就是小端的。 地址偏移 大端模式 小端模式 0x00 12 34 0x01 34 12 附：代码判断大小端的代码。 原理是生成一个两字节的数据，然后转为1字节的char数据。大端取到的是第一个高字节，小端取到的是第二个低字节。 123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; short x = 1; //0x0001 char *p = (char *)&amp;x; if(*p) &#123; printf(&quot;little\n&quot;); &#125; else &#123; printf(&quot;large\n&quot;); &#125; return 0;&#125; UTF-32详细的本人没看懂，实际中没有用到这个编码，这个编码使用4字节存储。也有大小端之分 总结 字符编码就是把可读的字符转化为二进制数据方法，字符解码就是把二进制数据转化为可读的方法。 ASCII占用1个字节，只有128个字符，主要是英文字符。 UNICODE是国际标准编码字符集，包含了所有已知符号。 UTF-8是UNICODE编码的一种实现方式，兼容ASCII码，也就是英文字符占1个字节，汉字可能占两个字节或三个字节。 UTF-16也是UNICODE编码的一种实现方式，通常和UNICODE编码一致，占用两个字节，分大小端。 Base64编码Base64编码的作用是把非ASCII的字符转换为ASCII的字符。很多加密算法，很喜欢做一次Base64转换。原因是使用Base64编码后，所有的数据都是ASCII字符，方便在网络上传输。 设计思路是：Base64把每三个8Bit的字节转换为四个6Bit的字节（38 = 46 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节。所以Base64算法生成的数据会比原数据大1/3左右。 比如： 图片这种二进制数据就可以转换为Base64作为文本传输。 比如有中文的数据，可以通过Base64转为可以显示的ASCII数据 简单说明： 将字符按照文字编码转化为二进制字节。 每3字节化为一组（24bit），如果字节不够，最后输出结果补=。然后再把每一组拆分成4个组，每个组6bit,如果不足6bit后面补0。 将每个6bit前面补足两个0，凑够8位。 然后按照新分出来的每8位转成10进制数，按照表里面的查找，转为对应的ASCII字符。 举例： 字符bl如何转化为Base64编码： bl对应的ASCII码为： 01100010和01101100,因为只有两个，所以有一个输出结果是= 按照每三个字节分组：0110001001101100 按照每个组6bit分4个组,不足6位的补0：011000,100110,110000 在前面补0,凑够8位：00011000,00100110,00110000 转为10进制：24,38,48。 查表得到：Y,m,w 最后补=,所以结果为Ymw= 标准的程序实现可以参考：GTMBase64.m。 说明： Base64是一种编码算法，不是加密算法,他的作用不是加密，而是用最简的ASCII码来传输文本数据，屏蔽掉设备网络差异，是为了方便传输的一种算法。很多加密算法，最后生成的是二进制数据，不是可见字符，而传输的一般是通过字符传输，所以常见的二进制转化方式就是Base64算法。 哈希散列算法一个萝卜一个坑这个俗语形容这个算法很贴切。官方的定义为： 散列（Hash）函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。 安全的哈希算法要满足下面条件： 固定长度。不同长度的数据，生成的固定长度的数据 唯一性。不同的数据，生成的结果一定不同。相同的数据，每次输出的结果一定一样。 不可逆。对于生成后的数据，反推回原数据，通过算法是不可能的。 防篡改。两个输出的散列值相同，则原数据一定相同。如果两个输出的散列值不同，则原数据一定不同。 从上面的特点可以知道散列值主要使用的场景： 生成唯一的值做索引，比如哈希表 用作数据签名，校验数据完整性和有效性。 密码脱敏处理。 MD5算法MD5算法是最常用的散列算法。 对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为十六个32位子分组，经过了一系列的处理后，算法的输出由4个32位分组组成，将这4个32位分组级联后将生成1个128位散列值。 算法有点复杂，没有看懂，放下不表。 下面是本人的简单理解： MD5算法效率是比较快的。 MD5防碰撞能力比较强，只有少数的几个例子有出现碰撞的情况。但也不影响安全性。 MD5生成的是固定128位,16个字节。 MD5算法安全性目前主流看法是MD5逐渐有被攻克的风险。但是目前还没有有效算法破解。 主要的破解方法是使用数据库保存常见的字符串的MD5值，然后通过反查得到原始数据。也就是如果用户的密码很常见就很容易破解。如果用户密码是随机的，那就没什么平台可以破解了。 下面对于是用MD5的观点： MD5不是加密算法，重要的用户密码应该加密存储。做MD5只是为了脱敏，也就是不让相关人员知道原文是什么（包括内鬼）。 极重要数据是用更安全的算法：比如用户密码数据使用更安全的算法，比如SHA1算法。传输过程中也进一步加密。 如果使用MD5算法，在原始值里面加入盐值。盐值要尽量随机。因为如果加入随机值后原始值也变得随机，使用暴力破解就基本不可能了。即result = MD5(password + salt) 关于加盐这里有个破解的网站，大家可以看下常用的策略其实都可以破解。安全性主要是盐如何选择。 盐值要是随机字符，数据尽量长一些，只有这样才能保证最后数据的随机。 盐值尽量保证每个用户不一样，增加破解的难度。 盐值的保存可以是前后端约定,固化在APP里，但是也应该和用户相关，比如salt=(固化的值+用户信息)。可以是通过一些随机值变化得来：比如用户注册时间等信息做盐值。可以是每次随机生成，当做参数带给后端，后端保存密码+盐值。安全性从低到高。还有做多次MD5的，个人觉得意义不大。 个人推荐的一个方案。result = MD5 (password + salt)。salt的计算方法是：MD5(Random(128)+ uid)。其中Random(128)表示一个随机128位字符串，两端可以一致，固化在代码里。uid是用户唯一标示，比如登陆用的用户名。这样对于破解者来说就需要先拿到这个salt值，然后对每个用户都要生成一个唯一的128位的盐值，去生成对应的库，破解成本就非常高了。 其实目前暴漏出来的是攻击者把整个数据库的内容拿到后，暴力解密出原文。但是MD5加盐也好变换也好都是可以通过前端代码查到算法的，通过算法就可以生成常用数据对应的MD5库。所以密码做MD5更重要的是脱敏处理，不能做为安全的加密使用，重要的用户密码持久化或传输过程中一定是要通过加密算法处理的。这样只要安全保存私钥就可以了。在很多金融公司，大量使用硬件加密机做加密处理，然后保存，更加大了破解难度。所以如果你的密码是使用加密再保存的，使用固定盐值的已经可以满足要求了。如果担心可以加上用户的注册时间或服务器时间戳做盐值。 SHA1SHA1也是一种HASH算法。是MD5的替代方案。生成的数据是160位，20个字节。 目前SHA1也被认为不安全,google找到了算法进行了碰撞,所以普遍推荐使用新的SHA2代替。Google已经开始废弃这个算法了。 SHA2 SHA-224、SHA-256、SHA-384，和SHA-512并称为SHA-2。 新的散列函数并没有接受像SHA-1一样的公众密码社区做详细的检验，所以它们的密码安全性还不被大家广泛的信任。 虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。 所以目前推荐使用SHA2相关的算法做散列算法。 其中SHA-256输出为256位，32字节。SHA-512输出为512位，64字节。 HMacHMac是秘钥相关的哈希算法。和之前的算法不同的在于需要一个秘钥，才能生成输出。主要是基于签名散列算法。可以认为是散列算法加入了加密逻辑，所以相比SHA算法更难破解，包含下面的算法。 1234567891011121314151617181920/*! @enum CCHmacAlgorithm @abstract Algorithms implemented in this module. @constant kCCHmacAlgSHA1 HMAC with SHA1 digest @constant kCCHmacAlgMD5 HMAC with MD5 digest @constant kCCHmacAlgSHA256 HMAC with SHA256 digest @constant kCCHmacAlgSHA384 HMAC with SHA384 digest @constant kCCHmacAlgSHA512 HMAC with SHA512 digest @constant kCCHmacAlgSHA224 HMAC with SHA224 digest */enum &#123; kCCHmacAlgSHA1, kCCHmacAlgMD5, kCCHmacAlgSHA256, kCCHmacAlgSHA384, kCCHmacAlgSHA512, kCCHmacAlgSHA224&#125;;typedef uint32_t CCHmacAlgorithm; HMAC主要应用场景： 密码的散列存储，因为需要散列的时候需要密码，实际上相当于算法里加了盐值。使用的密码要随机和用户相关，请参考盐值的生产规则。 用于数据签名。双方使用共同的秘钥，然后做签名验证。秘钥可以固化，也可以会话开始前协商，增加签名篡改和被破解的难度。 PS：目前项目中的密码散列算法，采用的就是HMac算法。 总结 密码保存和传输需要做散列处理。但是散列算法主要是脱敏，不能替代加密算法。 如今常用的Md5算法和SHA1算法都不再安全。所以推荐使用SHA-2相关算法。 散列算法应该加入盐值即：result=HASH(password+salt)。其中盐值应该是随机字符串且每个用户不一样。 HMac引入了秘钥的概念，如果不知道秘钥，秘钥不同，散列值也不同，相当于散列算法加入了盐值。可以把它当做更安全的散列算法使用。 算法实现算法都是使用苹果自己的Security.framework框架实现的，只需要调用相关算法就可以了。推荐一个github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229//// NSData+KKHASH.m// SecurityiOS//// Created by cocoa on 16/12/15.// Copyright © 2016年 dev.keke@gmail.com. All rights reserved.//#import &quot;NSData+KKHASH.h&quot;#include &lt;CommonCrypto/CommonDigest.h&gt;#import &lt;CommonCrypto/CommonHMAC.h&gt;@implementation NSData (KKHASH)- (NSData *)hashDataWith:(CCDIGESTAlgorithm )ccAlgorithm&#123; NSData *retData = nil; if (self.length &lt;1) &#123; return nil; &#125; unsigned char *md; switch (ccAlgorithm) &#123; case CCDIGEST_MD2: &#123; md = malloc(CC_MD2_DIGEST_LENGTH); bzero(md, CC_MD2_DIGEST_LENGTH); CC_MD2(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_MD2_DIGEST_LENGTH]; &#125; break; case CCDIGEST_MD4: &#123; md = malloc(CC_MD4_DIGEST_LENGTH); bzero(md, CC_MD4_DIGEST_LENGTH); CC_MD4(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_MD4_DIGEST_LENGTH]; &#125; break; case CCDIGEST_MD5: &#123; md = malloc(CC_MD5_DIGEST_LENGTH); bzero(md, CC_MD5_DIGEST_LENGTH); CC_MD5(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_MD5_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA1: &#123; md = malloc(CC_SHA1_DIGEST_LENGTH); bzero(md, CC_SHA1_DIGEST_LENGTH); CC_SHA1(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA224: &#123; md = malloc(CC_SHA224_DIGEST_LENGTH); bzero(md, CC_SHA224_DIGEST_LENGTH); CC_SHA224(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA224_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA256: &#123; md = malloc(CC_SHA256_DIGEST_LENGTH); bzero(md, CC_SHA256_DIGEST_LENGTH); CC_SHA256(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA256_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA384: &#123; md = malloc(CC_SHA384_DIGEST_LENGTH); bzero(md, CC_SHA384_DIGEST_LENGTH); CC_SHA384(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA384_DIGEST_LENGTH]; &#125; break; case CCDIGEST_SHA512: &#123; md = malloc(CC_SHA512_DIGEST_LENGTH); bzero(md, CC_SHA512_DIGEST_LENGTH); CC_SHA512(self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA512_DIGEST_LENGTH]; &#125; break; default: md = malloc(1); break; &#125; free(md); md = NULL; return retData; &#125;- (NSData *)hmacHashDataWith:(CCHmacAlgorithm )ccAlgorithm key:(NSString *)key &#123; NSData *retData = nil; if (self.length &lt;1) &#123; return nil; &#125; unsigned char *md; const char *cKey = [key cStringUsingEncoding:NSUTF8StringEncoding]; switch (ccAlgorithm) &#123; case kCCHmacAlgSHA1: &#123; md = malloc(CC_SHA1_DIGEST_LENGTH); bzero(md, CC_SHA1_DIGEST_LENGTH); CC_SHA1(self.bytes, (CC_LONG)self.length, md); CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH]; &#125; break; case kCCHmacAlgSHA224: &#123; md = malloc(CC_SHA224_DIGEST_LENGTH); bzero(md, CC_SHA224_DIGEST_LENGTH); CCHmac(kCCHmacAlgSHA224, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA224_DIGEST_LENGTH]; &#125; break; case kCCHmacAlgSHA256: &#123; md = malloc(CC_SHA256_DIGEST_LENGTH); bzero(md, CC_SHA256_DIGEST_LENGTH); CCHmac(kCCHmacAlgSHA256, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA256_DIGEST_LENGTH]; &#125; break; case kCCHmacAlgSHA384: &#123; md = malloc(CC_SHA384_DIGEST_LENGTH); bzero(md, CC_SHA384_DIGEST_LENGTH); CCHmac(kCCHmacAlgSHA384, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA384_DIGEST_LENGTH]; &#125; break; case kCCHmacAlgSHA512: &#123; md = malloc(CC_SHA512_DIGEST_LENGTH); bzero(md, CC_SHA512_DIGEST_LENGTH); CCHmac(kCCHmacAlgSHA512, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_SHA512_DIGEST_LENGTH]; &#125; break; case CCDIGEST_MD5: &#123; md = malloc(CC_MD5_DIGEST_LENGTH); bzero(md, CC_MD5_DIGEST_LENGTH); CCHmac(kCCHmacAlgMD5, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md); retData = [NSData dataWithBytes:md length:CC_MD5_DIGEST_LENGTH]; &#125; break; default: md = malloc(1); break; &#125; free(md); md = NULL; return retData;&#125;- (NSString *)hexString&#123; NSMutableString *result = nil; if (self.length &lt;1) &#123; return nil; &#125; result = [[NSMutableString alloc] initWithCapacity:self.length * 2]; for (size_t i = 0; i &lt; self.length; i++) &#123; [result appendFormat:@&quot;%02x&quot;, ((const uint8_t *) self.bytes)[i]]; &#125; return result;&#125;+ (NSData *)dataWithHexString:(NSString *)hexString &#123; NSMutableData * result; NSUInteger cursor; NSUInteger limit; NSParameterAssert(hexString != nil); result = nil; cursor = 0; limit = hexString.length; if ((limit % 2) == 0) &#123; result = [[NSMutableData alloc] init]; while (cursor != limit) &#123; unsigned int thisUInt; uint8_t thisByte; if ( sscanf([hexString substringWithRange:NSMakeRange(cursor, 2)].UTF8String, &quot;%x&quot;, &amp;thisUInt) != 1 ) &#123; result = nil; break; &#125; thisByte = (uint8_t) thisUInt; [result appendBytes:&amp;thisByte length:sizeof(thisByte)]; cursor += 2; &#125; &#125; return result;&#125;@end 对称加密算法对称加密，指双方使用的秘钥是相同的。加密和解密都使用这个秘钥。 对称加密的优点为： 加密效率高 加密速度快 可以对大数据进行加密 缺点为： 秘钥安全性无法保证，以现在的技术手段来说，默认对称秘钥的秘钥是非安全的，可以被拿到的。 加密方法 DES ：数据加密标准。 是一种分组数据加密技术，先将数据分成固定长度64位的小数据块，之后进行加密。 速度较快，适用于大量数据加密。DES密钥为64位,实际使用56位。将64位数据加密成64位数据。 3DES：使用三组密钥做三次加密。 是一种基于 DES 的加密算法，使用3个不同密钥对同一个分组数据块进行3次加密，如此以使得密文强度更高。3DES秘钥为DES两倍或三倍，即112位或168位。其实就是DES的秘钥加强版。 AES ：高级加密标准。 是美国联邦政府采用的一种区块加密标准。 相较于 DES 和 3DES 算法而言，AES 算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准。AES秘钥长度为128、192、256位。 使用到的基础数学方法： 移位和循环移位 移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。 置换 就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。 扩展 就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。 压缩 就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。 异或 这是一种二进制布尔代数运算。异或的数学符号为⊕ ，它的运算法则如下：1⊕1 = 00⊕0 = 01⊕0 = 10⊕1 = 1 也可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。 迭代 迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。 对于对称加密来说，有几个共同要点： 密钥长度；（关系到密钥的强度） 加密模式；（ecb、cbc等等） 块加密算法里的块大小和填充方式区分； 加密模式ECB 模式ECB ：电子密本方式，最古老,最简单的模式，将加密的数据分成若干组，每组的大小跟加密密钥长度相同；然后每组都用相同的密钥加密。OC对应的为kCCOptionECBMode ECB的特点为： 每次Key、明文、密文的长度都必须是64位； 数据块重复排序不需要检测； 相同的明文块(使用相同的密钥)产生相同的密文块，容易遭受字典攻击； 一个错误仅仅会对一个密文块产生影响，所以支持并行计算； CBC模式 CBC ：密文分组链接方式。与ECB相比，加入了初始向量IV。将加密的数据分成若干组，加密时第一个数据需要先和向量异或之后才加密。后面的数据需要先和前面的数据异或，然后再加密。是OC默认的加密模式。 CBC的特点为： 每次加密的密文长度为64位(8个字节); 当相同的明文使用相同的密钥和初始向量的时候CBC模式总是产生相同的密文; 密文块要依赖以前的操作结果,所以，密文块不能进行重新排列; 可以使用不同的初始化向量来避免相同的明文产生相同的密文,一定程度上抵抗字典攻击; 一个错误发生以后,当前和以后的密文都会被影响; 块大小和填充方式对称算法的第一步就是对数据进行分组，每一个组的大小称为快大小，比如DES需要将数据分组为64位（8个字节），如果数据不够64位就需要进行补位。 PKCS7Padding填充OC中指定的填充方法只有kCCOptionPKCS7Padding，对应JAVA的PKCS5Padding填充方式。算法为计算缺几位数，然后就补几位数，数值为下面的公式： value=k - (l mod k) ,K=块大小，l=数据长度，如果l=8, 则需要填充额外的8个byte的8 比如块大小为8字节，数据为DD DD DD DD4个字节，带入公式，l=4,k=8,计算 8 - （4 mod 8）= 4 ,所以补充4个4，补位后得到DD DD DD DD 04 04 04 04。 唯一特别的是如果最后位数是够的，也需要额外补充，比如数据是DD DD DD DD DD DD DD DD8个字节,带入公式，l=8,k=8,计算 8 - （8 mod 8）= 8，所以补位后得到DD DD DD DD DD DD DD DD 08 08 08 08 08 08 08 08。 所以如果考虑补位，实际输出buffer大小要加上快大小，防止buffer不够。 Zero Padding（No Padding）补位的算法和PKCS7Padding一致，只不过补的位为0x00,比如数据为DD DD DD DD4个字节，带入公式，l=4,k=8,计算 8 - （4 mod 8）= 4 ,所以补充4个00，补位后得到DD DD DD DD 00 00 00 00。 非常不建议用这种模式，因为解密后的数据会多出补的00。如果原始数据以00结尾(ASCII码代表空字符)，就没办法区分出来了。 几种算法比较 算法 秘钥长度（字节） 分组长度（字节） 加密效率 破解难度 DES 8 8 较快（22.5MB/S） 简单 3DES 24 8 慢（12MB/S） 难 AES 16/24/32 16 快（51.2MB/s） 难 IOS 代码实现解析下面以AES代码实现为例，说明下IOS加解密算法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131+ (NSString *)AES128Encrypt:(NSString *)plainText key:(NSString *)gkey iv:(NSString *)gIv padding:(BOOL)padding&#123; //先处理秘钥，如果秘钥不够算法长度，就用0填充，如果长于算法长度就截断。 char keyPtr[kCCKeySizeAES128+1]; //申请秘钥buffer，这里根据不同算法导入需要的key长度。AES128是16个字节，对应的值kCCKeySizeAES128。 memset(keyPtr, 0, sizeof(keyPtr)); //使用0填充，保证秘钥长度达到要求。 [gkey getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; //将传入的秘钥copy进秘钥buffer里 //注意这个只在模式为CBC下有效， //处理向量值，默认模式为CBC。如果指定了kCCOptionECBMode模式，就不需要这个向量。 char ivPtr[kCCBlockSizeAES128+1]; //申请向量的buffer，长度为块长度。AES128块长度为kCCBlockSizeAES128。 memset(ivPtr, 0, sizeof(ivPtr)); [gIv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding]; //将传入的值copy进向量buffer NSData* data = [plainText dataUsingEncoding:NSUTF8StringEncoding]; NSUInteger dataLength = [data length]; //注意这个只在不指定padding的情况下有效，需要填充0，算法为num_to_fill= k - (length mod k)，如果指定了kCCOptionPKCS7Padding，就不需要人为填充。 long long newSize = dataLength; int diff = padding ? 0 : kCCKeySizeAES128 - (dataLength % kCCKeySizeAES128); if(diff &gt; 0) &#123; newSize = dataLength + diff; &#125; char dataPtr[newSize]; memcpy(dataPtr, [data bytes], [data length]); for(int i = 0; i &lt; diff; i++) &#123; dataPtr[i + dataLength] = 0x00; &#125; //输出的buffer size_t bufferSize = newSize + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); memset(buffer, 0, bufferSize); size_t numBytesCrypted = 0; CCOptions option = padding ? kCCOptionPKCS7Padding : 0x0000; option = gIv.length &gt; 0 ? option : option | kCCOptionECBMode; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, option,// 0x0000, //No padding | CBC模式 需要补零且需要iv向量// kCCOptionPKCS7Padding, // kCCOptionPKCS7Padding | CBC模式 需要iv向量 //kCCOptionPKCS7Padding | kCCOptionECBMode, // kCCOptionPKCS7Padding | kCCOptionECBMode 不需要iv向量，也不需要补零// kCCOptionECBMode, // No padding | kCCOptionECBMode 不需要补零，不需要iv向量 keyPtr, kCCKeySizeAES128, ivPtr, dataPtr, sizeof(dataPtr), buffer, bufferSize, &amp;numBytesCrypted); if (cryptStatus == kCCSuccess) &#123; NSData *resultData = [NSData dataWithBytesNoCopy:buffer length:numBytesCrypted]; resultData = [resultData base64EncodedDataWithOptions:(NSDataBase64EncodingOptions)0]; NSString *encryptedString = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding]; return encryptedString; &#125; free(buffer); return nil;&#125;+ (NSString *)AES128Decrypt:(NSString *)encryptText key:(NSString *)gkey iv:(NSString *)gIv padding:(BOOL)padding&#123; //复制秘钥buffer char keyPtr[kCCKeySizeAES128 + 1]; memset(keyPtr, 0, sizeof(keyPtr)); [gkey getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; //复制向量buffer char ivPtr[kCCBlockSizeAES128 + 1]; memset(ivPtr, 0, sizeof(ivPtr)); [gIv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding]; NSData *data = [[NSData alloc] initWithBase64EncodedString:encryptText options:0]; NSUInteger dataLength = [data length]; size_t bufferSize = dataLength + kCCBlockSizeAES128; void *buffer = malloc(bufferSize); //计算采用哪种模式和填充方式 CCOptions option = padding ? kCCOptionPKCS7Padding : 0x0000; option = gIv.length &gt; 0 ? option : option | kCCOptionECBMode; size_t numBytesCrypted = 0; //解密 CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, option,// 0x0000, //No padding | CBC模式 需要补零且需要iv向量// kCCOptionPKCS7Padding, // kCCOptionPKCS7Padding | CBC模式 需要iv向量 //kCCOptionPKCS7Padding | kCCOptionECBMode, // kCCOptionPKCS7Padding | kCCOptionECBMode 不需要iv向量，也不需要补零// kCCOptionECBMode, // No padding | kCCOptionECBMode 不需要补零，不需要iv向量 keyPtr, kCCBlockSizeAES128, ivPtr, [data bytes], dataLength, buffer, bufferSize, &amp;numBytesCrypted); if (cryptStatus == kCCSuccess) &#123; NSData *resultData = [NSData dataWithBytesNoCopy:buffer length:numBytesCrypted]; NSString *result = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding]; if ([result length] &gt; 0 &amp;&amp; !padding) &#123; //如果是非填充模式，解析后的数据会多出填充的'\0',所以需要去掉。 long byteWithoutZero = numBytesCrypted; const char *utf8Str = [result UTF8String]; //从后开始扫描，查到需要截断的长度 for (long i = byteWithoutZero - 1; i &gt; 0; i --) &#123; if (utf8Str[i] != '\0') &#123; break; &#125; byteWithoutZero --; &#125; NSString *finalReslut = [[NSString alloc] initWithBytes:utf8Str length:byteWithoutZero encoding:NSUTF8StringEncoding]; return finalReslut; &#125; return result; &#125; free(buffer); return nil;&#125; 建议和说明 建议使用ECB模式（kCCOptionECBMode），填充采用kCCOptionPKCS7Padding。这种使用最广泛，和PHP、JAVA（AES/ECB/PKCS5Padding）都适配。联调的时候需要注意两端是否一致，不一致是调不通的。 通常数据加密后，会做一次Base64编码进行传输，有些应用也会将数据转为二进制字符串传输。 如果不指定模式，则默认是CBC模式，需要用到向量IV。 如果不指定填充格式，则需要自行补0x00处理，在解码后也需要把补的0x00去除掉，网上很多资料解码后没有去除，会多出\0。 说明和总结 建议对称加密使用AES加密。DES无论安全性和效率都不如AES算法。 加密建议用kCCOptionPKCS7Padding填充方式，对应的JAVA模式为PKCS5Padding 如果用CBC模式，需要使用初始向量，初始向量两端应该一致。如果不使用应该指定kCCOptionECBMode。也建议用这个模式，兼容性最好。 秘钥应该用随机数生成对应的位数。AES128为16个字节，也就是16个字符。不要用短密码,比如：111111,这样真的很蠢。 对称加密的安全隐患主要在于秘钥的保存。重要会话的秘钥应该随机生成，使用非对称加密来沟通交换秘钥，策略可以参考我的另一篇文章IOS应用安全-HTTP/HTTPS网络安全(一)。 如果秘钥需要硬编码到程序里，应该做脱敏运算，比如做位运算进行变形等。后面会专门写怎么解决秘钥硬编码问题。 非对称加密算法非对称秘钥加密算法的特点是：加密和解密使用不同的秘钥。 非对称加密需要两个秘钥：公开秘钥和私有秘钥。两个秘钥是不同的，而且通过公钥是无法推算出私钥的，使用公钥加密的数据只有用私钥解密。 非对称算法的特点： 解决了秘钥保存的问题。公钥可以发布出去，任何人都可以使用，也不用担心被人获取到，只要保证私钥的安全就可以了。而对称加密，因为秘钥相同，客户端泄露了就不安全了。 加密和解密的效率不高，只适合加解密少量的数据。而对称加密效率要高。这里有一篇文章对比AES和RSA算法的性能对比。 RSA算法RSA是目前最常用的非对称加密算法。 算法原理可以看下这篇文章：RSA算法原理。 RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。RSA的秘钥长度在2048位，现有的技术手段是无法破解的（实际的可以暴力破解的位数为768位，也就是768位的大数才有可能暴力进行因数分解）。 RSA算法优点： 算法原理简单，我都快看懂了。 安全性也足够高，目前没有证据和方案可以破解1048位以上秘钥的RSA算法。 缺点： 安全性取决于秘钥长度，推荐的要至少1048位，但是这么高位数的秘钥生成速度很慢，所以没法做一次会话一次秘钥。 加解密的效率很低，相对于对称加密，差好几个量级，而且也不支持加密长数据。 国密算法SM2中国特有的算法，国家强制要求金融机构使用国密算法。包括SM1/SM2/SM3/SM4。其中SM4为对称加密算法。SM3是哈希算法。SM2为非对称加密算法。但是国家只给算法原理，没有给出常用的算法实现，所以是件蛋疼的事情。 算法我也没看懂。因为项目中使用到了，所以做了一些研究。相关代码可以参考我的github,IOS SM2开源实现非常少，而且都有些问题，要么基于openSSL，代码特别大。要么基于libtommath库，但是有一些问题，SM2无法调通。所以两个结合重新整理的下代码。这个代码只保证SM2算法有效性，因为经过实际使用过，其他的项目未用到。 SM2的加密流程 抛出掉数学方法，下面是本人的一些理解： SM2需要依赖于一个曲线，一般使用国家推荐曲线。如果曲线不对，肯定是无法加解密的。曲线参数 #define SM2_P "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF" #define SM2_A "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC" #define SM2_B "28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93" #define SM2_N "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123" #define SM2_G_X "32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7" #define SM2_G_Y "BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0" SM2公钥分为两部分：Pub_x和Pub_y。每个都是32字节，总共是64字节。私钥长度现在还不清楚是多少，有资料说是要32位，但是文档里面未提到。字节数如果不对说明生成秘钥算法有问题。 输出数据分为3段：C1C2C3,其中C1是64个字节，C2和原始数据大小相同，即原文是6个字节，C2就是6个字节，C3是32个字节。所以总长度是64+32+原文长度（字节）。如果长度不对，要看下是否是人为添加了其他字段。 算法涉及到哈希算法，标准是使用SM3的hash算法，SM3的Hash算法生成的字节为32字节，这个联调的时候一定要保证一致。 加密步骤说明： 第一步计算随机数，如果这个不是随机的,是固定的，那后面的结果每次输出就是唯一的。 通过随机数rank和曲线的G_x、G_y、P、A五个参数，通过ECC算法C1=[k]G = (x1,y1)生成一个点（x1,y1）。拼接起来就是C1数据。C1数据应该是64个字节。有些算法里面会在前面填充0x04，变成65个字节 通过公钥的P_x和P_y,随机数rank,A,P，通过ECC算法[k]PukeyB = [k](XB,YB) = (x2,y2)计算出(x2,y2)，x2和y2的大小为分别为32字节 将上面的(x2,y2)拼接，然后做KDF（密码派生算法）计算，输出原文长度（klen）的t值。t= KDF(x2||y2, klen),KDF一般使用的是SM3的算法。结果t的大小和原文的大小一致。 然后将t和原文做异或运算，得到C2,C2的大小和原文一致。 然后将(x2,原文,x3)拼接，计算一次SM3的Hash算法,生成的数据放入C3中，C3的大小为32字节。 最后把C1C2C3拼接到一起，长度为64+原文长度+32字节。注意，老的标准为C1C3C2,有些实现的是这种模式。 注：这其中ECC算法是标准算法，大部分第三方实现的都没有问题。主要是KDF算法和Hash算法会有不同。这个联调的时候需要搞清楚。 SM2解密流程流程图如下： 解密步骤说明 先判断C1是否在曲线上。C1长度为64字节，取数据的前64字节就可以了。所以两端一定要用同样的曲线。 使用C1的数据,曲线参数（A,P）,私钥dA，使用ECC算法生成(x2,y2)，dA*C1 = dA*(x2,y2) = dA*[k]*(Xg,Yg) 使用(x2,y2)和C2的长度（总长度-64-32），使用KDF计算t。 使用c2异或t，达到M’ 计算(x2,M’,y2)的hash值U。 比较U和C3数据是否是一致的，如果一致就输出M’ KDF算法说明：文档里的描述 密钥派生函数的作用是从一个共享的秘密比特串中派生出密钥数据。在密钥协商过程中，密钥派生函数作用在密钥交换所获共享的秘密比特串上，从中产生所需的会话密钥或进一步加密所需的密钥数据。密钥派生函数需要调用密码杂凑函数。设密码杂凑函数为Hv( )，其输出是长度恰为v比特的杂凑值。密钥派生函数KDF(Z, klen)：输入：比特串Z，整数klen(表示要获得的密钥数据的比特长度，要求该值小于(232-1)v)。输出：长度为klen的密钥数据比特串K。a)初始化一个32比特构成的计数器ct=0x00000001；b)对i从1到⌈klen/v⌉执行：b.1)计算Hai=Hv(Z ∥ ct)；b.2) ct++；c)若klen/v是整数，令Ha!⌈klen/v⌉ = Ha⌈klen/v⌉，否则令Ha!⌈klen/v⌉为Ha⌈klen/v⌉最左边的(klen −(v × ⌊klen/v⌋))比特；d)令K = Ha1||Ha2|| · · · ||Ha⌈klen/v⌉−1||Ha!⌈klen/v⌉。 简化下说明： 先分组,分组的大小为klen/v,向上取整,其中klen是数据长度，v是HASH算法输出长度。SM3的输出长度为32字节。 然后每一组循环，把原始数据Z和计数器ct拼接，做SM3_Hash运算得到Hai。然后计数器ct+1。 最终生成的数据Ha1,Ha2…拼接起来，然后截断到klen长度也就是数据长度。 HASH算法说明官方使用的是SM3密码杂凑算法，输入为小于2的64次方bit，输出为256bit（32字节）。 总结： 国密算法的基础是使用曲线计算。曲线应该使用官方推荐的曲线，曲线不同加解密肯定失败。 国密算法生成的数据为C1C2C3,其中C1为固定的64字节，c2和原始数据一样长，C3为固定的32字节。有些要求数据前面加上’0x04’,旧的版本输出是C3C1C2，这两点要注意。 公钥分为P_x和P_y,都是32字节长度。私钥长度从资料上看没有限制，是一个随机数[1,N-2]。N为曲线参数。 加密过程中使用了SM3的散列算法(官方叫杂凑算法)，这个算法输出为32字节的数据。如果对端没有用这个算法，两端也无法加解密成功。 总结 字符编码是为了把可见字符和二进制之间做一层转化。其中UNICODE编码是国际编码标准。UTF-8是这种编码格式的实现方式。特点是ASCII码的字符占用一个字节，其他的比如中文字符占用两到三个字符。 Base64也是一种编码方式，主要用于把二进制数据转化为ASCII字符，方便传输。现在很多加密算法习惯在加密后把二进制数做一次Base64进行传输。相对于原文，长度会多出1/3。也有把二进制转为字符串的形式，不过长度是原文的2倍。 哈希散列算法，主要用于脱敏处理和信息签名防篡改，做哈希运算应该加盐处理。盐值应该是随机值，而且和用户相关，建议使用（随机数 + 用户名）。 对称加密两端秘钥相同，加密速度快，可以加密大数据，但是秘钥保存一直是个难题。 非对称加密分为公钥和私钥，公钥可以公开。加密速度慢，只能加密小数据，但是只需要妥善保存私钥就可以了。 通常一个信息加密传输流程为： 双方约定好使用的编码格式。通常常用的是UTF-8编码。 客户端随机生成对称秘钥作为会话秘钥。使用非对称加密传输给后端，后端保存这个对称秘钥用于之后的加解密过程。 用户使用对称加密（通常为RSA）加密整个数据，结果通常使用Base64做编码（通常还要做一次URLEncode操作）,整个相关数据按照规则使用Hash算法（通常为SHA256算法）做数据签名。最后做传输 如果是用户密码的话建议用HMac做Hash脱敏处理，然后单独使用非对称加密进一步加强安全性。 参考： 字符编码笔记：ASCII，Unicode和UTF-8 百度百科-ASCII 深入浅出大小端 Base64 编码 MD5+Salt安全浅析 哈希加密算法 MD5,SHA-1,SHA-2,SHA-256,SHA-512,SHA-3,RIPEMD-160 - aTool DES加密模式详解 DES加密算法原理 关于PKCS5Padding与PKCS7Padding的区别 各种加密算法比较 AES在线加解密 iOS - Safe iOS 加密安全 RSA算法原理 SM2国密算法官方说明]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>iOS</tag>
        <tag>加解密</tag>
        <tag>字符编码</tag>
        <tag>大小端</tag>
        <tag>国密算法</tag>
        <tag>HASH</tag>
        <tag>对称加密</tag>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS应用安全-HTTP/HTTPS网络安全(二)]]></title>
    <url>%2F2017%2F05%2F15%2Fhttps-safe-2%2F</url>
    <content type="text"><![CDATA[导读 本文主要讲解IOS中ATS相关的配置说明和使用AFNetworking框架来实现证书验证的方法。讲解了AFNetworking各个配置试用的场景和注意点。 ATSIOS9之后，苹果开启了App Transport Security（简称ATS）特性,即禁止HTTP请求，必须使用支持TLS1.2的HTTPS请求。但是也支持在Info.plist中做一些配置，来做缓冲。需要在info.plist中加入App Transport Security Settings字段。 plist里面的结构如下 123456789101112131415NSAppTransportSecurity : Dictionary &#123; NSAllowsArbitraryLoads : Boolean NSAllowsArbitraryLoadsForMedia : Boolean NSAllowsArbitraryLoadsInWebContent : Boolean NSAllowsLocalNetworking : Boolean NSExceptionDomains : Dictionary &#123; &lt;domain-name-string&gt; : Dictionary &#123; NSIncludesSubdomains : Boolean NSExceptionAllowsInsecureHTTPLoads : Boolean NSExceptionMinimumTLSVersion : String NSExceptionRequiresForwardSecrecy : Boolean // Default value is YES NSRequiresCertificateTransparency : Boolean &#125; &#125;&#125; ATS整体配置（NSAllowsArbitraryLoads） 配置ATS生效或不生效 在App Transport Security Settings字段下加入Allow Arbitrary Loads，或NSAllowsArbitraryLoads，配置为NO。PS：如果要禁用则为YES。但是如果配置为YES会导致审核失败，需要单独向APPStrore申诉说明。 配置web(H5)访问限制生效或不生效 在App Transport Security Settings字段下加入Allow Arbitrary Loads in Web Content或NSAllowsArbitraryLoadsInWebContent，默认配置生效为NO。如果要容许访问任意web网页内容，配置为YES。但是如果配置为YES会导致审核失败，需要单独向APPStrore申诉说明。 配置多媒体访问限制生效或不生效 在App Transport Security Settings字段下加入Allow Arbitrary Loads in Web Content，默认配置生效为NO。设置YES，容许访问通过AVFoundation框架访问媒体内容。 ATS根据域名配置（Exception Domains）在App Transport Security Settings字段下加入Exception Domains或NSExceptionDomains,系统优先响应NSExceptionDomains中的配置。比如之前设置NSAllowsArbitraryLoadsInMedia为 YES，然而NSExceptionDomain所代表的域名，如果没有特殊配置，依然默认不能访问不安全的媒体内容。 加入域名配置 在Exception Domains下，添加字典。其中key为域名的名称，比如baidu.com。 容许访问HTTP 在步骤1对应的域名字典下，加入字段NSExceptionAllowsInsecureHTTPLoads.默认为NO，如果设置YES，则容许访问HTTP 容许TLS支持非正向保密算法（Perfect Forward Secrecy） 在步骤1对应的域名字典下，加入字段NSExceptionRequiresForwardSecrecy.默认为YES。如果设置为NO，则支持非正向保密的加密算法。 正向保密算法（Forward Secrecy），指如果通信密钥泄露，使用FS算法，可以保证这个密钥泄露只会影响之后的加密数据，之前的加密数据无法解密。主要防止攻击者保存之前的数据，等到私钥泄露之后再解密数据。这个算法的基础是基于椭圆曲线向前保密的秘钥交换算法ECDHE（Elliptic Curve Diffie-Hellman Ephemeral）。这些算法有： 1234567891011TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHATLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHATLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 如果设置为NO，则非正向保密算法，有下面几种： 123456TLS_RSA_WITH_AES_256_GCM_SHA384TLS_RSA_WITH_AES_128_GCM_SHA256TLS_RSA_WITH_AES_256_CBC_SHA256TLS_RSA_WITH_AES_256_CBC_SHATLS_RSA_WITH_AES_128_CBC_SHA256TLS_RSA_WITH_AES_128_CBC_SHA 具体原理参考TLS/SSL 高级进阶。 容许支持低版本的TLS算法。 在步骤1对应的域名字典下，加入字段NSExceptionMinimumTLSVersion。值为对应的支持的最低版本。包含下面值 123TLSv1.0TLSv1.1TLSv1.2 包含域名下的所有子域名。 在步骤1对应的域名字典下，加入字段NSIncludesSubdomains。默认为NO。如果配置为YES则包含域名下的所有子域名。 开启Certificate Transparency 在步骤1对应的域名字典下，加入字段NSRequiresCertificateTransparency,这个默认为NO.如果设为YES，则开启Certificate Transparency。这个是IETF启动的一个开源项目，目的是进一步验证证书是否安全。个人觉得没什么用，没必要开启。 ATS各种字段含义说明主要的几个key： NSAllowsArbitraryLoads 默认NO。如果设置为YES，则不生效ATS规则。但是配置在NSExceptionDomains里面的规则，按照里面的规则生效。配置为YES，提交APP Strore需要说明 NSAllowsArbitraryLoadsForMedia 默认NO.如果设置为YES，那使用AVFoundation加载资源不生效ATS。 NSAllowsArbitraryLoadsInWebContent 默认NO.如果设置为YES.使用webview加载的页面资源不生效ATS。 NSExceptionDomains 用于单独配置其他域名ATS策略的键。值应该是字典类型。 下面是NSExceptionDomains相关的key NSIncludesSubdomains 默认NO。如果设置为YES，则生效此域名下的子域名 NSExceptionAllowsInsecureHTTPLoads 默认NO。如果设置为YES，则容许HTTP请求。设置YES，在审核时需要提供说明。 NSExceptionMinimumTLSVersion 默认TLSv1.2。可以设置为：TLSv1.0、TLSv1.1。在审核时需要提供说明 NSExceptionRequiresForwardSecrecy 默认YES。设置为NO标示不支持正向保密。 NSRequiresCertificateTransparency 默认NO。如果设置为YES，开启Certificate Transparency。 上面的是方便本人查找，详细设置case也可以参考[ATS 官方文档] (https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35)。目前过渡阶段最多出现的是第三方不兼容的问题+不支持NSExceptionRequiresForwardSecrecy+TLS版本不到1.2+h5访问的链接不支持ATS。按照要求配置就可以了，最重要的是推动第三方和自己后台使用HTTPS。自己的后台如果要求不高，可以用自制证书。 推荐的一个配置： 自己的域名使用最安全的方案，防止被苹果拒绝。第三方可以按照需求配置，但是审核时也建议进一步说明。 123456789101112NSAppTransportSecurity NSExceptionDomains &quot;domain-i-control.example.com&quot; // 后台的域名 NSExceptionAllowsInsecureHTTPLoads = NO //不容许HTTP NSExceptionRequiresForwardSecrecy = YES //支持正向加密 NSExceptionMinimumTLSVersion = &quot;TLSv1.2&quot; //使用1.2版本 NSIncludesSubdomains = YES //包含子域名 &quot;other-domain-i-control.example.com&quot; //部分不支持的第三方域名 NSExceptionAllowsInsecureHTTPLoads = NO //支持http NSExceptionRequiresForwardSecrecy = YES //不支持正向加密 NSExceptionMinimumTLSVersion = &quot;TLSv1.0&quot; //第三方支持的TLS版本 NSAllowsArbitraryLoads = NO 使用AFNetworking配置HTTPS安全AFNetworking是最常用的网络框架。所以以这个为基础说明一些配置信息。本人是使用2.6版本的。3.x版本和2.6相比安全验证的逻辑没有变化，可以参考。2.6之前的版本，建议所有配置项显示配置，不要用默认配置（因为有个版本有漏洞，默认不校验域名）。下面先讲解下配置参数，清楚之后再讲解代码实现。 AFSecurityPolicy说明AFNetworking使用AFSecurityPolicy类来管理安全策略。 主要的属性和方法： 12345@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode; //证书验证的策略@property (nonatomic, assign) BOOL allowInvalidCertificates; //是否容许无效的证书@property (nonatomic, assign) BOOL validatesDomainName; //是否验证证书的域名@property (nonatomic, strong, nullable) NSArray *pinnedCertificates; //app自己导入的证书文件，默认情况下主bundle里面的.cer文件都会导入到这个数组里。 validatesDomainName 说明是否容许证书包含的域名和实际访问的域名不匹配，默认为YES。采用的策略为： 如果validatesDomainName == YES，则开启域名验证。如果allowInvalidCertificates == NO，则不容许所用的证书里面的域名和实际域名不一致。如果allowInvalidCertificates == YES，则忽略域名验证，直接按照AFSSLPinningMode方式验证。 如果validatesDomainName == NO,则不对证书做域名验证。 allowInvalidCertificates 说明是否容许无效证书，默认为NO。采用的策略为： 如果allowInvalidCertificates == YES，则容许使用自制证书，或容许CA颁发的证书或系统信任的第三方证书（比如手动信任Charles证书）无效（包括域名无效和超过有效期） 如果allowInvalidCertificates == NO，那无法使用自制证书，且不容许CA颁发的证书或系统信任的第三方证书（比如手动信任Charles证书）超过有效期。如果配置了validatesDomainName == YES，则容许证书的域名不匹配，否则也不容许域名不匹配。 SSLPinningMode 说明证书文件实体验证策略，默认为AFSSLPinningModeNone。AFSSLPinningMode包括的值为： 123456typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, AFSSLPinningModePublicKey, AFSSLPinningModeCertificate &#125;; AFSSLPinningModeNone。AFNetworking默认配置模式。采用的策略为： 如果容许无效证书（allowInvalidCertificates == YES），则直接返回验证成功（YES） 如果不容许无效证书（allowInvalidCertificates == YES），则验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。 AFSSLPinningModePublicKey。验证证书公钥模式。采用的策略为： 如果容许无效证书（allowInvalidCertificates == YES），则比对服务端发来的证书链中的公钥和自己加入的所有证书的的公钥是否匹配，只要有一个证书匹配就返回成功。 如果不容许无效证书（allowInvalidCertificates == YES），则先验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。验证通过后，则比对服务端发来的证书链中的公钥和自己加入的所有证书的的公钥是否匹配，只要有一个证书匹配就返回成功。 AFSSLPinningModeCertificate。证书完全匹配模式。采用的策略为： 如果容许无效证书（allowInvalidCertificates == YES），则将自己导入的所有证书作为锚点，判断服务端是否有效。如果有效，判断服务端证书链中的证书中，是否有证书包含在导入的证书里（使用二进制比较，也就是必须完全一样）。 如果不容许无效证书（allowInvalidCertificates == YES），则先验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。验证通过后，则将自己导入的所有证书作为锚点，判断服务端证书是否有效。如果有效，判断服务端证书链中的证书中，是否有证书包含在导入的证书里（使用二进制比较，也就是必须完全一样）。 上面的比较绕，其实就是三个配置的组合。下面把这几种组合起来，看看验证了什么，使用于什么策略。其中AC表示allowInvalidCertificates，VD表示validatesDomainName。需要的可以去查这个表来决定方案。 table th:first-of-type {width: 10px;} th:nth-of-type(2) {width: 70px;} th:nth-of-type(3) {width: 20px;} th:nth-of-type(4) {width: 40px;} 场景 mode AC VD 验证策略 适用场景 不适用场景 1 None NO YES 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期3.验证证书域名是否匹配 1.AF默认的安全策略2.对于安全有基础的要求3.使用CA机构颁发的证书 1.使用自制证书的 2.不容许使用第三方抓包工具抓包的应用 2 None NO NO 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期 1.证书是正规CA颁发的。但是使用的域名不是证书中的域名 1.存在风险，会导致攻击方使用自己的合法的CA证书进行攻击 2.使用自制证书的 3.不容许使用第三方抓包工具抓包的应用 3 None YES YES /NO 不对证书做任何验证 请勿使用这儿配置。 1.对安全没有要求的 1.对安全有要求的 4 PublicKey NO YES 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期 3.验证证书域名是否匹配4.验证证书和埋入的证书的公钥是否一致 1.证书是正规CA颁发的。2.对安全有比较高的需求 3.需要本地APP中导入证书 4.禁止第三方工具抓包 5.证书过期后只要保证公钥一致，就可以保证请求有效 1.使用自制证书的2.害怕攻击者拿到私钥或公钥文件，伪造证书（概率极低，因为需要CA机构再签发） 3.证书过期需要更换，但是新旧证书公钥不同 5 PublicKey NO NO 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书 2.验证证书是否过期 3.验证证书和埋入的证书的公钥是否一致 1.证书是正规CA颁发的。 2.需要本地APP中导入证书 3.禁止第三方工具抓包 4.使用的域名和证书域名不一致 5.证书过期后只要保证公钥一致，就可以保证请求有效 1.使用自制证书的 2.害怕攻击者拿到私钥或公钥文件，伪造证书（概率极低，因为需要CA机构再签发） 3.证书过期需要更换，但是新旧证书公钥不同 6 PublicKey YES YES/NO 1.验证证书和埋入的证书公钥是否一致 1.使用自制证书 2.需要本地APP中导入证书 3.禁止第三方工具抓包 4.不需要关心证书的有效期 1.攻击者可以拿到私钥或公钥文件，伪造证书。相对于场景4和5，更容易攻击一些。 2.攻击者可以用不在有效期的证书对进行攻击 7 Certificate NO YES 1.验证证书域名是否匹配2.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书3.验证证书是否过期4.验证证书和埋入的证书是否完全一致 1.证书是正规CA颁发的。2.对安全有最高的需求3.需要本地APP中导入证书4.禁止第三方工具抓包 1.需要考虑证书更新的场景 2.证书如果失效，客户端网络请求将会失效 3.自制证书 8 Certificate NO NO 1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书2.验证证书是否过期3.验证证书和埋入的证书是否完全一致 1.证书是正规CA颁发的。2.对安全有最高的需求3.需要本地APP中导入证书4.禁止第三方工具抓包5.证书域名和实际域名不一致 1.需要考虑证书更新的场景2.证书如果失效，客户端网络请求将会失效3.自制证书4.攻击者拿到公私钥的前提下，可以利用不校验域名，攻击或重定向其他域名。 9 Certificate YES YES 1.验证证书的域名是否匹配？ 2.验证证书是否过期？ 3.验证证书和埋入的证书是否完全一致 1.使用自制证书2.需要本地APP中导入证书3.禁止中间人攻击 1.需要考虑证书更新的场景2.证书如果失效，客户端网络请求将会失效3.无法作废不安全的证书。在攻击者拿到公私钥的前提下,可以监听数据。 10 Certificate YES NO 1.验证证书是否过期？2.验证证书和埋入的证书是否完全一致 1.使用自制证书2.需要本地APP中导入证书3.禁止禁止中间人攻击 1.需要考虑证书更新的场景2.证书如果失效，客户端网络请求将会失效3.攻击者拿到公私钥的前提下，可以利用不校验域名，定位到其他域名。 相关问题下面是一些疑问： 如何选择合适的方案? 建议对安全没有特别要求的或在测试环境下方便抓包，采用默认规则就可以了，重要的数据单独做加密。即选场景1 要校验域名，即：validatesDomainName不要设置为NO。如果设为NO，不校验域名，也最好自己加一层验证方法。 如果是自制证书，allowInvalidCertificates设置为YES。如果是ca颁发的证书则建议设置为YES。 无论是使用AFSSLPinningModePublicKey还是AFSSLPinningModeCertificate都应该考虑证书失效需要更换的问题。 如果用AFSSLPinningModePublicKey方式，使用场景6只要保证后续更换的证书公钥不变化就可以了。个人觉得是安全和方便性最平衡的一种模式，只要私钥不泄露就可以了。这个要求公司的证书管理机构知道这点，不过如果出了意外，也可以延缓部署。 最安全的方案是7。也就是强校验，漏洞最少，安全防护最高。但是必须考虑证书失效更换的问题。 如何防止证书过期导致不过的问题？有以下方案： 可以用场景6，保证后续更换的证书公钥不变化就可以了 APP强制升级，全局通知，热更新等保护通道，建议不要使用强校验策略，使用强的加密手段保证安全，作为最后手段。 加入证书更新的通道，每次应用启动的时候访问，查看是否有证书更新，如果有就去下载证书。 证书更新有什么方案？ 建议启动检查是否有证书更新，可以合并在检查APP更新或热更新里面。 发现有更新的时候，服务端把证书二进制数据转为16进制字符串下发给客户端。服务端对数据使用私钥签名，客户端使用公钥对数据进行验签。 客户端将下载的文件按照签名等规则保存。下次加载前，继续对文件验证签名，保证没有篡改。 对于场景9，容许无效的证书，使用AFSSLPinningModeCertificate模式，为什么说明里面还说会验证证书过期？ 我个人也不确定，但是这个模式在加入证书锚点后，代码里还是会调用AFServerTrustIsValid()方法，然后再匹配证书数据是否一致。这个AFServerTrustIsValid()最终调用的是系统验证的方法，不确定系统是否还是会验证有效期，还是只验证包含证书就可以了，目前没有手段验证，大概率认为系统还是会验证是否过期。所以相对来说验证AFSSLPinningModePublicKey需要考虑更新的情况更少。 如果使用AFSSLPinningModePublicKey模式，更换证书怎么保证公钥不变？ 参考上一篇文章的附录，有一步是使用私钥.key文件生成.csr。只要.key和.csr，下次签发的时候直接用这两文件，签发就可以了。这样能保证下次的证书公钥也不变化。建议生产私钥的时候使用位数在2048位以上，可以保证安全性。 代码具体实现导出证书建议向自己公司的网络管理员导出对应的crt文件。或者使用命令： openssl s_client -connect www.google.com:443 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer //获取www.google.com:443的ssl证书，地址可以换成自己的 建议最好导出根证书的crt文件。因为根证书crt文件有效期长，很少更换。 如果是crt格式，使用时需要转化为cer格式。两种转化方式都可以： 命令行 openssl x509 -in 你的证书.crt -out 你的证书.cer -outform der 通过电脑导出。 双击crt，安装到钥匙链中。 钥匙链中选中需要导出的证书，鼠标右键，菜单中选择&gt;&gt;导出，点击存储即可。 然后将.cer文件导入到工程中。注意选Copy items if needed . 设置生效规则代码实现其实非常简单，重要的是规则的设置，建议认真搞清楚上面讲的配置说明，然后再配置。 12345678910111213141516171819202122232425262728293031//设置模式 AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; //设置是否验证域名，不建议设置为NO policy.validatesDomainName = YES; //设置是否容许无效的证书，自制证书选YES policy.allowInvalidCertificates = NO; //AF如果模式为AFSSLPinningModeCertificate或AFSSLPinningModePublicKey会默认导入mainBundle里的所有cer文件，如果没有特别需求，没必要实现下面加载cer的代码 //先导入证书路径 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@"myCer" ofType:@"cer"];//证书的路径 // 有多个加多个 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; policy.pinnedCertificates = @[certData]; AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; //生效policy manager.securityPolicy = policy; //调用 NSString *host = @"exmple"; NSDictionary *params = @&#123;&#125;; [manager GET:host parameters:params success:^(AFHTTPRequestOperation *_Nonnull operation, id _Nonnull responseObject) &#123; &#125; failure:^(AFHTTPRequestOperation *_Nonnull operation, NSError *_Nonnull error)&#123; _hasUpdating = NO; &#125;]; 具体配置请参考上面AFSecurityPolicy的介绍。通常测试环境下使用默认模式，其他环境使用校验模式。 验证策略源码解读AF 2.6版本，在系统框架需要进行证书验证的时候会调用AFURLCOnnectionOpeation.m中的evaluateServerTrust:forDomain方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain&#123; //自制证书且验证域名不能用AFSSLPinningModeNone模式 if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123; // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html // According to the docs, you should only trust your provided certs for evaluation. // Pinned certificates are added to the trust. Without pinned certificates, // there is nothing to evaluate against. // // From Apple Docs: // "Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors). // Instead, add your own (self-signed) CA certificate to the list of trusted anchors." NSLog(@"In order to validate a domain name for self signed certificates, you MUST use pinning."); return NO; &#125; NSMutableArray *policies = [NSMutableArray array]; if (self.validatesDomainName) &#123; //如果要验证域名需要把域名加入到规则里 [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; //设置验证规则，如果有域名验证就加入域名验证 SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); if (self.SSLPinningMode == AFSSLPinningModeNone) &#123; //AFSSLPinningModeNone下，如果容许无效证书或者证书通过验证就返回成功，否则返回失败 return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123; //其他模式，如果没有容许无效证书，就做证书验证，失效了就返回失败 return NO; &#125; //抽取服务端的所有证书链数据 NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust); switch (self.SSLPinningMode) &#123; //不会进入到这个case case AFSSLPinningModeNone: default: return NO; case AFSSLPinningModeCertificate: &#123; //将导入的证书加入到锚点里 NSMutableArray *pinnedCertificates = [NSMutableArray array]; for (NSData *certificateData in self.pinnedCertificates) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; &#125; // PS:查看相关文档发现，如果只调用了SecTrustSetAnchorCertificates而没有调用SecTrustSetAnchorCertificatesOnly(serverTrust,false)方法，会导致只信任SecTrustSetAnchorCertificatesOnly设置的锚点的证书，不信任系统默认内置的锚点证书 SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); //验证是否证书是否在加入的锚点证书列表里。猜测会验证证书的有效期，如果有域名验证，验证域名。 if (!AFServerTrustIsValid(serverTrust)) &#123; return NO; &#125; //查看证书链中的证书是否和埋入的证书完全一致。 NSUInteger trustedCertificateCount = 0; for (NSData *trustChainCertificate in serverCertificates) &#123; if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123; trustedCertificateCount++; &#125; &#125; return trustedCertificateCount &gt; 0; &#125; case AFSSLPinningModePublicKey: &#123; NSUInteger trustedPublicKeyCount = 0; //从证书链中抽取所有公钥列表 NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust); //验证证书链中的公钥是否在导入的证书里面的公钥链中 for (id trustChainPublicKey in publicKeys) &#123; for (id pinnedPublicKey in self.pinnedPublicKeys) &#123; if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123; trustedPublicKeyCount += 1; &#125; &#125; &#125; return trustedPublicKeyCount &gt; 0; &#125; &#125; return NO;&#125; 里面实际验证是否有效的方法为：AFServerTrustIsValid(SecTrustRef serverTrust)。实现： 12345678910111213static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123; BOOL isValid = NO; SecTrustResultType result; // 具体实现，因为看不到源码无法确认，应该是标准的证书链验证方式，验证证书有效性，验证证书链的对应的CA根证书是否在颁发机构里或者是否是用户手动同意或拒绝的证书。如果设置了SecTrustSetAnchorCertificates,则验证是否在SecTrustSetAnchorCertificates方法设置的锚点证书里（不包含系统的证书） __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); //kSecTrustResultUnspecified:证书通过验证，但用户没有设置这些证书是否被信任 //kSecTrustResultProceed:证书通过验证，用户有操作设置了证书被信任，例如在弹出的是否信任的alert框中选择always trust isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);_out: return isValid;&#125; WebView进行证书验证如果不配置，webview执行系统默认的策略。因为项目中没用到，暂时不敢评判，下面是相关博客供参考。 参考文献 iOS 10 适配 ATS（app支持https通过App Store审核） [ATS 官方文档] (https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35) RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密? iOS安全系列之二：HTTPS进阶]]></content>
      <categories>
        <category>iOS</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>HTTPS</tag>
        <tag>iOS</tag>
        <tag>ATS</tag>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS应用安全-HTTP/HTTPS网络安全(一)]]></title>
    <url>%2F2017%2F05%2F11%2Fhttps-safe-1%2F</url>
    <content type="text"><![CDATA[导读： 本文主要讲在HTTP和HTTPS实际开发中有用和有意思的地方，希望读者能够有所启发。 主要包括：HTTP和HTTPS的简单介绍。介绍HTTPS加密逻辑。介绍SSL证书和SSL证书校验的规则。 本文简化了相关的技术细节，主要关注于前端开发需要关注的点和可以借鉴的地方，希望能对开发能有所帮助。开发更关心的技术代码实现细节，会单独文章中说明。 HTTP简介具体细节可以参考后面的参考文献，只写我觉得有意思和实际中可以参考的地方。 HTTP协议构建于TCP之上。意味着http是可靠的数据传输。所以不用担心丢包和乱序的问题。 HTTP协议是基于请求和响应的协议。与之对比MQTT协议是基于订阅的协议。 比如我想要一个资源的种子，如果知道哪个老司机有，我直接问他，他有就给我，没有也告诉我没有。这种模式就是请求和响应，好处是一对一，可以准确完整的按照自己的需求拿到需要的数据，但是坏处是消息会滞后，我想知道老司机后面是不是有资源了，我就只能一遍遍重复的问，直到拿到想要的结果为止（循环延迟请求，之前专门写个looperRequest就是为了解决这种问题）。 另外一种方案，我发布消息到一个论坛，然后留下邮箱，求好人一生平安。然后很多好人有资源就发给我，这样也能拿到数据。这种模式就是订阅模式，好处是可以一对多，可以快速实时拿到数据。但是坏处是：需要长链接，且推送消息时不清楚客户端的状态，推送的东西不一定需要，比如这个种子可能我已经有了，再发给我就浪费大家的流量了。 总结下。利用请求应答的模式，可以快速的和服务端同步数据，保证当前请求数据的有效性，有时候我们也叫拉（pull）数据。订阅模块可以快速的更新需要保证实时性的数据，比如聊天数据，交易结果，账户异常，有时候我们也叫推送（push）数据。 这两种方案是和服务端常用的两种交互方案，有些交互可以考虑两者结合的方式解决。比如之前项目中解决聊天数据的实时有效性，就采用后端推送当前有新消息或其他状态信息，前端收到状态信息后，主动拉取消息到本地，既能保证能够快速更新消息或状态，又能通过本地的状态，按照需求拉取需要的消息。 推/拉这种设计思路也可以用于应用间的数据同步，应用于模块间数据通信来进行模块解耦等。现在的项目工程模块化设计方案也借鉴了这两种思想。 URL。URL定义了一个资源的地址。大部分格式如下 protocol :// hostname[:port] / abs_path / [;parameters][?query]#fragment 详细说明参考 其中query用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。例如：http://www.joes.com/inventory-check.cgi?item=12731&amp;color=blue。唯一需要注意的是，URL里面不容许有非ASCII字符（常见的就是汉字），也不容许有保留字符比如：!*&#39;\&quot;();:@&amp;=+$,/?%#[]%,所以通常拼接请求时（GET），需要对传进来的参数做一次URLEncode操作。 可以参考这个做私有协议跳转，比如push消息协议，模块跳转协议，外部跳转协议等。 http请求由三部分组成，分别是：请求行、消息报头、请求正文.详细的建议使用charles抓一个请求看下就知道了。 注：来源于http://www.cnblogs.com/ranyonsue/p/5984001.html. 重要的几个请求报头字段： Accept: 指定客户端接受的消息类型（通常没人使用,因为客户端大量使用json做数据解析） Host:请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 User-Agent:用于附加操作系统名称和浏览器版本，通常给H5使用的，UA很容易被修改，项目中有遇到修改UA导致H5页面识别不出来当前操作系统和版本的问题，遇到这种可以查下UA被谁篡改了。 Referer:用于标示请求来源，一般用于防盗链，这个实际中也遇到过。 http的响应一般由三个部分组成，分别是:状态行，消息报头，响应正文。 注：来源于http://www.cnblogs.com/ranyonsue/p/5984001.html. 重要的几个消息报头 Content-Type 正文媒体类型和编码格式，比如：Content-Type:text/html;charset=ISO-8859-1.Content-Type这个字段被AFNetworking框架用于决定用什么解析器，注意后端不要配置错了。charset被用于AFNetworking字符解码，也应该前后端配置正确。这个配置不正确是经常联调不过的原因。 具体实现参考AFURLResonseSerialization.m。 Content-Length 用于表示正文长度，下载长资源时，需要使用这个字段来计算进度，也可以用这个字段推算下载流量。 Content-Encoding 通常用于记录压缩方法，比如：gzip。 GET和POST的方法。HTTP有定义了几种常用的方法，不过通常前端只和这两个打交道。这两个区别： 通常认为get是获取消息，不改变数据，post是用来改变数据，不过实际中，并不是那么明确。 get参数是附在URL链接上的，参数拼接前需要做URLEncode，post是附在请求正文里的,格式为key=value，使用&amp;分割，所以对传入数据也要做URLEncode，拼接后和头部用回车换行隔开。 get的URL长度有一定限制，不过也取决于系统支持，具体长度需要实际调研，ie的限制为2083字节，post理论上不存在长度限制。 安全性，post相对安全，get相对不安全。不过post属于防君子不防小人的那种，实际没有什么安全可言。所以综合来说，如果没有技术洁癖，建议都用post处理。 上传图片等二进制资源。上传资源一般是post协议，但是通常post是用于传送文本的，如何传图片等资源呢？就需要multipart协议了。 mutipart和普通的post有两点不同：请求头，请求报文。其中关键字是boundary这个属性。 请求头： 必须包含content-Type，且值为：multipart/form-data;boundary=${bond},其中${bound}为具体分割符，在AFNetworking中，如果不指定是Boundary+${random}。 请求体:内容不再是用name=value的形式，而是使用上面的boundary进行分割的一段一段的结构体。具体示例： 12345678910111213141516171819202122232425262728293031 POST /btoa/work/common/uploadImage HTTP/1.1Host: www.example.comContent-Type: multipart/form-data; boundary=Boundary+49F77F66A65EEA58Cookie: BIGipServerPOOL_PACLOUD_STGR2016080900646=1274288556.52384.0000; FF_SESSION2_ID=Sf503bee3691b4a31a53c6e3c5ae1c1f00912e8Connection: keep-aliveAccept: */*User-Agent: FFProject/2.0.0 (iPhone; iOS 10.3.1; Scale/3.00)Accept-Language: zh-Hans-CN;q=1, th-TH;q=0.9Content-Length: 418864Accept-Encoding: gzip, deflate--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="ffAppID"10004--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="imageSeq"1--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="imageType"5--Boundary+49F77F66A65EEA58Content-Disposition: form-data; name="image"; filename="xxxx.jpg"Content-Type: image/jpeg***image hex data***--Boundary+49F77F66A65EEA58-- 看到上面的例子可以知道，有几个参数是必须的，name、filename、Content-Type、具体资源数据 ，对应的AF接口： 1234- (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType; HTTPS简介苹果ATS政策出来之前，后端极少使用HTTPS协议，而是使用HTTP协议+自定义的安全数据加密策略来保证安全性。这是因为虽然HTTPS更安全，但是也更加耗费性能。如今苹果强推HTTPS（有说法是苹果可能会全面禁止HTTP的使用），使得HTTPS大范围使用，并且使用HTTPS作为安全扫描项，被安全机构接纳。但是如果不正确的使用HTTPS，还是会带来安全风险。 SSL/TLS简介HTTPS的关键字就是SSL（TLS）。和HTTP唯一的不同就是加入了SSL（TLS）协议，这一层在TCP之上，负责保证安全连接和数据传输安全。 注：来自 深入解析HTTPS SSL实际上是一套加密通信机制。SSL和TLS两者的协议基本一致，区别简单可以理解是TLS是SSL的升级版本。但是使用SSL所有协议版本都不再安全。请勿使用SSL协议 具体可以参考SSL与TLS的区别以及介绍 ios加入了ATS限制，强制原来HTTP必须使用HTTPS传输，也强制要求服务器必须使用TLS v1.2版本以上。所以简化为： 要使用支持TLS1.2及以上协议的HTTPS传输数据 PS：后面如无特殊说明，不再区分TLS和SSL，统一称为SSL HTTPS原理建议看下浅析HTTPS中间人攻击与证书校验和阮一峰：图解SSL/TLS协议和SSL、TLS协议格式入门学习 - .Little Hann 下面是协议流程图： 注：来自http://blog.csdn.net/muzhengjun/article/details/53379593 简单描述： TCP握手 SSL握手，握手成功就开始传输，失败就断开链接 数据传输 下面也是只讲一些有意思的点和注意的地方。 HTTPS加密流程整个加密的流程，体现了一个非常安全的信息加密的方案。 简化的流程如下： 客户发送一个随机数给服务端：random-c（明文） 服务端发送自己SSL证书给客户端。发送服务端随机数：random-s（明文） 客户端验证SSL证书有效性，如果判定有效，生成一个随机数random-p,然后使用证书中的公钥进行非对称加密，发送给服务端。 （这一步是整个安全环节最重要也是最薄弱的环节） 服务端拿到加密后的秘钥，通过私钥解密，得到random-p ，将random-c、random-s、random-p三个随机数做因子，两端都按照一定算法生成会话对称秘钥secret_key。 客户端计算之前的握手消息（除了Change Cipher Spec外）的Hash值，利用secret_key做对称加密后发给服务端。 服务端拿到后，利用secret_key解密，然后利用同样的算法计算之前的握手消息的Hash值，如果能解密成功，且验证Hash值正确则说明客户端的加密算法和秘钥没问题。 服务端再计算之前的握手消息的Hash值，利用secret_key做对称加密后发给客户端，客户端如果能够解密出来，且与自己计算的Hash值相同，则最后链接正式建立成功。 注明：上面是以RSA为基础的秘钥加密流程，即需要客户端将随机数加密传输给后端。还有一种基于秘钥交换的形式，双方的对称秘钥是通过交换的参数本地的，不会通过信道传输，会更安全些。具体参考TLS/SSL 高级进阶 先简单说明几个概念，详细的会专门抽出来分享： 对称加密：双方使用的秘钥是相同的，使用同一个秘钥进行加解密。 非对称加密：加密使用公钥加密，解密使用私钥加密。或者私钥加密，使用公钥解密。但是公钥和私钥是不同的。公钥是公开的，可以被第三方拿到而不会引起任何安全问题，因为通过公钥是无法得到私钥的，因而没办法解密使用公钥加密的数据。 散列（hash）：散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。好的散列算法是一对一的，不同的原文生成的一定是不同的散列。 这其中使用的加密策略： 传输数据应该加密，整个加密过程使用了两种加密方案，一种对称加密，一种非对称加密。 传输数据使用了对称加密，而秘钥生成中使用了非对称加密。 使用了散列算法（hash）来做数据验证。 回答这里面常见的几个问题： 为什么又要用非对称加密，又要用对称加密，只使用一个不可以么？ 不能只是用对称加密，因为对称加密，两个使用的秘钥是一致的，有一端的秘钥泄露了，两端的通信就不再安全了，尤其是客户端的对称秘钥非常容易泄露，拿到秘钥后，整个系统就不安全了。 也不只用非对称加密，主要是因为性能，非对称加密相对于对称加密，计算时间要长非常多，对于性能要求很高的场景，会明显降低性能。RSA算法和AES算法性能测试 所以设计者结合了两种方案。两端通过非对称加密协商秘钥，攻击者因为拿不到私钥，是无法解开通信秘钥的。一旦协商成功，通过对称加密又解决了性能问题。 为什么使用三个随机数 还是为了进一步加强安全，客户端或者服务端生成的随机数可能是伪随机的，有可能被攻击者猜出，但是如果三个伪随机的数一起使用就大大加强了随机性，这样攻击者就很难破解了。 为什么最后要做hash验证 为了保证两端通信中的数据不会做篡改，由于HASH算法，可以保证唯一性，所以如果中间消息被人篡改，就可以断开链接。 如果对原理不感兴趣，那建议记住下面推荐的加密方案，完全可以解决大部分的加密需求： 使用随机数做对称加密秘钥，将对称加密秘钥使用公钥进行非对称加密传给后端。这样因为秘钥随机，所以即使客户端被破解，也拿不到任何对称秘钥。而公钥建议老客户过3456让她进行动态获取，避免私钥泄露带来的问题。 使用非对称加密秘钥，可以保证网络数据即使劫持，因为没有私钥，也解不出来对应的加密秘钥，所以加密的隐私数据也是安全的 两者结合，可以保证一定的性能要求。 对数据进行加签（加盐+hash算法），保证中间的数据不会篡改。 ps:用户的密码，因为保密性要求更高。建议的算法是做HMAC哈希做脱敏，然后使用非对称加密给后端。 常用的网络传输攻击手段先思考下，刚才的通信链路有三个参与者： 客户端 传输信道 服务端 如果新加入一个攻击者，他想要窃取用户的隐私数据，他该怎么做？常见的做法： 攻击客户端。对于IOS系统来说，非越狱手机，由于权限问题，几乎无法攻击（之前XcodeGhost真的是很nb的攻击思路）。对于越狱手机，通过HOOK API，然后重新打包应用，诱导用户下载。或者劫持系统的输入框等常用控件可以达到攻击目的。相关的以后整理输出。但是从移动APP来说，直接攻击APP带来的危害和利用性很低，通常只会泄露很少的用户信息。大多是利用来薅羊毛的。 攻击传输信道。攻击手段有中间人攻击，DNS劫持等。 攻击服务端。也非常难做到。一般是模板注入，撞库等。 这里面其实最容易的就是攻击传输信道。排除技术术语，手段有： 伪装成正常的客户端攻击服务端 伪装成正常的服务端，劫持客户端数据 监听修改信道数据 这几种怎么解决？ 问：如何处理伪装成正常的客户端攻击服务端 在认为客户端app本身是无法攻破的前提下： 请求中一定加入签名策略。攻击者不知道签名策略是无法仿造请求的，也防止劫持者修改。发现签名不对，服务端认为是假的客户端。 请求中一定加入请求防重放策略。服务端发现是之前的请求，重复发送过来的（可能只有签名不一致），应该忽略 加入风险控制策略。比如异地登陆，同一设备ip反复请求，一些金融类app也会加入公安部认证的风控系统，防止一些有金融犯罪前科的用户注册。后端使用风控策略，禁止用户登录，或者强制要求用户再次身份认证，比如手机验证码认证。 问：如何处理监听修改信道数据&gt; 请求关键数据做加密，加密方案建议使用上面提到的加密方案。这样即使被监听，拿到数据也无法处理 加入请求签名，防止数据篡改。 问：如何处理伪装成正常的服务端，劫持客户端数据 这一种方式是目前攻击最常见且有效的手段。使用http的时候，因为没有任何认证措施，通过ARP或者DNS劫持，非常容易将网址定向到其他攻击者的地址，攻击者可以做劫持和修改相关数据。所以HTTP现在已经被各大平台所抛弃。很多开发遇到的访问一个h5页面，被运营商强插入广告就是这么做的。解决办法就是正确的使用HTTPS HTTPS，很大一部分作用就是解决上述问题。也就是通过SSL握手，校验服务端证书，达到验证是否是伪装的服务端的目的。HTTPS握手阶段算法原理都是安全的，只有验证身份这一步有漏洞，即只要想办法让客户端认为证书是可信的，证书里面的公钥就是生成者的公钥，自然就有相对应的私钥，后面非对称加密生成的对称秘钥就可以被截取到，造成整个链路不安全。如何攻击这个策略，行业上主要称为中间人攻击。 SSL证书可以说验证SSL证书是整个HTTPS的关键，如果这一步出问题，后面的就没有任何安全可言。而对于我们前端开发来说，SSL证书也是最需要关注的地方。 这里讲两个问题。SSL证书是什么？为什么通过SSL证书可以防止攻击者伪装成服务端。 SSL证书是什么SSL证书是一个文件。里面的内容包括：用户的信息、用户的公钥、还有CA中心对该证书里面的信息的签名。一个证书的实例： 打开safari，打开百度，https://www.baidu.com,在地址栏点击锁按钮，然后选显示证书。 里面的内容只有几个需要关注的： 常用名称：baidu.com 。客户端或浏览器，根据常用名称和访问的域名做匹配，访问的域名和证书的域名不一致，就会拒绝访问，达到防止域名劫持的目的。这个信息可以被伪造。 公共密钥：SSL握手生成的第二段随机串是通过这个公钥来加密的。这个信息可以被伪造，但是伪造没有异议。（想知道为啥的可以看看证书生成的步骤。） 签名：是对整个证书内容做hash之后，使用颁发机构的私钥加密的值。这个信息可以被伪造，但是伪造没有异议。 签名者信息：颁发机构的信息，由于验证上一级的证书信息。这个信息可以被伪造。 证书有效期。这个信息可以被伪造。 可以看到在百度这个证书上面还有两个证书，这是因为百度这个证书是有GS这个机构的二级机构颁发的，而GS这个二级机构是由GS的CA根证书颁发的。 也就是证书有证书链的概念，即这个证书可能是上一层机构颁发的，从CA根证书开始-&gt;二级CA证书-&gt;三级CA证书-&gt;…。 注：来自SSL 之证书链 SSL证书如何验证的推荐这篇文章，是目前看到讲的最清楚。浅析HTTPS中间人攻击与证书校验 根据HTTPS协议，服务端会在握手的时候将证书传送给客户单，而且是将整个证书链发过来。 通常的验证传过来的证书是否有效的步骤为： 验证证书的常用名称是否是访问的域名，是否在有效期内。（域名校验+有效期校验） 计算这个证书内容的散列值得到MD5-a，然后用颁发机构的公钥解密这个证书的签名得到MD5-b，比较两个值是否相同，如果相同说明这个证书确实是上个颁发机构颁发的。 重复上面的操作，直到验证到CA根证书。CA证书是自签名的，也就是签名是用自己的私钥签名的。可是CA根证书签名是用自己的私钥做签名，怎么去验证这个证书是否正确呢？ 最终上面的问题简化为： 如何验证CA根证书有效性最终层层拨茧，HTTPS的安全性关键钥匙就在这一章了。 CA根证书有两种生成方式： 由可信的颁发机构颁发 本地自己生成 对于第一种，因为可信的颁发机构很少，这些机构的CA证书会默认保存在浏览器里或者手机操作系统里，由可信的机构颁发的证书的有效性会由颁发机构保证。不过这种证书需要向颁发机构申请，颁发机构会花时间去进行公司域名身份等信息验证，所以花费也不少。 对于第二种，本地生成的证书（后面会附录如何生成自签名证书），证书常用的信息都可以生成，可以认为证书信息内容都不可靠，尤其是证书中的域名。使用自制证书在浏览器会弹出警告不可信，用户可以手动添加到信任列表里，之后可信了才可以访问，12306之前让下载证书导入，就是这个原因。在应用APP里，如果使用默认配置，会拒绝，返回SSL验证失败。 在应用内信任自生成证书有两种办法： 第一种 安装描述文件到系统里。在安装charles过程中，其中一步就是打开一个网址，在弹出安装的时候，安装这个证书，也可以把这个证书下载到云盘里，然后打开。这个过程需要用户手动授权。这个起效后是全局的，任何应用都会影响。 第二种 把这个根证书，埋入APP里,然后设置为证书锚点（可以设置多个），然后在SSL握手需要验证证书的时候，系统会认为这个证书是有效的。这个方案也是很多自签名证书进行校验的方法。这个只会在本应用里起作用。 中间人攻击中间人攻击是最常见的攻击HTTPS手段。 建议看这篇文章：iOS安全系列之二：HTTPS进阶 看到上面的验证手段，其实关键就在于如何信任CA根证书上面。攻击者就是想尽一切办法让客户端安装他自己的CA证书到你的手机里。 如果手机没有越狱，一定会引诱你去安装这个证书，并且手动设为可信。一旦信任，在访问服务器的时候，攻击者通过代理劫持，通过这个信任的CA证书，生成对应的域名的证书。最终因为域名可信，有效期可信，证书可信整个HTTPS建立成功，攻击者拿到相关的数据。 使用charles抓包的整个过程，其实就是中间人攻击的过程。 附：下面是charles开启SSL代理后，访问新浪弹出的证书信息，可以看到charles生成了新浪域名的证书： 提示：对于用户来说，不要信任任何CA证书，不安装任何描述文件是最安全的方法。比如安装飙车软件，让你信任一个证书。比如链接外部wifi，提示你安装证书才可以链接。比如翻墙设置代理，提示你安装信任证书。描述文件在通用-&gt;描述文件与设备管理中找到。 校验证书的姿势校验证书有两种方案： 弱校验 对于服务端证书，校验下面的case。 校验证书的域名 校验证书的有效期 校验证书链和证书的有效性 保证这三者有效，已经可以解决大部分的攻击了。唯一的风险就是中间人攻击，被安装CA证书之后，一个被信任的CA根证书可以生成符合上面要求的任何域名的证书。存在着风险，但是攻击难度已经大大增加了。AFNetworking框架默认采用的就是这个策略。 强校验 将证书放入APP中作为证书锚点。在上面的基础上再验证证书。这样可以完全保证服务端的证书是真正需要的证书，从而真正解决中间人攻击。 下面主要讲下强校验面临的坑，各位开发一定要注意。 证书强校验的坑证书是有有效期的，尤其是非自制证书，通常都在三年以内（很多资料根本不谈这个问题）。一旦有效期过了，服务端就需要更换证书,但是由于APP存在发版的情况，老的APP由于所有链接失败，导致老APP任何请求都失效，然后无法通知用户更新，老用户也不知道因为什么访问失败。（这些都是血的教训啊） 有几个建议的地方： 尽量埋CA证书，因为CA证书的有效期要长，有足够的时间准备。 有些通道不要使用证书强校验，比如检查升级，一些热修复策略，尽量使用自有的安全逻辑保证安全。 如果是自制证书，建议有效期设置长一些。 上面的是尽量降低风险，该出问题的时候还是会出，有一些不完美的方案大家可以参考下： 方案1：动态更新证书。 在APP中放入RSA公钥，应用启动的时候，证书信息通过私钥加密，发送给前端保存，前端把这个新证书和埋入的证书一起做锚点，进行验证。这样可以保证老APP可以使用一段时间。缺点是这个下发的机制要尽量安全可靠，有可能被攻击者利用，而且后续的请求需要依赖这个请求，所以方案复杂一些。 方案2：只验证证书的公钥 只使用证书的公钥进行验证，因为更换证书，一般是通过.csr文件生成crt证书文件的（也就是证书文件），在.csr文件没变的情况下，生成的证书的公钥是一致的，也就即使服务端更换了证书，只要公钥不变，依然可以通过验证。所以验证公钥也是相对安全的。缺点是如果新的证书换了公钥还是出问题。我遇到的case就是需要更换私钥和证书算法，公钥也不一样了。 其他不太靠谱的方案： 方案3： 在弱校验的基础上，加上验证颁发机构。只要读到颁发机构是可信的，证书就认为是有效的。可以解决第三方抓包工具的抓包问题，因为第三方抓包工具，一般使用自己的颁发机构，和实际的颁发机构不一致。缺点是，证书是可以完全伪造的，包括颁发结构的名字，有效期等等都可以伪造。 方案4： 信任无效的证书。 信任无效的证书，但是做本地证书校验，在失效的一段时间内，后端先不部署新证书，在新版本里面提前埋入新证书，在几个版本后再上线新的证书。优点是简单，不怕哪天忘了更换证书导致出问题。缺点是信任失效的证书，如果真的有需求要强制更换证书，就没办法处理。 附录:如何生成自签名证书参考 深入解析HTTPS和利用OpenSSL创建自签名的SSL证书 和 自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名 生成私钥 openssl genrsa -out ca.key 4096 利用私钥创建根证书 openssl req -new -x509 -days 36500 -key ca.key -out ca.crt 弹出的对话框按照提示填写： 1234567 Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangdongLocality Name (eg, city) []:ShenzhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:BL.incOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:BLEmail Address []: 创建SSL证书私钥 openssl genrsa -out server.key 4096 使用刚才的私钥签名 openssl req -new -key server.key -out server.csr 弹出的对话框按照提示填写： 12345678910111213 Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangdongLocality Name (eg, city) []:ShenzhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:BL.incOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:*.sina.com.cnEmail Address []:Please enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:1111An optional company name []: 注意，这里的Common Name 应该和实际的域名匹配。而且生成的.csr这个文件最好长期保留，下次过期的时候，建议直接用这个文件做签名。如果是向CA颁发机构申请，提交的文件也是这个文件。 对上一步的csr使用CA进行签名生成证书 openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt 如果是向CA机构申请，提交这个文件就可以了。 如果有必要可以重复上面必要步骤，使用上一步的证书的.crt和.key继续签名下一级证书。 一些常用命令： 12345 openssl s_client -connect www.google.com:443 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer //获取www.google.com:443的ssl证书，地址可以换成自己的openssl rsa -noout -text -in server.key 查看私钥信息openssl req -noout -text -in server.csr 查看签名请求信息openssl x509 -noout -text -in ca.crt 查看证书信息 MAC下使用Charles抓包参考 深入解析HTTPS 和 iOS安全系列之二：HTTPS进阶 安装Charles CA根证书 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certification …，会弹出如下提示，链接代理，手机浏览器输入chls.pro/ssl，就可以安装根证书了。 设置SSL代理 点击Proxy-&gt;SSL Proxying Setting，勾选Enable SSL Proxying，然后点击Add输入要SSL代理的请求Host和Port，可以使用通配符来表示某一类请求。 或者在对应的请求上右键选择Enable SSL Proxying，就会把这一个请求加入到上面的SSL代理列表中（类似于点击Add的效果）。 做完上述步骤后重新请求就能得到解密后的信息了。ps:抓取PC端的HTTPS包也类似，在Help-&gt;SSL Proxying中下载证书，双击安装证书，并选择始终信任即可。 在iPhone端设置HTTP代理 在Mac上获取当前机器的IP地址： ifconfig en0: ch将iPhone连接到与电脑相同的WiFi，在iPhone设置中：无线局域网 -&gt; 已连接WiFi右边的Info详情图标 -&gt; HTTP代理 -&gt; 手动 -&gt; 设置HTTP代理： 设置完成之后，打开Safari随便访问一个网页，初次设置代理的话，Charles会弹出一个iPhone请求代理的确认框，点击Allow即可。然后在Charles上就可以看到iPhone上的HTTP请求了。为了避免Mac上的请求过多影响对被代理iPhone上HTTP请求的查看和调试，可以在Charles取消Mac的代理：Menu -&gt; Proxy -&gt; 取消勾选Mac OS X Proxy 即可。 参考文献 HTTP协议详解（真的很经典） MQTT_github 说说http协议中的编码和解码 HTTP协议之multipart/form-data请求分析 苹果文档翻译 iOS10 NSAppTransportSecurity iOS中的HTTPS, 你知道多少? 阮一峰：图解SSL/TLS协议 SSL与TLS的区别以及介绍 浅析HTTPS中间人攻击与证书校验 SSL、TLS协议格式入门学习 - .Little Hann iOS安全系列之二：HTTPS进阶 HTTPS 理论详解与实践 利用OpenSSL创建自签名的SSL证书 自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名 深入解析HTTPS TLS/SSL 高级进阶]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>HTTPS</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
</search>