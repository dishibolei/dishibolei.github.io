<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萝卜的空间</title>
  <subtitle>我的小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dishibolei.github.io/"/>
  <updated>2017-11-16T09:01:26.000Z</updated>
  <id>https://dishibolei.github.io/</id>
  
  <author>
    <name>bolei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fishhook源代码解析</title>
    <link href="https://dishibolei.github.io/2017/11/13/fishHooker/"/>
    <id>https://dishibolei.github.io/2017/11/13/fishHooker/</id>
    <published>2017-11-13T05:56:22.000Z</published>
    <updated>2017-11-16T09:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<blockquote>
<p>导读<br>在做网络性能监听的时候，需要对网络状态进行监听，OC的代码可以通过runtime机制做hook，但是其中涉及到C代码函数，如何进行hook？通过查资料，使用fishhook可以解决这个问题</p>
</blockquote>
</blockquote>
<a id="more"></a>
<h2 id="官方内容："><a href="#官方内容：" class="headerlink" title="官方内容："></a>官方内容：</h2><h1 id="fishhook"><a href="#fishhook" class="headerlink" title="fishhook"></a>fishhook</h1><p><strong>fishhook</strong> is a very simple library that enables dynamically rebinding symbols in Mach-O binaries running on iOS in the simulator and on device. This provides functionality that is similar to using <a href="http://opensource.apple.com/source/dyld/dyld-210.2.3/include/mach-o/dyld-interposing.h" title="&lt;mach-o/dyld-interposing.h&gt;" target="_blank" rel="external"><code>DYLD_INTERPOSE</code></a> on OS X. At Facebook, we’ve found it useful as a way to hook calls in libSystem for debugging/tracing purposes (for example, auditing for double-close issues with file descriptors).</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>Once you add <code>fishhook.h</code>/<code>fishhook.c</code> to your project, you can rebind symbols as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#import &lt;dlfcn.h&gt;</div><div class="line"></div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">#import &quot;AppDelegate.h&quot;</div><div class="line">#import &quot;fishhook.h&quot;</div><div class="line"> </div><div class="line">static int (*orig_close)(int);</div><div class="line">static int (*orig_open)(const char *, int, ...);</div><div class="line"> </div><div class="line">int my_close(int fd) &#123;</div><div class="line">  printf(&quot;Calling real close(%d)\n&quot;, fd);</div><div class="line">  return orig_close(fd);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int my_open(const char *path, int oflag, ...) &#123;</div><div class="line">  va_list ap = &#123;0&#125;;</div><div class="line">  mode_t mode = 0;</div><div class="line"> </div><div class="line">  if ((oflag &amp; O_CREAT) != 0) &#123;</div><div class="line">    // mode only applies to O_CREAT</div><div class="line">    va_start(ap, oflag);</div><div class="line">    mode = va_arg(ap, int);</div><div class="line">    va_end(ap);</div><div class="line">    printf(&quot;Calling real open(&apos;%s&apos;, %d, %d)\n&quot;, path, oflag, mode);</div><div class="line">    return orig_open(path, oflag, mode);</div><div class="line">  &#125; else &#123;</div><div class="line">    printf(&quot;Calling real open(&apos;%s&apos;, %d)\n&quot;, path, oflag);</div><div class="line">    return orig_open(path, oflag, mode);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main(int argc, char * argv[])</div><div class="line">&#123;</div><div class="line">  @autoreleasepool &#123;</div><div class="line">    rebind_symbols((struct rebinding[2])&#123;&#123;&quot;close&quot;, my_close, (void *)&amp;orig_close&#125;, &#123;&quot;open&quot;, my_open, (void *)&amp;orig_open&#125;&#125;, 2);</div><div class="line"> </div><div class="line">    // Open our own binary and print out first 4 bytes (which is the same</div><div class="line">    // for all Mach-O binaries on a given architecture)</div><div class="line">    int fd = open(argv[0], O_RDONLY);</div><div class="line">    uint32_t magic_number = 0;</div><div class="line">    read(fd, &amp;magic_number, 4);</div><div class="line">    printf(&quot;Mach-O Magic Number: %x \n&quot;, magic_number);</div><div class="line">    close(fd);</div><div class="line"> </div><div class="line">    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Calling real open(&apos;/var/mobile/Applications/161DA598-5B83-41F5-8A44-675491AF6A2C/Test.app/Test&apos;, 0)</div><div class="line">Mach-O Magic Number: feedface </div><div class="line">Calling real close(3)</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h2><p><code>dyld</code> binds lazy and non-lazy symbols by updating pointers in particular sections of the <code>__DATA</code> segment of a Mach-O binary. <strong>fishhook</strong> re-binds these symbols by determining the locations to update for each of the symbol names passed to <code>rebind_symbols</code> and then writing out the corresponding replacements.</p>
<p>For a given image, the <code>__DATA</code> segment may contain two sections that are relevant for dynamic symbol bindings: <code>__nl_symbol_ptr</code> and <code>__la_symbol_ptr</code>. <code>__nl_symbol_ptr</code> is an array of pointers to non-lazily bound data (these are bound at the time a library is loaded) and <code>__la_symbol_ptr</code> is an array of pointers to imported functions that is generally filled by a routine called <code>dyld_stub_binder</code> during the first call to that symbol (it’s also possible to tell <code>dyld</code> to bind these at launch). In order to find the name of the symbol that corresponds to a particular location in one of these sections, we have to jump through several layers of indirection. For the two relevant sections, the section headers (<code>struct section</code>s from <code>&lt;mach-o/loader.h&gt;</code>) provide an offset (in the <code>reserved1</code> field) into what is known as the indirect symbol table. The indirect symbol table, which is located in the <code>__LINKEDIT</code> segment of the binary, is just an array of indexes into the symbol table (also in <code>__LINKEDIT</code>) whose order is identical to that of the pointers in the non-lazy and lazy symbol sections. So, given <code>struct section nl_symbol_ptr</code>, the corresponding index in the symbol table of the first address in that section is <code>indirect_symbol_table[nl_symbol_ptr-&gt;reserved1]</code>. The symbol table itself is an array of <code>struct nlist</code>s (see <code>&lt;mach-o/nlist.h&gt;</code>), and each <code>nlist</code> contains an index into the string table in <code>__LINKEDIT</code> which where the actual symbol names are stored. So, for each pointer <code>__nl_symbol_ptr</code> and <code>__la_symbol_ptr</code>, we are able to find the corresponding symbol and then the corresponding string to compare against the requested symbol names, and if there is a match, we replace the pointer in the section with the replacement.</p>
<p>The process of looking up the name of a given entry in the lazy or non-lazy pointer tables looks like this:<br><img src="http://i.imgur.com/HVXqHCz.png" alt="Visual explanation"></p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h3><p>使用非常简单，可以用下面的方式hook <code>printf</code>的方法，来执行自定义的printf方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> (*orig_printf)(<span class="keyword">const</span> <span class="keyword">char</span> * __restrict, ...);</div><div class="line"><span class="keyword">int</span> my_printf(<span class="keyword">const</span> <span class="keyword">char</span> * __restrict result,...) &#123;</div><div class="line">    <span class="keyword">return</span> orig_printf(<span class="string">"%s+custom\n"</span>,result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)btAction:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    </div><div class="line">    printf(<span class="string">"测试1"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 调用绑定</span></div><div class="line">    rebind_symbols((<span class="keyword">struct</span> rebinding[<span class="number">1</span>])&#123;&#123;<span class="string">"printf"</span>, my_printf, (<span class="keyword">void</span> *)&amp;orig_printf&#125;&#125;, <span class="number">1</span>);</div><div class="line">    </div><div class="line">    printf(<span class="string">"测试2"</span>);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>绑定的函数定义为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> rebind_symbols(<span class="keyword">struct</span> rebinding rebindings[], size_t rebindings_nel)</div></pre></td></tr></table></figure></p>
<p>调用非常简单，其中传入的参数是一个结构体数组，其中结构体定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * A structure representing a particular intended rebinding from a symbol</div><div class="line"> * name to its replacement</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//需要hook的方法名称</span></div><div class="line">  <span class="keyword">void</span> *replacement; <span class="comment">//替换后的函数实现</span></div><div class="line">  <span class="keyword">void</span> **replaced; <span class="comment">//保存替换后函数实现</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="rebind-symbols方法详解"><a href="#rebind-symbols方法详解" class="headerlink" title="rebind_symbols方法详解"></a>rebind_symbols方法详解</h3><p>外部调用的方法，用于重新绑定实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel); <span class="comment">//预绑定方法，主要是实现相关的结构体和内存地址。</span></div><div class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// If this was the first call, register callback for image additions (which is also invoked for</span></div><div class="line">  <span class="comment">// existing images, otherwise, just run on existing images</span></div><div class="line">  <span class="comment">// 第一次调用的时候注册回调处理，否则直接加载当前的images内存处理</span></div><div class="line">  <span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</div><div class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">uint32_t</span> c = _dyld_image_count();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</div><div class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>prepend_rebindings</code>的作用是做一些初始化的工作，生成需要的数据结构,赋值给<code>_rebindings_head</code>，最终是一个链表结构。实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepend_rebindings</span><span class="params">(struct rebindings_entry **rebindings_head,</span></span></div><div class="line">                              struct rebinding rebindings[],</div><div class="line">                              <span class="keyword">size_t</span> nel) &#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">new_entry</span> = (<span class="title">struct</span> <span class="title">rebindings_entry</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">rebindings_entry</span>));</span></div><div class="line">  <span class="keyword">if</span> (!new_entry) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  new_entry-&gt;rebindings = (struct rebinding *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct rebinding) * nel);</div><div class="line">  <span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</div><div class="line">    <span class="built_in">free</span>(new_entry);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="built_in">memcpy</span>(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(struct rebinding) * nel);</div><div class="line">  new_entry-&gt;rebindings_nel = nel;</div><div class="line">  new_entry-&gt;next = *rebindings_head;</div><div class="line">  *rebindings_head = new_entry;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中最主要的是这个<code>rebindings_entry</code>数据结构,保留了后续需要绑定的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> &#123;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> *<span class="title">rebindings</span>;</span> <span class="comment">//需要绑定的数拒数组</span></div><div class="line">  <span class="keyword">size_t</span> rebindings_nel; <span class="comment">//绑定的数量</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">next</span>;</span> <span class="comment">//下一个节点</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>_dyld_register_func_for_add_image</code>是这段代码关键的函数，这个函数的作用是注册一个回调，调用这个函数后，首先系统会返回所有已经加载的镜像的数据，然后之后会回调新加入的镜像的数据。通过这个函数就能获取到镜像加载的数据情况。</p>
<p>接着调用<code>_rebind_symbols_for_image</code>方法来解析image数据。</p>
<h3 id="rebind-symbols-for-image-方法详解"><a href="#rebind-symbols-for-image-方法详解" class="headerlink" title="rebind_symbols_for_image 方法详解"></a>rebind_symbols_for_image 方法详解</h3><p>这段代码之前，先讲相关联的的一些知识，更详细的可以看我的另外一篇文章，<a href="https://dishibolei.github.io/2017/10/26/mach-o-parser/#more">mach-o parser</a>。</p>
<p>程序在解析完Mach64 Header后，开始加载命令（Segment commands），每个命令记录了相关数据的地址信息和命令类型，下面是几个用到的命令。</p>
<p><img src="/2017/11/13/fishHooker/fishhooker_1.jpg" alt=""></p>
<ol>
<li><p>LC_SEGMENT_64(_LINKEDIT) : 用于处理动态链接的段命令，在程序里，主要用这个段里的数据算出起始偏移地址：base_address = vmaddress - file_offset + slide（ps：动态偏移，是程序运行时动态计算出来的，保证地址空间随机）。比如下图的起始地址计算为：<code>base_address = 0x10000C000 - 0x00000C000 + 0（静态分析是0偏移） =  0x100000000</code></p>
<p> <img src="/2017/11/13/fishHooker/fishhooker_2.jpg" alt=""></p>
</li>
<li><p>LC_SYMTAB : 记录加载<code>symbol table</code>和<code>string table</code>的命令，<code>symbol table</code>记录了函数更详细的数据,程序中主要是利用这个表来从<code>string table</code>表中找到具体的方法名称。程序中用于定位<code>symbol table</code>和<code>string table</code>的起始地址。计算公式为：<code>symbol_addr = base_address + symbol_table_offset</code>、<code>string_addr = base_address + string_table_offset</code>。比如下图的起始地址计算为：<code>symbol_addr = 0x100000000 + 0x00000C4D8 = 0x10000C4D8</code>,<code>string_addr = 0x100000000 + 0x00000D02C = 0x10000D02C</code></p>
<p><img src="/2017/11/13/fishHooker/fishhooker_3.jpg" alt=""></p>
</li>
</ol>
<ol>
<li><p>LC_DYSYMTAB : 记录加载动态链接信息的命令。程序中主要是用来计算<code>Dynamic Symbol Table</code>的地址。利用<code>Dynamic Symbol Table</code>地址可以定位到对应方法在<code>symbol table</code>的地址，从而定位到方法名称。起始地址计算公式为：<code>dynamic_symbol_addr = base_address + indsym_table_offset</code>,比如下图的起始地址计算为：<code>dynamic_symbol_addr = 0x100000000 + 0000CF78 = 0x10000CF78</code></p>
<p> <img src="/2017/11/13/fishHooker/fishhooker_4.jpg" alt=""></p>
</li>
</ol>
<p>下面的程序主要是定位出<code>symbol table</code>、<code>string table</code>和<code>dynamic symbol table</code>的起始地址，最终交给<code>perform_rebinding_with_section</code>方法来真正做替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings,</span></span></div><div class="line">                                     <span class="keyword">const</span> struct mach_header *header,</div><div class="line">                                     <span class="keyword">intptr_t</span> slide) &#123;</div><div class="line">  <span class="comment">//rebindings是一个链表结构，保存了所有需要绑定的数据</span></div><div class="line">  </div><div class="line">  Dl_info info;</div><div class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">// 解析加载指令，找到需要的几个加载命令：SEG_LINKEDIT、LC_SYMTAB、LC_DYSYMTAB</span></div><div class="line">  <span class="keyword">segment_command_t</span> *cur_seg_cmd;</div><div class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></div><div class="line"></div><div class="line"><span class="comment">// header的数据结构为</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">/*</div><div class="line"> * The 64-bit mach header appears at the very beginning of object files for</div><div class="line"> * 64-bit architectures.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></div><div class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></div><div class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></div><div class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></div><div class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></div><div class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></div><div class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></div><div class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></div><div class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">**/</div><div class="line"></div><div class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</div><div class="line">  <span class="comment">// 头部之后是加载指令</span></div><div class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</div><div class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</div><div class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</div><div class="line">      <span class="comment">//解析__LINKEDIT的cmd命令</span></div><div class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</div><div class="line">        linkedit_segment = cur_seg_cmd;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</div><div class="line">      <span class="comment">//解析__SYMTAB的cmd命令</span></div><div class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</div><div class="line">      <span class="comment">//解析__DYSYMTAB的cmd命令</span></div><div class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 如果没找到就退出</span></div><div class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</div><div class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Find base symbol/string table addresses</span></div><div class="line">  <span class="comment">// 找到对应的基础地址，使用__LINKEDIT中的vmaddress - file_offset + slide（动态偏移），通过这个地址算出symbol/string table的地址。</span></div><div class="line">  <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</div><div class="line">  <span class="comment">//计算symbol table的地址 = linkedit_base + symbol_table_offset</span></div><div class="line">  <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</div><div class="line">  <span class="comment">//计算string table的地址 = linkedit_base + string_table_offset</span></div><div class="line">  <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</div><div class="line"></div><div class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></div><div class="line">  <span class="comment">//计算indirect symbols table地址 = linkedit_base + dysymtab-&gt;indSym_table_offset</span></div><div class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</div><div class="line"></div><div class="line">  <span class="comment">// 再次遍历加载命令,用于定位`__DATA`段中的`__la_symbol_ptr`或`__nl_symbol_ptr`节的加载命令</span></div><div class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</div><div class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</div><div class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</div><div class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</div><div class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</div><div class="line">        <span class="keyword">section_t</span> *sect =</div><div class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</div><div class="line">          <span class="comment">//如果是_la_symbol_ptr或者__nl_symbol_ptr就调用hook方法进行hook</span></div><div class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</div><div class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</div><div class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="perform-rebinding-with-section"><a href="#perform-rebinding-with-section" class="headerlink" title="perform_rebinding_with_section"></a>perform_rebinding_with_section</h3><p>这段代码是查找符号表的数据，如果名字和要代替的方法名称相同，就把实现用替换的方法做替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings,</span></span></div><div class="line">                                           <span class="keyword">section_t</span> *section,</div><div class="line">                                           <span class="keyword">intptr_t</span> slide,</div><div class="line">                                           <span class="keyword">nlist_t</span> *symtab,</div><div class="line">                                           <span class="keyword">char</span> *strtab,</div><div class="line">                                           <span class="keyword">uint32_t</span> *indirect_symtab) &#123;</div><div class="line">  <span class="comment">//通过节中保存的reserved1来定位在Dynamic Symbol Table的起始地址。Dynamic Symbol Table是一个数组结构，数组的元素保存了symbol table中的的index值                                                                              </span></div><div class="line">  <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</div><div class="line">  </div><div class="line">  <span class="comment">//算出对应的在DATA区的数据的地址（__DATA__got节对应的是__nl_symbol_ptr指针，__DATA__la_symbol_prt节对应的是_la_symbol_ptr），这个节对应的是一个数组列表，数组元素为具体的方法实现的函数指针，最终的目的就是把这个实现的函数指针替换成需要替换的函数指针</span></div><div class="line">  <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</div><div class="line">  </div><div class="line">  <span class="comment">//indirect_symbol_indices和indirect_symbol_bindings都是数组结构，而且一一对应，通过数组index就可以找到成对的对应关系,数组长度是节的长度/指针的长度</span></div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</div><div class="line">    <span class="comment">//从Dynamic Symbol Table表中取出对应在symbol table中的的index。</span></div><div class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</div><div class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</div><div class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通过index从symbol table取出nlist_t数据结构，在这个结构了保存了在string table中的偏移量</span></div><div class="line">    <span class="keyword">nlist_t</span> symtablist = symtab[symtab_index];</div><div class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtablist.n_un.n_strx;</div><div class="line">    <span class="comment">//通过偏移量可以找到对应的方法名称</span></div><div class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</div><div class="line">    <span class="keyword">if</span> (strnlen(symbol_name, <span class="number">2</span>) &lt; <span class="number">2</span>) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></div><div class="line">    <span class="keyword">while</span> (cur) &#123;</div><div class="line">      <span class="comment">//遍历传进来的替换结构体里是否有和现在数据方法名匹配</span></div><div class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</div><div class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</div><div class="line">              <span class="comment">//保存原始实现</span></div><div class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</div><div class="line">          &#125;</div><div class="line">          <span class="comment">//如果匹配到了，将indirect_symbol_bindings保存的函数指针替换成要绑定的函数指针</span></div><div class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</div><div class="line">          <span class="keyword">goto</span> symbol_loop;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      cur = cur-&gt;next;</div><div class="line">    &#125;</div><div class="line">  symbol_loop:;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分解下替换的步骤：</p>
<ol>
<li><p>找到加载<code>__nl_symbol_ptr</code>和<code>__la_symbol_prt</code>的节命令,其中<code>__nl_symbol_ptr</code>是程序启动就会加载的symbol，<code>__la_symbol_prt</code>代表懒加载。<br> 对应的数据结构为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct section_64 &#123; /* for 64-bit architectures */</div><div class="line">	char		sectname[16];	/* name of this section */</div><div class="line">	char		segname[16];	/* segment this section goes in */</div><div class="line">	uint64_t	addr;		/* memory address of this section */</div><div class="line">	uint64_t	size;		/* size in bytes of this section */</div><div class="line">	uint32_t	offset;		/* file offset of this section */</div><div class="line">	uint32_t	align;		/* section alignment (power of 2) */</div><div class="line">	uint32_t	reloff;		/* file offset of relocation entries */</div><div class="line">	uint32_t	nreloc;		/* number of relocation entries */</div><div class="line">	uint32_t	flags;		/* flags (section type and attributes)*/</div><div class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</div><div class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</div><div class="line">	uint32_t	reserved3;	/* reserved */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>__nl_symbol_ptr</code> 对应的节加载命令如下：</p>
<p><img src="/2017/11/13/fishHooker/fishhooker_5.jpg" alt=""></p>
<p><code>__la_symbol_prt</code>对应的节加载命令如下：</p>
<p><img src="/2017/11/13/fishHooker/fishhooker_5.jpg" alt=""></p>
</li>
<li><p>利用这个加载命令，可以定位到<code>__DATA</code>段中的地址，比如上图中<code>__la_symbol_prt</code>节，对应的起始地址为<code>100008018</code>，这个地址在<code>__DATA__la_symbol_ptr</code>。</p>
<p> <img src="/2017/11/13/fishHooker/fishhooker_7.jpg" alt=""></p>
<p> 每个数据记录了具体实现的函数地址，比如<code>__printf</code>函数,对应的实现地址为<code>100006BDC</code>，这个地址指向<code>__stub__helper</code>,也就是利用<code>__stub__helper</code>来调用<code>__printf</code>函数。把这个地址替换后就可以调用自己的函数了。对应的地址在程序中赋给<code>**indirect_symbol_bindings</code></p>
</li>
<li><p>通过section加载命令，定位这个节对应的在<code>Indirect Symbols</code>中的起始位置，计算公式为:<code>*indirect_symbol_indices = indirect_symtab + section-&gt;reserved1</code>,<br><img src="/2017/11/13/fishHooker/fishhooker_8.jpg" alt=""></p>
<p>上图中的起始index就是：24。在<code>Indirect Symbols</code>找到第24位（起始从0开始），</p>
<p><img src="/2017/11/13/fishHooker/fishhooker_9.jpg" alt=""></p>
<p>确定好起始位置后，<code>Indirect Symbols</code>表和前面确定的<code>__DATA</code>端中地址就是一一对应的。如下图，第一个是<code>NSStringFromClass</code>，上图第一个也是<code>NSStringFromClass</code>。</p>
<p><img src="/2017/11/13/fishHooker/fishhooker_10.jpg" alt=""></p>
</li>
<li><p>利用第三步中的<code>Indirect Symbols</code>表中的数据定位对应<code>Symbol table</code>中的index,比如下图中<code>printf</code>对应偏移地址<code>00000A6</code>,对应10进制为166。<br><img src="/2017/11/13/fishHooker/fishhooker_11.jpg" alt=""></p>
<p>上面计算的<code>Symbol table</code>起始地址为<code>10000C4D8</code>,这是一个数组，找到index为166的数据：</p>
<p><img src="/2017/11/13/fishHooker/fishhooker_12.jpg" alt=""></p>
</li>
<li><p>利用第五步得到的结果，取出在<code>String table</code>中的偏移值，上图中的<code>_printf</code>偏移值为<code>00002CC</code>，<code>String table</code>起始地址为<code>0x10000D02C</code>,则对应的地址为<code>10000D2F8</code>,这样就可以获得函数名，如果和传入的函数名相同，则将第二步获取的函数实现的地址和传入要改变的地址进行替换，并把原地址保存下来。</p>
<p> <img src="/2017/11/13/fishHooker/fishhooker_13.jpg" alt=""></p>
</li>
</ol>
<p>查找方法名参考官方的图：</p>
<p><img src="http://i.imgur.com/HVXqHCz.png" alt="Visual explanation"></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ol>
<li><a href="http://turingh.github.io/2016/03/22/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">fishhook源码分析</a></li>
<li><a href="http://www.jianshu.com/p/625a61dfe039" target="_blank" rel="external">动态修改 C 语言函数的实现</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;导读&lt;br&gt;在做网络性能监听的时候，需要对网络状态进行监听，OC的代码可以通过runtime机制做hook，但是其中涉及到C代码函数，如何进行hook？通过查资料，使用fishhook可以解决这个问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="优化" scheme="https://dishibolei.github.io/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="fishhook" scheme="https://dishibolei.github.io/tags/fishhook/"/>
    
      <category term="hook" scheme="https://dishibolei.github.io/tags/hook/"/>
    
      <category term="machO" scheme="https://dishibolei.github.io/tags/machO/"/>
    
  </entry>
  
  <entry>
    <title>ios优化-包大小分析-MACHO文件解析</title>
    <link href="https://dishibolei.github.io/2017/10/26/mach-o-parser/"/>
    <id>https://dishibolei.github.io/2017/10/26/mach-o-parser/</id>
    <published>2017-10-26T07:21:27.000Z</published>
    <updated>2017-11-16T08:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<blockquote>
<p>导读<br>在分析linkMap文件的时候，遇到一个有趣的问题：获取类名可以用<code>_objc_classname</code>, 获取方法名可以用<code>_objc_methname</code>。可是怎么将方法名称和对象名称对应起来，程序是如何对应这两部分数据的。带着这个疑问研究了下macho的文件结构。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<h2 id="MACHO文件说明"><a href="#MACHO文件说明" class="headerlink" title="MACHO文件说明"></a>MACHO文件说明</h2><p>macho文件是mac os或ios系统可执行文件的格式，系统通过加载这个格式来执行代码。</p>
<p>相关结构如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1892225-b1105e7d6dde4ae2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>注：来源于：（<a href="http://www.jianshu.com/p/f1a61b53398f）" target="_blank" rel="external">http://www.jianshu.com/p/f1a61b53398f）</a></p>
<p>具体每部分的含义可以参考这个定义：</p>
<p><a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h.auto.html" target="_blank" rel="external">mach-0 loader.h</a></p>
<p>这里简单讲几个我比较关注的：</p>
<p>注：下面都是以64位做演示说明，cpu结构为arm64。</p>
<h3 id="MachO-Header的结构"><a href="#MachO-Header的结构" class="headerlink" title="MachO Header的结构"></a>MachO Header的结构</h3><p><img src="/2017/10/26/mach-o-parser/macho_15090044915523.jpg" alt=""></p>
<p>数据结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * The 64-bit mach header appears at the very beginning of object files for</div><div class="line"> * 64-bit architectures.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></div><div class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></div><div class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></div><div class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></div><div class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></div><div class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></div><div class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></div><div class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></div><div class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>第一个四字节数叫做<code>magic number</code>,可以得到使用的是64位还是32位系统</li>
<li>第二个字节和第三个字节是CPU类型</li>
<li>第四个字节是文件类型。<code>MH_EXECUTE</code>表示可执行文件</li>
<li>第五个字节和第六个字节表示<code>load commands</code>的个数和长度</li>
<li>第7个字节是加载的flag信息。具体参考<code>loader.h</code>中的文件</li>
</ol>
<h2 id="MachO-load-command"><a href="#MachO-load-command" class="headerlink" title="MachO load command"></a>MachO load command</h2><p>程序检索完Header之后就开始加载和解析Load Commands了。</p>
<p>相关代码在<code>mach_loader.c</code>,通过递归调用加载命令。</p>
<p><img src="/2017/10/26/mach-o-parser/macho_15090828612344.jpg" alt=""><br><img src="/2017/10/26/mach-o-parser/macho_15090828785060.jpg" alt=""></p>
<p><code>load_comand</code>的数据结构为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line"> * The load commands directly follow the mach_header.  The total size of all</div><div class="line"> * of the commands is given by the sizeofcmds field in the mach_header.  All</div><div class="line"> * load commands must have as their first two fields cmd and cmdsize.  The cmd</div><div class="line"> * field is filled in with a constant for that command type.  Each command type</div><div class="line"> * has a structure specifically for it.  The cmdsize field is the size in bytes</div><div class="line"> * of the particular load command structure plus anything that follows it that</div><div class="line"> * is a part of the load command (i.e. section structures, strings, etc.).  To</div><div class="line"> * advance to the next load command the cmdsize can be added to the offset or</div><div class="line"> * pointer of the current load command.  The cmdsize for 32-bit architectures</div><div class="line"> * MUST be a multiple of 4 bytes and for 64-bit architectures MUST be a multiple</div><div class="line"> * of 8 bytes (these are forever the maximum alignment of any load commands).</div><div class="line"> * The padded bytes must be zero.  All tables in the object file must also</div><div class="line"> * follow these rules so the file can be memory mapped.  Otherwise the pointers</div><div class="line"> * to these tables will not work well or at all on some machines.  With all</div><div class="line"> * padding zeroed like objects will compare byte for byte.</div><div class="line"> */</div><div class="line">struct load_command &#123;</div><div class="line">	uint32_t cmd;		/* type of load command */</div><div class="line">	uint32_t cmdsize;	/* total size of command in bytes */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每一个command都需要包含</p>
<ol>
<li>cmd：加载类型</li>
<li>cmdsize:加载的大小</li>
</ol>
<p>相关的最主要的解析源码在<code>mach_loader.c</code>里的<code>parse_machfile</code>方法里.最主要的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">			/*</div><div class="line">			 * Act on struct load_command&apos;s for which kernel</div><div class="line">			 * intervention is required.</div><div class="line">			 */</div><div class="line">			switch(lcp-&gt;cmd) &#123;</div><div class="line">			case LC_SEGMENT:</div><div class="line">				if (pass != 2)</div><div class="line">					break;</div><div class="line"></div><div class="line">				if (abi64) &#123;</div><div class="line">					/*</div><div class="line">					 * Having an LC_SEGMENT command for the</div><div class="line">					 * wrong ABI is invalid &lt;rdar://problem/11021230&gt;</div><div class="line">					 */</div><div class="line">					ret = LOAD_BADMACHO;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				ret = load_segment(lcp,</div><div class="line">				                   header-&gt;filetype,</div><div class="line">				                   control,</div><div class="line">				                   file_offset,</div><div class="line">				                   macho_size,</div><div class="line">				                   vp,</div><div class="line">				                   map,</div><div class="line">				                   slide,</div><div class="line">				                   result);</div><div class="line">				break;</div><div class="line">			case LC_SEGMENT_64:</div><div class="line">				if (pass != 2)</div><div class="line">					break;</div><div class="line"></div><div class="line">				if (!abi64) &#123;</div><div class="line">					/*</div><div class="line">					 * Having an LC_SEGMENT_64 command for the</div><div class="line">					 * wrong ABI is invalid &lt;rdar://problem/11021230&gt;</div><div class="line">					 */</div><div class="line">					ret = LOAD_BADMACHO;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				ret = load_segment(lcp,</div><div class="line">				                   header-&gt;filetype,</div><div class="line">				                   control,</div><div class="line">				                   file_offset,</div><div class="line">				                   macho_size,</div><div class="line">				                   vp,</div><div class="line">				                   map,</div><div class="line">				                   slide,</div><div class="line">				                   result);</div><div class="line">				break;</div><div class="line">			case LC_UNIXTHREAD:</div><div class="line">				if (pass != 1)</div><div class="line">					break;</div><div class="line">				ret = load_unixthread(</div><div class="line">						 (struct thread_command *) lcp,</div><div class="line">						 thread,</div><div class="line">						 slide,</div><div class="line">						 result);</div><div class="line">				break;</div><div class="line">			case LC_MAIN:</div><div class="line">				if (pass != 1)</div><div class="line">					break;</div><div class="line">				if (depth != 1)</div><div class="line">					break;</div><div class="line">				ret = load_main(</div><div class="line">						 (struct entry_point_command *) lcp,</div><div class="line">						 thread,</div><div class="line">						 slide,</div><div class="line">						 result);</div><div class="line">				break;</div><div class="line">			case LC_LOAD_DYLINKER:</div><div class="line">				if (pass != 3)</div><div class="line">					break;</div><div class="line">				if ((depth == 1) &amp;&amp; (dlp == 0)) &#123;</div><div class="line">					dlp = (struct dylinker_command *)lcp;</div><div class="line">					dlarchbits = (header-&gt;cputype &amp; CPU_ARCH_MASK);</div><div class="line">				&#125; else &#123;</div><div class="line">					ret = LOAD_FAILURE;</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			case LC_UUID:</div><div class="line">				if (pass == 1 &amp;&amp; depth == 1) &#123;</div><div class="line">					ret = load_uuid((struct uuid_command *) lcp,</div><div class="line">							(char *)addr + mach_header_sz + header-&gt;sizeofcmds,</div><div class="line">							result);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			case LC_CODE_SIGNATURE:</div><div class="line">				/* CODE SIGNING */</div><div class="line">				if (pass != 1)</div><div class="line">					break;</div><div class="line">				/* pager -&gt; uip -&gt;</div><div class="line">				   load signatures &amp; store in uip</div><div class="line">				   set VM object &quot;signed_pages&quot;</div><div class="line">				*/</div><div class="line">				ret = load_code_signature(</div><div class="line">					(struct linkedit_data_command *) lcp,</div><div class="line">					vp,</div><div class="line">					file_offset,</div><div class="line">					macho_size,</div><div class="line">					header-&gt;cputype,</div><div class="line">					result);</div><div class="line">				if (ret != LOAD_SUCCESS) &#123;</div><div class="line">					printf(&quot;proc %d: load code signature error %d &quot;</div><div class="line">					       &quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">					ret = LOAD_SUCCESS; /* ignore error */</div><div class="line">				&#125; else &#123;</div><div class="line">					got_code_signatures = TRUE;</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">#if CONFIG_CODE_DECRYPTION</div><div class="line">			case LC_ENCRYPTION_INFO:</div><div class="line">			case LC_ENCRYPTION_INFO_64:</div><div class="line">				if (pass != 3)</div><div class="line">					break;</div><div class="line">				ret = set_code_unprotect(</div><div class="line">					(struct encryption_info_command *) lcp,</div><div class="line">					addr, map, slide, vp,</div><div class="line">					header-&gt;cputype, header-&gt;cpusubtype);</div><div class="line">				if (ret != LOAD_SUCCESS) &#123;</div><div class="line">					printf(&quot;proc %d: set_code_unprotect() error %d &quot;</div><div class="line">					       &quot;for file \&quot;%s\&quot;\n&quot;,</div><div class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</div><div class="line">					/* </div><div class="line">					 * Don&apos;t let the app run if it&apos;s </div><div class="line">					 * encrypted but we failed to set up the</div><div class="line">					 * decrypter. If the keys are missing it will</div><div class="line">					 * return LOAD_DECRYPTFAIL.</div><div class="line">					 */</div><div class="line">					 if (ret == LOAD_DECRYPTFAIL) &#123;</div><div class="line">						/* failed to load due to missing FP keys */</div><div class="line">						proc_lock(p);</div><div class="line">						p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</div><div class="line">						proc_unlock(p);</div><div class="line">					&#125;</div><div class="line">					 psignal(p, SIGKILL);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">#endif</div><div class="line">			default:</div><div class="line">				/* Other commands are ignored by the kernel */</div><div class="line">				ret = LOAD_SUCCESS;</div><div class="line">				break;</div><div class="line">			&#125;</div></pre></td></tr></table></figure>
<p>其中几个比较重要的加载命令:</p>
<ol>
<li><code>LC_SEGMENT(LC_SEGMENT_64)</code>,用于加载段（segment）的命令，有下面段用下面加载:<code>__PAGEZERO</code>、<code>__TEXT</code>、<code>DATA</code>、<code>__LINKEDIT</code>。其中<code>__PAGEZERO</code>程序保留区,用于处理NULL异常，<code>__TEXT</code>保存程序代码和字符，<code>DATA</code>保存程序使用的二进制数据，<code>__LINKEDIT</code>保存动态库需要原始数据如符号、字符串、重定位条目等。也保留了起始地址信息，后续的<code>LC_SYMTAB</code>和<code>LC_DYSYMTAB</code>也是基于起始地址来算出相关偏移的值</li>
<li><code>LC_LOAD_DYLINKER</code>,用来读取动态加载库路径，通常在<code>usr/lib/dyld</code>，然后使用这个命令加载后面的动态库（最终还是递归调用<code>parse_machfile</code>）。</li>
<li><code>LC_MAIN</code>，用来读取程序入口</li>
<li><code>LC_CODE_SIGNATURE</code> 用来验证程序签名 </li>
<li><code>LC_DYSYMTAB</code>加载<code>Dynamic Symbol Table</code>,保存了<code>C Function</code>相关的链接信息，通过数据偏移，可以查询<code>LC_SYMTAB</code>保存的<code>C Function</code>相关的信息，比如方法名和实现等。<code>fishhook</code>,利用这个机制可以找到C对应的方法实现，并动态替换成要hook的函数，具体参考我的fishHooker源码解析。</li>
</ol>
<p>经过LoadCommand，程序正式被加载到内存中，最终运行起来。</p>
<h2 id="MACHO-Section"><a href="#MACHO-Section" class="headerlink" title="MACHO Section"></a>MACHO Section</h2><p>下面的主要是相关的节数据，主要有：</p>
<p>__TEXT段节名含义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1. __text: 代码节，存放机器编译后的代码</div><div class="line">2. __stubs: 用于辅助做动态链接代码（dyld）.</div><div class="line">3. __stub_helper:用于辅助做动态链接（dyld）.</div><div class="line">4. __objc_methname:objc的方法名称</div><div class="line">5. __cstring:代码运行中包含的字符串常量,比如代码中定义`#define kGeTuiPushAESKey        @&quot;DWE2#@e2!&quot;`,那DWE2#@e2!会存在这个区里。</div><div class="line">6. __objc_classname:objc类名</div><div class="line">7. __objc_methtype:objc方法类型</div><div class="line">8. __ustring:</div><div class="line">9. __gcc_except_tab:</div><div class="line">10. __const:存储const修饰的常量</div><div class="line">11. __dof_RACSignal:</div><div class="line">12. __dof_RACCompou:</div><div class="line">13. __unwind_info:</div></pre></td></tr></table></figure>
<p>__DATA段节名含义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">1. __got:存储引用符号的实际地址，类似于动态符号表，存储了`__nl_symbol_ptr`相关函数指针。</div><div class="line">2. __la_symbol_ptr:lazy symbol pointers。懒加载的函数指针地址（C代码实现的函数对应实现的地址）。和__stubs和stub_helper配合使用。具体原理暂留。</div><div class="line">3. __mod_init_func:模块初始化的方法。</div><div class="line">4. __const:存储constant常量的数据。比如使用extern导出的const修饰的常量。</div><div class="line">5. __cfstring:使用Core Foundation字符串</div><div class="line">6. __objc_classlist:objc类列表,保存类信息，映射了__objc_data的地址</div><div class="line">7. __objc_nlclslist:Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行。</div><div class="line">8. __objc_catlist: categories</div><div class="line">9. __objc_nlcatlist:Objective-C 的categories的 +load函数列表。</div><div class="line">10. __objc_protolist:objc协议列表</div><div class="line">11. __objc_imageinfo:objc镜像信息</div><div class="line">12. __objc_const:objc常量。保存objc_classdata结构体数据。用于映射类相关数据的地址，比如类名，方法名等。</div><div class="line">13. __objc_selrefs:引用到的objc方法</div><div class="line">14. __objc_protorefs:引用到的objc协议</div><div class="line">15. __objc_classrefs:引用到的objc类</div><div class="line">16. __objc_superrefs:objc超类引用</div><div class="line">17. __objc_ivar:objc ivar指针,存储属性。</div><div class="line">18. __objc_data:objc的数据。用于保存类需要的数据。最主要的内容是映射__objc_const地址，用于找到类的相关数据。</div><div class="line">19. __data:暂时没理解，从日志看存放了协议和一些固定了地址（已经初始化）的静态量。</div><div class="line">20. __bss:存储未初始化的静态量。比如：`static NSThread *_networkRequestThread = nil;`其中这里面的size表示应用运行占用的内存，不是实际的占用空间。所以计算大小的时候应该去掉这部分数据。</div><div class="line">21. __common:存储导出的全局的数据。类似于static，但是没有用static修饰。比如KSCrash里面`NSDictionary* g_registerOrders;`, g_registerOrders就存储在__common里面</div></pre></td></tr></table></figure>
<p>这部分数据会在上一步LoadCommand命令时，加载到内存里。</p>
<h2 id="解析-objc-classlist"><a href="#解析-objc-classlist" class="headerlink" title="解析__objc_classlist"></a>解析<code>__objc_classlist</code></h2><p>在看linkMap的时候，很奇怪的是，获取类名可以用<code>_objc_classname</code>, 获取方法名可以用<code>_objc_methname</code>，但是两个数据怎么匹配起来的，根据查相关资料，是通过<code>__objc_classlist</code>来映射的。</p>
<p>在解析的时候需要两个工具：<code>MachOView</code>和<code>Hopper</code>，</p>
<h3 id="加载可执行文件"><a href="#加载可执行文件" class="headerlink" title="加载可执行文件"></a>加载可执行文件</h3><p>选用真机编译,编译选项选择<code>Build Active Architecture Only</code>,这样只生成一个CPU类型的文件，方便后续分析，然后在工程的<code>DerivedData/**/Build/Products/**-iphonesos/**.app</code>中显示包内容，把和工程同名的文件copy到自己的目录下。</p>
<p>打开<code>`MachOview</code>,打开刚才的可执行文件。</p>
<p><img src="/2017/10/26/mach-o-parser/macho_15094215883115.jpg" alt=""></p>
<h2 id="解析-objc-class结构"><a href="#解析-objc-class结构" class="headerlink" title="解析__objc_class结构"></a>解析<code>__objc_class</code>结构</h2><p>直接看<code>__objc_classlist</code>节，</p>
<p><img src="/2017/10/26/mach-o-parser/macho_15094216820661.jpg" alt=""></p>
<p>然后看下<code>__objc_classlist</code>数据结构，这个是个内存地址占用64位,<br>经过分析，<code>__objc_classlist</code>,保存的地址，映射的是<code>__objc_data</code>的地址，在MachOView中，对应的数据为：</p>
<p><img src="/2017/10/26/mach-o-parser/macho_15094357689311.jpg" alt=""></p>
<p>使用Hopper打开可执行文件，按<code>G</code>，在搜索框里输入这个地址，比如输入<code>0000000100009278</code></p>
<p><img src="/2017/10/26/mach-o-parser/macho_15094355332393.jpg" alt=""></p>
<p>之后显示了一个数据结构。<br><img src="/2017/10/26/mach-o-parser/macho_15094355546664.jpg" alt=""></p>
<p>这个数据对应的数据结构为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class&#123;</div><div class="line">        <span class="keyword">struct</span> __objc_class* isa;</div><div class="line">        <span class="keyword">struct</span> __objc_class* wuperclass;</div><div class="line">        <span class="keyword">struct</span> __objc_cache* cache;</div><div class="line">        <span class="keyword">struct</span> __objc_vtable* vtable;</div><div class="line">        <span class="keyword">struct</span> __objc_ data* data;</div><div class="line">&#125;objc_class;</div></pre></td></tr></table></figure>
<ol>
<li><p>第一个是64位指针，保存isa指针，指向了<code>MetaClass</code>指针，对应的地址为<code>00000001000092A0</code>,在<code>Hopper</code>中搜索这个地址，得到的数据为:</p>
<p> <img src="/2017/10/26/mach-o-parser/macho_15094363177692.jpg" alt=""></p>
</li>
<li><p>第二个指向父类的指针，对应地址为<code>0000000000000000</code></p>
</li>
<li><p>第5个指向<code>data</code>,对应的地址为：<code>00000001000082C8</code>, 这个数据保存在<code>__objc_const</code>节,对应的数据结构为<code>__objc_data</code><br>,在<code>Hopper</code>中搜索这个地址，得到的数据为：</p>
<p><img src="/2017/10/26/mach-o-parser/macho_15094368762269.jpg" alt=""><br>对应的具体数据为：<br><img src="/2017/10/26/mach-o-parser/macho_15094373724379.jpg" alt=""></p>
</li>
</ol>
<p>``</p>
<h2 id="解析-objc-data"><a href="#解析-objc-data" class="headerlink" title="解析__objc_data"></a>解析<code>__objc_data</code></h2><p>对应的数据结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_data&#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t instanceStart;</div><div class="line">    uint32_t instanceSize;</div><div class="line">    uint32_t reserved;</div><div class="line">    void* ivarlayout;</div><div class="line">    char* name;</div><div class="line">    struct __objc_method_list* baseMethod;</div><div class="line">    struct __objc_protos* baseProtocol;</div><div class="line">    struct __objc_ivars* ivars;</div><div class="line">    struct __objc_ivars weakIvarLayout;</div><div class="line">    struct __objc_ivars baseProperties;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要的几个数据结构:</p>
<ol>
<li><p><code>name</code> 保存的类名称。这个地址为：<code>00000001000076B6</code>,对应的数据在<code>__objc_classname</code>段里,用<code>Hopper</code>查看这个地址，对应的名称为<code>ViewController</code></p>
<p><img src="/2017/10/26/mach-o-parser/macho_15095213058298.jpg" alt=""></p>
</li>
<li><p><code>baseMethod</code>,保存了类所有方法，这个地址为：<code>0000000100008278</code> , 对应数据在<code>__objc_const</code>,可以在这里找到对应的数据。<br><img src="/2017/10/26/mach-o-parser/macho_15095216127956.jpg" alt=""><br>对应数据结构为<code>__objc_method_list</code>,在<code>Hopper</code>,查看：<br><img src="/2017/10/26/mach-o-parser/macho_15095214498017.jpg" alt=""></p>
</li>
</ol>
<h2 id="解析-objc-method-list"><a href="#解析-objc-method-list" class="headerlink" title="解析__objc_method_list"></a>解析<code>__objc_method_list</code></h2><p>对应的数据结构为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_method_list&#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用到的数据主要是<code>count</code>，对应数据为<code>00000003</code>,对应10进制数为3，说明有3个方法。具体方法对应的数据结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">typedef struct objc_method&#123;</div><div class="line">    char* name;</div><div class="line">    char* signature;</div><div class="line">    void* implementation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个数据结构占用24(8*3)字节。<code>objc_method_list</code>结构体占用8字节，所以从<code>0000000100008278</code>开始，偏移8个字节，到<code>0000000100008280</code>就是第一个方法的起始位置，再偏移24个字节到<code>0000000100008298</code>,就是第二个方法起始地址位置，以此类推，最后一个方法占用地址为<code>00000001000082b0 ~ 00000001000082c7</code>。</p>
<p>先看第一个方法存储的数据为：</p>
<p><img src="/2017/10/26/mach-o-parser/macho_15095237983118.jpg" alt=""></p>
<p>然后分别解析这些地址:</p>
<ol>
<li><p><code>0000000100006924</code>,在<code>__objc_methname</code>段里，对应方法名称。<br> <img src="/2017/10/26/mach-o-parser/macho_15095240540172.jpg" alt=""></p>
</li>
<li><p><code>000000010000770F</code>,在<code>__objc_methtype</code>段里，对应方法签名，这里的值为<code>v16@0:8</code>,代表含义可以参考这里<a href="http://www.jianshu.com/p/f4129b5194c0" target="_blank" rel="external">关于type encodings的理解–runtime programming guide</a></p>
<p><img src="/2017/10/26/mach-o-parser/macho_15095244462172.jpg" alt=""></p>
</li>
</ol>
<ol>
<li><p><code>0000000100004A20</code>,在<code>__text</code>节里，对应的数据为：</p>
<p><img src="/2017/10/26/mach-o-parser/macho_15095247779616.jpg" alt=""></p>
</li>
</ol>
<p>最终类需要的数据完全解析完成。</p>
<p>ps：想要知道数据结构是什么，可以在<code>Hopper</code>的右侧导航栏下，点击<code>Manager type</code>查看。<br><img src="/2017/10/26/mach-o-parser/macho_15094426618641.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.blogfshare.com/ioss-mach-o-dump.html" target="_blank" rel="external">iOS安全–从Mach-o文件结构分析类名和方法名</a></li>
<li><a href="http://www.jianshu.com/p/f1a61b53398f" target="_blank" rel="external">从macho中解析类名</a></li>
<li><a href="http://colabug.com/267089.html" target="_blank" rel="external">深入理解Macho文件（二）- 消失的<strong>OBJC段与新生的</strong>DATA段</a></li>
<li><a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" target="_blank" rel="external">mach-o文件格式分析</a></li>
<li><a href="https://opensource.apple.com/source/xnu/xnu-4570.1.46/bsd/kern/" target="_blank" rel="external">Macho kern</a></li>
<li><a href="https://github.com/squarezw/squarezw.github.com/blob/b06665ab19ee22cc9a2413a80687949b0414ccd4/_posts/2016-04-11-app-launch-improvement-one.md" target="_blank" rel="external">main.m 方法之前的优化</a></li>
<li><a href="http://blog.csdn.net/fishmai/article/details/51419675" target="_blank" rel="external">OSX内核加载mach-o流程分析</a></li>
<li><a href="http://www.cocoachina.com/ios/20170716/19876.html" target="_blank" rel="external">iOS程序启动-&gt;dyld加载-&gt;runtime初始化(初识)</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;导读&lt;br&gt;在分析linkMap文件的时候，遇到一个有趣的问题：获取类名可以用&lt;code&gt;_objc_classname&lt;/code&gt;, 获取方法名可以用&lt;code&gt;_objc_methname&lt;/code&gt;。可是怎么将方法名称和对象名称对应起来，程序是如何对应这两部分数据的。带着这个疑问研究了下macho的文件结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="优化" scheme="https://dishibolei.github.io/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="machO" scheme="https://dishibolei.github.io/tags/machO/"/>
    
      <category term="iOS" scheme="https://dishibolei.github.io/tags/iOS/"/>
    
      <category term="包大小" scheme="https://dishibolei.github.io/tags/%E5%8C%85%E5%A4%A7%E5%B0%8F/"/>
    
  </entry>
  
  <entry>
    <title>iSee使用说明</title>
    <link href="https://dishibolei.github.io/2017/10/25/ios-isee/"/>
    <id>https://dishibolei.github.io/2017/10/25/ios-isee/</id>
    <published>2017-10-25T03:56:40.000Z</published>
    <updated>2017-10-25T07:27:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<blockquote>
<p>导读<br>为了方便对linkMap做解析，参考zyangSir的iSee工程，做了linkMap文件解析的工具，欢迎使用。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<h1 id="ios包大小分析工具iSee"><a href="#ios包大小分析工具iSee" class="headerlink" title="ios包大小分析工具iSee"></a>ios包大小分析工具iSee</h1><p><a href="https://github.com/dishibolei/iSee" target="_blank" rel="external">github地址</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>iSee是一款分析iOS可执行文件成分的工具，通过加载XCode在项目编译期间产生的linkMap文件，能够输出项目中每个类(包括第三方静态库)，在最终可执行文件中占用的长度信息。本工具根据zyangSir的代码做了部分修改。主要功能有：</p>
<ol>
<li>各个可执行文件占用大小</li>
<li>可执行文件中，各个段占用的大小（包括方法+常量字符串等）</li>
<li>未使用到的类</li>
<li>未使用到的方法</li>
</ol>
<p><img src="/2017/10/25/ios-isee/iSee_detail.png" alt="iSee_detai"></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>建议使用真机生成的文件测试，目前看对arm64架构支持最好。优先使用arm64相关文件检测。</p>
<h3 id="导出生成linkmap文件"><a href="#导出生成linkmap文件" class="headerlink" title="导出生成linkmap文件"></a>导出生成linkmap文件</h3><ol>
<li><p>在XCode编译选项中打开”WriteLinkMapFile”<br> <img src="/2017/10/25/ios-isee/./iSee_step1.png" alt="image"> </p>
</li>
<li><p>选择好真机/模拟器,Debug/Release。编译项目,进入项目的Derived Data目录<br> <img src="/2017/10/25/ios-isee/./iSee_step2.png" alt="image"> </p>
</li>
<li><p>依次进入Build/Intermediates/项目名.build/  目录, 找到相应模式下的编译产物文件夹<br><img src="/2017/10/25/ios-isee/./iSee_step3.png" alt="image"> </p>
</li>
<li><p>可以看到一个名为 项目名-LinkMap-normal-CPU架构.txt的文件，在iSee中点击linkMap文件按钮，导入这个文件 </p>
</li>
</ol>
<h3 id="导出生成的可执行文件"><a href="#导出生成的可执行文件" class="headerlink" title="导出生成的可执行文件"></a>导出生成的可执行文件</h3><ol>
<li><p>在上一步的Derived Data目录下,</p>
<p><img src="/2017/10/25/ios-isee/./iSee_step5.png" alt="image"> </p>
<p>看到.app结尾的文件，邮件显示包内容，找到和工程名称一样的一个可执行文件，把这个文件copy到相关目录<br><img src="/2017/10/25/ios-isee/./iSee_step5.png" alt="image"></p>
</li>
<li><p>在iSee中点击可执行文件，导入刚才的文件</p>
</li>
<li>之后程序会自动执行分析。</li>
</ol>
<h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><ol>
<li>现在对arm64支持比较好，所以建议用这个格式测试。</li>
<li>对于未使用方法和未使用类，使用otool工具来做辅助分析</li>
<li>未使用方法和未使用类，有误报可能，主要误报的是一些实现协议的类，这一部分是动态使用的，所以静态分析不出来。</li>
</ol>
<p>详细技术细节可以参考我的博客：<br><code>https://dishibolei.github.io/</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;导读&lt;br&gt;为了方便对linkMap做解析，参考zyangSir的iSee工程，做了linkMap文件解析的工具，欢迎使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="优化" scheme="https://dishibolei.github.io/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="iOS" scheme="https://dishibolei.github.io/tags/iOS/"/>
    
      <category term="包大小" scheme="https://dishibolei.github.io/tags/%E5%8C%85%E5%A4%A7%E5%B0%8F/"/>
    
      <category term="linkmap解析" scheme="https://dishibolei.github.io/tags/linkmap%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS优化-包大小分析-linkMap</title>
    <link href="https://dishibolei.github.io/2017/08/17/ios-linkmap/"/>
    <id>https://dishibolei.github.io/2017/08/17/ios-linkmap/</id>
    <published>2017-08-17T03:56:40.000Z</published>
    <updated>2017-10-24T08:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkMap解析"><a href="#LinkMap解析" class="headerlink" title="LinkMap解析"></a>LinkMap解析</h1><blockquote>
<blockquote>
<p>导读<br>IOS在做包大小优化的时候，需要分析包大小组成，然后通过包大小组成来有针对的做优化。其中最主要的工具就是linkmap文件的解析，下面文章讲简单说明如何解析linkmap文件。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<h2 id="如何生成linkMap文件"><a href="#如何生成linkMap文件" class="headerlink" title="如何生成linkMap文件"></a>如何生成linkMap文件</h2><ol>
<li><p>Xcode开启编译选项Write Link Map File</p>
<p> XCode -&gt; Project -&gt; Build Settings -&gt; 搜map -&gt; 把Write Link Map File选项设为yes，并指定好linkMap的存储位置</p>
<p><img src="/2017/08/17/ios-linkmap/get_link_map.png" alt="get_link_map"></p>
</li>
<li><p>编译后，到编译目录里找到该txt文件，文件路径就是上面设定的路径，我的位于：</p>
<p> <code>~/Library/Developer/Xcode/DerivedData/FFProject-gdxobffdqcwvyleustpwgfdxslqp/Build/Intermediates/FFProject.build/Debug-iphonesimulator/FFProject.build</code></p>
</li>
</ol>
<h2 id="linkMap文件结构解析"><a href="#linkMap文件结构解析" class="headerlink" title="linkMap文件结构解析"></a>linkMap文件结构解析</h2><h3 id="1-基础信息"><a href="#1-基础信息" class="headerlink" title="1. 基础信息"></a>1. 基础信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># Path: /Users/bolei/Library/Developer/Xcode/DerivedData/FFProject-gdxobffdqcwvyleustpwgfdxslqp/Build/Products/Debug-iphonesimulator/FFProject.app/FFProject //路径</div><div class="line"># Arch: x86_64 //架构</div></pre></td></tr></table></figure>
<h3 id="2-类表"><a href="#2-类表" class="headerlink" title="2.类表"></a>2.类表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Object files: //类文件</div><div class="line">[  0] linker synthesized</div><div class="line">[  1] dtrace</div><div class="line">[  2] /Users/bolei/Library/Developer/Xcode/DerivedData/FFProject-gdxobffdqcwvyleustpwgfdxslqp/Build/Intermediates/FFProject.build/Debug-iphonesimulator/FFProject.build/Objects-normal/x86_64/PAFFConfig.o</div></pre></td></tr></table></figure>
<p>这里保存了所有用到的类生成的.o文件，也包括用到的<code>dylib</code>库。前面[num]是序号，类是按照顺序保存的，后续可以通过序号查到具体对应的哪个类。</p>
<h3 id="3-段表"><a href="#3-段表" class="headerlink" title="3.段表"></a>3.段表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># Sections:</div><div class="line"># Address	Size    	Segment	Section</div><div class="line">0x100002460	0x00E382DF	__TEXT	__text</div><div class="line">0x100E3A740	0x000019D4	__TEXT	__stubs</div><div class="line">0x100E3C114	0x0000273E	__TEXT	__stub_helper</div><div class="line">0x100E3E860	0x0009D78B	__TEXT	__cstring</div><div class="line">0x100EDBFEB	0x00089F7A	__TEXT	__objc_methname</div><div class="line">0x100F65F65	0x0000CFCD	__TEXT	__objc_classname</div><div class="line">0x100F72F32	0x00012A27	__TEXT	__objc_methtype</div><div class="line">0x100F8595A	0x000122E8	__TEXT	__ustring</div><div class="line">0x100F97C44	0x00067DA8	__TEXT	__gcc_except_tab</div><div class="line">0x100FFF9F0	0x000259C8	__TEXT	__const</div><div class="line">0x1010253B8	0x0000017C	__TEXT	__entitlements</div><div class="line">0x101025534	0x0000037B	__TEXT	__dof_RACSignal</div><div class="line">0x1010258AF	0x000002E8	__TEXT	__dof_RACCompou</div><div class="line">0x101025B98	0x00016928	__TEXT	__unwind_info</div><div class="line">0x10103C4C0	0x00013B40	__TEXT	__eh_frame</div><div class="line">0x101050000	0x00000010	__DATA	__nl_symbol_ptr</div><div class="line">0x101050010	0x00000D30	__DATA	__got</div><div class="line">0x101050D40	0x00002270	__DATA	__la_symbol_ptr</div><div class="line">0x101052FB0	0x00000030	__DATA	__mod_init_func</div><div class="line">0x101052FE0	0x00036580	__DATA	__const</div><div class="line">0x101089560	0x0005EB20	__DATA	__cfstring</div><div class="line">0x1010E8080	0x000040A8	__DATA	__objc_classlist</div><div class="line">0x1010EC128	0x00000448	__DATA	__objc_nlclslist</div><div class="line">0x1010EC570	0x00000AA8	__DATA	__objc_catlist</div><div class="line">0x1010ED018	0x00000048	__DATA	__objc_nlcatlist</div><div class="line">0x1010ED060	0x00000780	__DATA	__objc_protolist</div><div class="line">0x1010ED7E0	0x00000008	__DATA	__objc_imageinfo</div><div class="line">0x1010ED7E8	0x001A2B80	__DATA	__objc_const</div><div class="line">0x101290368	0x00020CE8	__DATA	__objc_selrefs</div><div class="line">0x1012B1050	0x00000168	__DATA	__objc_protorefs</div><div class="line">0x1012B11B8	0x00003B80	__DATA	__objc_classrefs</div><div class="line">0x1012B4D38	0x00002620	__DATA	__objc_superrefs</div><div class="line">0x1012B7358	0x00010AF0	__DATA	__objc_ivar</div><div class="line">0x1012C7E48	0x000286E0	__DATA	__objc_data</div><div class="line">0x1012F0530	0x0000BB48	__DATA	__data</div><div class="line">0x1012FC080	0x00011A40	__DATA	__bss</div><div class="line">0x10130DAC0	0x00000538	__DATA	__common</div></pre></td></tr></table></figure>
<p>接下来是段表，描述了不同功能的数据保存的地址，通过这个地址就可以查到对应内存里存储的是什么数据。</p>
<p>其中第一列是起始地址，第二列是段占用的大小，第三个是段类型，第四列是段名称，<code>每一行初始地址 = 上一行的初始地址+占用大小</code></p>
<p>其中：</p>
<p>__TEXT 表示代码段,用于执行，可读不可以写，可以被执行</p>
<p>__DATA 表示数据段，用于存储数据，可以读写，不可以执行</p>
<p>其中：</p>
<p>第一个段是__PAGEZERO 地址从0到0x100000000，程序保留字段。</p>
<h4 id="3-1-段表内容含义"><a href="#3-1-段表内容含义" class="headerlink" title="3.1 段表内容含义"></a>3.1 段表内容含义</h4><p>__TEXT段节名含义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1. __text: 代码节，存放机器编译后的代码</div><div class="line">2. __stubs: 用于辅助做动态链接代码（dyld）.</div><div class="line">3. __stub_helper:用于辅助做动态链接（dyld）.</div><div class="line">4. __objc_methname:objc的方法名称</div><div class="line">5. __cstring:代码运行中包含的字符串常量,比如代码中定义`#define kGeTuiPushAESKey        @&quot;DWE2#@e2!&quot;`,那DWE2#@e2!会存在这个区里。</div><div class="line">6. __objc_classname:objc类名</div><div class="line">7. __objc_methtype:objc方法类型</div><div class="line">8. __ustring:</div><div class="line">9. __gcc_except_tab:</div><div class="line">10. __const:存储const修饰的常量</div><div class="line">11. __dof_RACSignal:</div><div class="line">12. __dof_RACCompou:</div><div class="line">13. __unwind_info:</div></pre></td></tr></table></figure>
<p>__DATA段节名含义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">1. __got:存储引用符号的实际地址，类似于动态符号表</div><div class="line">2. __la_symbol_ptr:lazy symbol pointers。懒加载的函数指针地址。和__stubs和stub_helper配合使用。具体原理暂留。</div><div class="line">3. __mod_init_func:模块初始化的方法。</div><div class="line">4. __const:存储constant常量的数据。比如使用extern导出的const修饰的常量。</div><div class="line">5. __cfstring:使用Core Foundation字符串</div><div class="line">6. __objc_classlist:objc类列表,保存类信息，映射了__objc_data的地址</div><div class="line">7. __objc_nlclslist:Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行。</div><div class="line">8. __objc_catlist: categories</div><div class="line">9. __objc_nlcatlist:Objective-C 的categories的 +load函数列表。</div><div class="line">10. __objc_protolist:objc协议列表</div><div class="line">11. __objc_imageinfo:objc镜像信息</div><div class="line">12. __objc_const:objc常量。保存objc_classdata结构体数据。用于映射类相关数据的地址，比如类名，方法名等。</div><div class="line">13. __objc_selrefs:引用到的objc方法</div><div class="line">14. __objc_protorefs:引用到的objc协议</div><div class="line">15. __objc_classrefs:引用到的objc类</div><div class="line">16. __objc_superrefs:objc超类引用</div><div class="line">17. __objc_ivar:objc ivar指针,存储属性。</div><div class="line">18. __objc_data:objc的数据。用于保存类需要的数据。最主要的内容是映射__objc_const地址，用于找到类的相关数据。</div><div class="line">19. __data:暂时没理解，从日志看存放了协议和一些固定了地址（已经初始化）的静态量。</div><div class="line">20. __bss:存储未初始化的静态量。比如：`static NSThread *_networkRequestThread = nil;`其中这里面的size表示应用运行占用的内存，不是实际的占用空间。所以计算大小的时候应该去掉这部分数据。</div><div class="line">21. __common:存储导出的全局的数据。类似于static，但是没有用static修饰。比如KSCrash里面`NSDictionary* g_registerOrders;`, g_registerOrders就存储在__common里面</div></pre></td></tr></table></figure>
<h3 id="3-2-后续符号表内容"><a href="#3-2-后续符号表内容" class="headerlink" title="3.2 后续符号表内容"></a>3.2 后续符号表内容</h3><h4 id="3-2-1-代码节"><a href="#3-2-1-代码节" class="headerlink" title="3.2.1 代码节"></a>3.2.1 代码节</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Symbols:</div><div class="line"># Address	Size    	File  Name</div><div class="line">0x100002460	0x00000080	[  2] +[PAFFConfig instance]</div><div class="line">0x1000024E0	0x00000050	[  2] ___22+[PAFFConfig instance]_block_invoke</div><div class="line">0x100002530	0x00000090	[  2] -[PAFFConfig init]</div><div class="line">apiType]</div></pre></td></tr></table></figure>
<p>这里面保存里类里面的方法内存情况。其中</p>
<ol>
<li>第一列是起始地址位置，通过这个地址我们可以查上面的段表，可以知道，对应的节为<code>__text</code>。</li>
<li>第二列是大小，通过这个可以算出方法占用的大小。</li>
<li>第三列是归属的类（.o文件），这里序号是2，通过查类表可以知道对应的类是PAFFConfig。</li>
</ol>
<p>通过这部分我们可以分析出来每个类对应的方法的大小是多少。</p>
<h4 id="3-2-3-方法名节-objc-methname"><a href="#3-2-3-方法名节-objc-methname" class="headerlink" title="3.2.3 方法名节(__objc_methname)"></a>3.2.3 方法名节(<code>__objc_methname</code>)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">0x100EDBFEB	0x00000006	[  2] literal string: alloc</div><div class="line">0x100EDBFF1	0x00000005	[  2] literal string: init</div><div class="line">0x100EDBFF6	0x0000000B	[  2] literal string: mainBundle</div><div class="line">0x100EDC001	0x0000000F	[  2] literal string: infoDictionary</div><div class="line">0x100EDC010	0x0000000E	[  2] literal string: objectForKey:</div><div class="line">0x100EDC01E	0x0000000C	[  2] literal string: setAppName:</div><div class="line">0x100EDC02A	0x0000000C	[  2] literal string: setVersion:</div><div class="line">0x100EDC036	0x0000000C	[  2] literal string: setApiType:</div><div class="line">0x100EDC042	0x00000009	[  2] literal string: instance</div><div class="line">0x100EDC04B	0x00000008	[  2] literal string: isDebug</div></pre></td></tr></table></figure>
<p>这部分保存了类里方法的字符串信息(所以原则上方法名起短一些，是可以减少占用的 - -!)</p>
<p>分析步骤：</p>
<ol>
<li>查看第一列起始地址，然后在上面的段表中查看这个地址在那个节里，可以看到在<code>__objc_methname</code>中。</li>
<li>通过第二列对比大小</li>
<li>通过第三列解析对应的类和对应方法名称</li>
</ol>
<h4 id="类列表节（-objc-classlist）"><a href="#类列表节（-objc-classlist）" class="headerlink" title="类列表节（__objc_classlist）"></a>类列表节（<code>__objc_classlist</code>）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0x1010E8080	0x00000008	[  2] anon</div><div class="line">0x1010E8088	0x00000008	[  3] anon</div><div class="line">0x1010E8090	0x00000008	[  4] anon</div><div class="line">0x1010E8098	0x00000008	[  5] anon</div><div class="line">0x1010E80A0	0x00000008	[  7] anon</div><div class="line">0x1010E80A8	0x00000008	[  9] anon</div><div class="line">0x1010E80B0	0x00000008	[ 10] anon</div><div class="line">0x1010E80B8	0x00000008	[ 11] anon</div><div class="line">0x1010E80C0	0x00000008	[ 12] anon</div><div class="line">0x1010E80C8	0x00000008	[ 13] anon</div><div class="line">0x1010E80D0	0x00000008	[ 14] anon</div><div class="line">0x1010E80D8	0x00000008	[ 15] anon</div><div class="line">0x1010E80E0	0x00000008	[ 16] anon</div><div class="line">0x1010E80E8	0x00000008	[ 17] anon</div><div class="line">0x1010E80F0	0x00000008	[ 18] anon</div><div class="line">0x1010E80F8	0x00000008	[ 19] anon</div><div class="line">0x1010E8100	0x00000038	[ 20] anon</div><div class="line">0x1010E8138	0x00000030	[ 21] anon</div></pre></td></tr></table></figure>
<p><code>__objc_classlist</code>存储了所有类的虚拟地址。即<code>__objc_data</code>地址。这里都是二进制数据，具体保存了什么，看下对应的数据结构</p>
<p><code>__objc_data</code>的数据结构为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> isa;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> wuperclass;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cache;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> vtable;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> data;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> reserved1;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> reserved2;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> reserved3;</div><div class="line">&#125;objc_class;</div></pre></td></tr></table></figure>
<p>其中最主要的是<code>data</code>字段，保存了<code>_objc_const</code>节对应的数据地址。数据结构为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_classdata&#123;</div><div class="line">    long long flags;</div><div class="line">    long long instanceStart;</div><div class="line">    long long instanceSize;</div><div class="line">    long long reserved;</div><div class="line">    unsigned long long ivarlayout;</div><div class="line">    unsigned long long name;</div><div class="line">    unsigned long long baseMethod;</div><div class="line">    unsigned long long baseProtocol;</div><div class="line">    unsigned long long ivars;</div><div class="line">    unsigned long long weakIvarLayout;</div><div class="line">    unsigned long long baseProperties;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面保存了类名，方法名，协议名，ivar指针和属性对应的地址。最后对应到相应的TEXT段里就能找到。比如类名在<code>__objc_classname</code>可以找到，方法名可以在<code>__objc_methname</code>。应用程序就是通过这个结构来寻找哪个类对应的那个方法，从而执行相关逻辑</p>
<h2 id="如何找到没有用到的类和方法？"><a href="#如何找到没有用到的类和方法？" class="headerlink" title="如何找到没有用到的类和方法？"></a>如何找到没有用到的类和方法？</h2><p>通过<code>__objc_classrefs</code>和<code>_objc_classname</code>对比就可以知道哪些类没用。其中<code>__objc_classrefs</code>的解析需要通过otool命令才能解析</p>
<p>同理：<br>通过<code>__objc_selrefs</code>和<code>_objc_methname</code>对比可以知道哪些方法没有使用到。其中<code>__objc_selrefs</code>需要用otool命令才能解析。</p>
<p><code>otool -v -s __DATA __objc_selrefs &lt;path&gt;</code></p>
<h2 id="otool使用"><a href="#otool使用" class="headerlink" title="otool使用"></a>otool使用</h2><p>这个用来做反汇编的，比如分析哪些类被使用了，需要用这个工具。</p>
<p>比如获取使用到的方法可以用这个命令：</p>
<p><code>otool -V -s __DATA __objc_selrefs &lt;path&gt; -arch arm64 | open -f</code></p>
<p>其中path是你的应用编译后生成的可执行文件。通常在项目的DerivedData目录下的Build/Products/<strong>/</strong>.app文件，然后显示包内容，有个和工程同名的可执行文件。比如我的目录：</p>
<p><code>/Users/bolei/Library/Developer/Xcode/DerivedData/FFProject-gqpkbetfhlofkxcmyfwpmkfqubun/Build/Products/Release-iphoneos/FFProject.app/FFProject</code></p>
<p>打印使用到的类： <code>_objc_classrefs</code></p>
<p><code>otool -V -o FFProject -arch arm64 | open -f</code></p>
<p>可以打印出来objc Section中的所有数据</p>
<p><a href="http://www.unix.com/man-page/osx/1/otool/" target="_blank" rel="external">otool说明</a></p>
<h2 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h2><p>相关代码欢迎fork：<a href="https://github.com/dishibolei/iSee.git" target="_blank" rel="external">https://github.com/dishibolei/iSee.git</a></p>
<p>主要功能包含了</p>
<ol>
<li>代码占用分析</li>
<li>未使用类分析</li>
<li>未使用方法分析</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.objc.io/issues/6-build-tools/mach-o-executables/" target="_blank" rel="external">IOS Section Document</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/Assembler/040-Assembler_Directives/asm_directives.html#//apple_ref/doc/uid/TP30000823-SW1" target="_blank" rel="external">IOS 官方Section介绍</a></li>
<li><a href="http://www.blogfshare.com/ioss-mach-o-dump.html" target="_blank" rel="external">mach-o文件结构分析类名方法名</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24917588" target="_blank" rel="external">load 方法全程跟踪</a></li>
<li><a href="http://blog.cnbang.net/tech/2296/" target="_blank" rel="external">iOS APP可执行文件的组成</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LinkMap解析&quot;&gt;&lt;a href=&quot;#LinkMap解析&quot; class=&quot;headerlink&quot; title=&quot;LinkMap解析&quot;&gt;&lt;/a&gt;LinkMap解析&lt;/h1&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;导读&lt;br&gt;IOS在做包大小优化的时候，需要分析包大小组成，然后通过包大小组成来有针对的做优化。其中最主要的工具就是linkmap文件的解析，下面文章讲简单说明如何解析linkmap文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="优化" scheme="https://dishibolei.github.io/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="iOS" scheme="https://dishibolei.github.io/tags/iOS/"/>
    
      <category term="包大小" scheme="https://dishibolei.github.io/tags/%E5%8C%85%E5%A4%A7%E5%B0%8F/"/>
    
      <category term="linkmap" scheme="https://dishibolei.github.io/tags/linkmap/"/>
    
  </entry>
  
  <entry>
    <title>iOS安全-切换后台背景模糊</title>
    <link href="https://dishibolei.github.io/2017/08/17/safe-backgroud-blurry/"/>
    <id>https://dishibolei.github.io/2017/08/17/safe-backgroud-blurry/</id>
    <published>2017-08-17T03:56:40.000Z</published>
    <updated>2017-08-17T09:54:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<blockquote>
<p>导读<br>我们在双击切换到后台的时候，背景会有缩略图，而缩略图会暴漏用户的部分敏感数据，所以要求切换到后台后，缩略图需要做毛玻璃模糊处理。一些银行类的应用会要求这么做。比如招商银行。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<p>切换到后台效果，可以看到时钟是没有模糊的。</p>
<p><img src="/2017/08/17/safe-backgroud-blurry/blurry_bg.jpeg" alt="blurry_bg"></p>
<p>实现思路也很简单在切换后台前，截取当前页面，然后做高斯模糊，然后加在window上。切到前台前，将这个加的页面移除出去。</p>
<p>关键代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  PAFFBlurryView.m</span></div><div class="line"><span class="comment">//  Pods</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by bolei on 16/10/9.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"BLBlurryView.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Accelerate/Accelerate.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#define kBlurryTag 10009</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BLBlurryView</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame blurryView:(<span class="built_in">UIView</span> *)view &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="built_in">UIImage</span> *sourceImage = [<span class="keyword">self</span> getCurrentImageWithView:view];</div><div class="line">        <span class="keyword">if</span> (sourceImage) &#123;</div><div class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:<span class="built_in">UIImageJPEGRepresentation</span>(sourceImage, <span class="number">1.0</span>)];</div><div class="line">            <span class="built_in">UIImage</span> *sImage =  [<span class="keyword">self</span> blurryImage:image withBlurLevel:<span class="number">0.1</span>];</div><div class="line">            <span class="built_in">UIImageView</span> *bgView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:frame];</div><div class="line">            bgView.image = sImage;</div><div class="line">            [<span class="keyword">self</span> addSubview:bgView];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)showBlurryViewInWindow &#123;</div><div class="line">    <span class="built_in">UIWindow</span> *window = [<span class="built_in">UIApplication</span> sharedApplication].delegate.window;</div><div class="line">    BLBlurryView *view = [[BLBlurryView alloc] initWithFrame:window.frame blurryView:<span class="literal">nil</span>];</div><div class="line">    view.tag = kBlurryTag;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIWindow</span> *window <span class="keyword">in</span> [[<span class="built_in">UIApplication</span> sharedApplication] windows]) &#123;</div><div class="line">        <span class="keyword">if</span> (window.windowLevel == <span class="built_in">UIWindowLevelNormal</span>) &#123;</div><div class="line">            <span class="built_in">UIView</span> *preView = [window viewWithTag:kBlurryTag];</div><div class="line">            <span class="keyword">if</span> (preView) &#123;</div><div class="line">                [preView removeFromSuperview];</div><div class="line">            &#125;</div><div class="line">            [window addSubview:view];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)removeBlurryViewInWindow &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIWindow</span> *window <span class="keyword">in</span> [[<span class="built_in">UIApplication</span> sharedApplication] windows]) &#123;</div><div class="line">        <span class="keyword">if</span> (window.windowLevel == <span class="built_in">UIWindowLevelNormal</span>) &#123;</div><div class="line">            <span class="built_in">UIView</span> *view = [window viewWithTag:kBlurryTag];</div><div class="line">            <span class="keyword">if</span> (view) &#123;</div><div class="line">                [view removeFromSuperview];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">UIImage</span> *)getCurrentImageWithView:(<span class="built_in">UIView</span> *)view</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIView</span> *sourceView = view;</div><div class="line">    <span class="keyword">if</span> (sourceView == <span class="literal">nil</span>) &#123;</div><div class="line">        sourceView = [<span class="keyword">self</span> getCurrentVisibleView];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (sourceView == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(sourceView.bounds.size);</div><div class="line">    [sourceView.layer renderInContext:<span class="built_in">UIGraphicsGetCurrentContext</span>()];</div><div class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UIImage</span> *)blurryImage:(<span class="built_in">UIImage</span> *)image withBlurLevel:(<span class="built_in">CGFloat</span>)blur &#123;</div><div class="line">    <span class="keyword">if</span> (blur &lt; <span class="number">0.</span>f || blur &gt; <span class="number">1.</span>f) &#123;</div><div class="line">        blur = <span class="number">0.5</span>f;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> boxSize = (<span class="keyword">int</span>)(blur * <span class="number">100</span>);</div><div class="line">    boxSize = boxSize - (boxSize % <span class="number">2</span>) + <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">CGImageRef</span> img = image.CGImage;</div><div class="line">    </div><div class="line">    vImage_Buffer inBuffer, outBuffer;</div><div class="line">    vImage_Error error;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> *pixelBuffer;</div><div class="line">    </div><div class="line">    <span class="built_in">CGDataProviderRef</span> inProvider = <span class="built_in">CGImageGetDataProvider</span>(img);</div><div class="line">    <span class="built_in">CFDataRef</span> inBitmapData = <span class="built_in">CGDataProviderCopyData</span>(inProvider);</div><div class="line">    </div><div class="line">    inBuffer.width = <span class="built_in">CGImageGetWidth</span>(img);</div><div class="line">    inBuffer.height = <span class="built_in">CGImageGetHeight</span>(img);</div><div class="line">    inBuffer.rowBytes = <span class="built_in">CGImageGetBytesPerRow</span>(img);</div><div class="line">    </div><div class="line">    inBuffer.data = (<span class="keyword">void</span>*)<span class="built_in">CFDataGetBytePtr</span>(inBitmapData);</div><div class="line">    </div><div class="line">    pixelBuffer = malloc(<span class="built_in">CGImageGetBytesPerRow</span>(img) *</div><div class="line">                         <span class="built_in">CGImageGetHeight</span>(img));</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(pixelBuffer == <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"No pixelbuffer"</span>);</div><div class="line">    </div><div class="line">    outBuffer.data = pixelBuffer;</div><div class="line">    outBuffer.width = <span class="built_in">CGImageGetWidth</span>(img);</div><div class="line">    outBuffer.height = <span class="built_in">CGImageGetHeight</span>(img);</div><div class="line">    outBuffer.rowBytes = <span class="built_in">CGImageGetBytesPerRow</span>(img);</div><div class="line">    </div><div class="line">    error = vImageBoxConvolve_ARGB8888(&amp;inBuffer,</div><div class="line">                                       &amp;outBuffer,</div><div class="line">                                       <span class="literal">NULL</span>,</div><div class="line">                                       <span class="number">0</span>,</div><div class="line">                                       <span class="number">0</span>,</div><div class="line">                                       boxSize,</div><div class="line">                                       boxSize,</div><div class="line">                                       <span class="literal">NULL</span>,</div><div class="line">                                       kvImageEdgeExtend);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error from convolution %ld"</span>, error);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(</div><div class="line">                                             outBuffer.data,</div><div class="line">                                             outBuffer.width,</div><div class="line">                                             outBuffer.height,</div><div class="line">                                             <span class="number">8</span>,</div><div class="line">                                             outBuffer.rowBytes,</div><div class="line">                                             colorSpace,</div><div class="line">                                             kCGImageAlphaNoneSkipLast);</div><div class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGBitmapContextCreateImage</span> (ctx);</div><div class="line">    <span class="built_in">UIImage</span> *returnImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</div><div class="line">    </div><div class="line">    <span class="comment">//clean up</span></div><div class="line">    <span class="built_in">CGContextRelease</span>(ctx);</div><div class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">    </div><div class="line">    free(pixelBuffer);</div><div class="line">    <span class="built_in">CFRelease</span>(inBitmapData);</div><div class="line">    </div><div class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">    <span class="built_in">CGImageRelease</span>(imageRef);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> returnImage;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">UIView</span> *)getCurrentVisibleView &#123;</div><div class="line">    <span class="built_in">UIWindow</span> *window = [[<span class="built_in">UIApplication</span> sharedApplication].delegate window];</div><div class="line">    <span class="built_in">UIViewController</span> *rootViewController = window.rootViewController;</div><div class="line">    <span class="keyword">if</span> ([rootViewController isKindOfClass:[<span class="built_in">UINavigationController</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">return</span> ((<span class="built_in">UINavigationController</span> *)rootViewController).visibleViewController.view;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rootViewController.view;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">// Only override drawRect: if you perform custom drawing.</div><div class="line">// An empty implementation adversely affects performance during animation.</div><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    // Drawing code</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>逻辑并不复杂，主要麻烦的点在于什么时候调用，切到后台涉及到四个周期：</p>
<ul>
<li>applicationWillResignActive 失去焦点的时候会首先调用</li>
<li>applicationDidEnterBackground 切换到后台后调用。在WillResignActive之后调用</li>
<li>applicationWillEnterForeground 将要回到前台的时候调用</li>
<li>applicationDidBecomeActive 已经到前台后调用</li>
</ul>
<p>其中点击home，切换到后台，四个状态都会调用。但是双击home的话只会调用applicationWillResignActive和applicationDidBecomeActive</p>
<p>一般调用显示和消失需要成对调用。所以两个方案：</p>
<ul>
<li>方案1：applicationWillResignActive调用消失，然后applicationWillEnterForeground调用显示</li>
<li>方案2：applicationDidEnterBackground调用消失，然后applicationDidBecomeActive调用显示</li>
</ul>
<p>方案1的问题是：在调用applicationWillResignActive，需要截屏需要做模糊效果，如果这个调用时间过长，就不会显示模糊的效果，对于复杂的页面经常会出现这个问题，需要找更好的算法去解决，目前没找到好的方案。而且进入到APP会有比较久的时间的模糊效果。</p>
<p>方案2的问题是：在双击home的时候，这个模糊效果不会生效。相对来说更推荐方案二。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;导读&lt;br&gt;我们在双击切换到后台的时候，背景会有缩略图，而缩略图会暴漏用户的部分敏感数据，所以要求切换到后台后，缩略图需要做毛玻璃模糊处理。一些银行类的应用会要求这么做。比如招商银行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="安全" scheme="https://dishibolei.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="iOS" scheme="https://dishibolei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>安全-秘钥硬编码解决</title>
    <link href="https://dishibolei.github.io/2017/06/26/safe-hard-code/"/>
    <id>https://dishibolei.github.io/2017/06/26/safe-hard-code/</id>
    <published>2017-06-26T03:31:36.000Z</published>
    <updated>2017-07-21T02:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<blockquote>
<p>导读<br>程序中经常用到需要用对称加密算法加解密，通常的做法是在代码中写死，硬编码到代码里。但是通过工具分析代码，是可以看到编码信息的，所以安全的做法是做一次变换，再硬编码进去。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<p>秘钥硬编码是常见的安全问题。攻击者拿到编译后的包后，经过分析是可以拿到所有使用到的字符串的（可以使用ida），很容易泄露对称秘钥，导致安全问题。(非对称算法的公钥是可以公开的)</p>
<p>最安全的解决方案是：对称秘钥按照会话随机生成。通过非对称的（比如RSA）算法，两边交换秘钥。</p>
<p>不过大部分场景还是需要把秘钥写在程序中的，对称秘钥如何存储一直是安全的大难题，<strong>目前没有什么方案可以保证安全存储对称秘钥的方案，相关的方案只是增加了破解难度而已</strong>。</p>
<p>相对安全的方案是：对秘钥进行变换。</p>
<p>使用的数学方法有：</p>
<ul>
<li>移位和循环移位<br>　　移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。</li>
<li>置换<br>　　就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。</li>
<li>扩展<br>　　就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。</li>
<li>压缩<br>　　就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。</li>
<li>异或<br>　　这是一种二进制布尔代数运算。异或的数学符号为⊕ ，它的运算法则如下：<br>1⊕1 = 0<br>0⊕0 = 0<br>1⊕0 = 1<br>0⊕1 = 1<br>　　也可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。</li>
<li>迭代<br>　　迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。</li>
</ul>
<p>通常是对秘钥进行变形，然后程序里面提供相关接口在运算过程中获取真实的秘钥。下面是几种常见的简单方案：</p>
<h2 id="方案1：使用RSA加密保存"><a href="#方案1：使用RSA加密保存" class="headerlink" title="方案1：使用RSA加密保存"></a>方案1：使用RSA加密保存</h2><p>方案很简单，使用RSA的私钥进行加密，RSA的公钥写死在客户端里，使用的时候使用RSA进行一次解密操作。</p>
<p>优点： 简单容易实现，一般项目里都需要使用非对称的加密方法，利用公开的秘钥做一次解密。<br>缺点： 如果知道了算法很容易破解。</p>
<h2 id="方案2：使用Base64进行编码，再保存"><a href="#方案2：使用Base64进行编码，再保存" class="headerlink" title="方案2：使用Base64进行编码，再保存"></a>方案2：使用Base64进行编码，再保存</h2><p>对秘钥进行Base64编码，然后再解码。</p>
<h2 id="方案3：使用AES再次加密"><a href="#方案3：使用AES再次加密" class="headerlink" title="方案3：使用AES再次加密"></a>方案3：使用AES再次加密</h2><p>再使用一次对称加密，两次不要使用相同的秘钥</p>
<h2 id="方案4：自定义方案"><a href="#方案4：自定义方案" class="headerlink" title="方案4：自定义方案"></a>方案4：自定义方案</h2><p>下面给一个方案，对数据进行变形。算法如下：</p>
<ol>
<li>对每一个字节做一次循环右移</li>
<li>对每一个字节用一个表的数据做位异或操作</li>
<li>转为16进制数</li>
</ol>
<p>相关代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Utils.m</span></div><div class="line"><span class="comment">//  Safe</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by bolei on 2017/7/18.</span></div><div class="line"><span class="comment">//  Copyright © 2017年 bolei. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"Utils.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"NSData+HexString.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">//使用自己的映射表</span></div><div class="line"><span class="keyword">char</span> changeMap[<span class="number">16</span>] = &#123;<span class="string">'w'</span>,<span class="string">'o'</span>,<span class="string">'s'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'b'</span>,<span class="string">'o'</span>,<span class="string">'l'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'s'</span>,<span class="string">'h'</span>,<span class="string">'a'</span>,<span class="string">'i'</span>,<span class="string">'g'</span>,<span class="string">'e'</span>&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Utils</span></span></div><div class="line"></div><div class="line">+ (<span class="built_in">NSString</span> *)hardKeyEncode:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">if</span> ([key length] == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">@""</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSData</span> *data = [key dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="built_in">NSUInteger</span> i, len;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *bytes;</div><div class="line">    </div><div class="line">    len = data.length;</div><div class="line">    bytes = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)data.bytes;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> index = i % <span class="number">16</span>;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> p = bytes[i];</div><div class="line">        p = (p &lt;&lt; <span class="number">7</span> || p &gt;&gt; <span class="number">1</span>); <span class="comment">//公式：循环左移n位： (x&gt;&gt;(N - n) ) | (x&lt;&lt;n)；循环右移n位： (x&lt;&lt;(N - n) ) | (x&gt;&gt;n)。</span></div><div class="line">        p ^= changeMap[index];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSData</span> *changeData = [<span class="built_in">NSData</span> dataWithBytes:bytes length:len];</div><div class="line">    <span class="built_in">NSString</span> *keyHex = [data hexStringFromData:changeData];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> keyHex;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (<span class="built_in">NSString</span> *)hardKeyDecode:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">if</span> ([key length] == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">@""</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataFromHexString:key];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([data length] == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">@""</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSUInteger</span> i, len;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *bytes;</div><div class="line">    </div><div class="line">    len = data.length;</div><div class="line">    bytes = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)data.bytes;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> index = i % <span class="number">16</span>;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> p = bytes[i];</div><div class="line">        p = (p &gt;&gt; <span class="number">7</span> || p &lt;&lt; <span class="number">1</span>); <span class="comment">//公式：循环左移n位： (x&gt;&gt;(N - n) ) | (x&lt;&lt;n)；循环右移n位： (x&lt;&lt;(N - n) ) | (x&gt;&gt;n)。</span></div><div class="line">        p ^= changeMap[index];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSData</span> *changeData = [<span class="built_in">NSData</span> dataWithBytes:bytes length:len];</div><div class="line">    <span class="built_in">NSString</span> *result = [<span class="built_in">NSString</span> stringWithUTF8String:changeData.bytes];</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://book.2cto.com/201506/52301.html" target="_blank" rel="external">IDA使用</a></li>
<li><a href="http://blog.csdn.net/jaccty/article/details/52471196" target="_blank" rel="external">IOS安全– 字符串加密那点小事</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;导读&lt;br&gt;程序中经常用到需要用对称加密算法加解密，通常的做法是在代码中写死，硬编码到代码里。但是通过工具分析代码，是可以看到编码信息的，所以安全的做法是做一次变换，再硬编码进去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="安全" scheme="https://dishibolei.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="iOS" scheme="https://dishibolei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>IOS应用安全-加解密算法简述</title>
    <link href="https://dishibolei.github.io/2017/05/25/save-encode/"/>
    <id>https://dishibolei.github.io/2017/05/25/save-encode/</id>
    <published>2017-05-25T05:54:41.000Z</published>
    <updated>2017-11-22T10:15:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<blockquote>
<p>导读<br>客户端经常遇到需要对数据进行加密的情况，那应该如何加密，选用什么样的加密算法，是本文想要讨论的问题。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<p>如果把我们的数据比作笔记，那数据加密相当于给笔记本上了锁，解密相当于打开锁看到笔记。而打开锁的钥匙一定是在私人手里的，外人是打不开的。所以数据加密一定有三个关键字：</p>
<p><strong>1.加密<br>2.解密<br>3.秘钥</strong></p>
<p>所以有些常见的算法不是数据加密的范围，这个开发需要注意。比如Base64编码，MD5算法。</p>
<p>Base64只是把数据编码，通俗讲只是把原来用汉语写的笔记内容，改成用英语写的内容，只要懂转换规则的任何人都能得到数据。所以老板说把数据加下密，一定不是让你Base64一下或者用其他编码重新编码下，编码算法不涉及到数据安全。</p>
<p>MD5算法也是数据处理的一种方式，更多的被用在数据验证身上。用上面的例子来讲，MD5算法把整本书的内容变成了一句标题，通过标题是没办法推算出整个书讲什么的。因为根本没有解密的步骤，所以也不属于加密算法。</p>
<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>计算机的所有数据，最终都是由多个二进制bit(0/1)来存储和传输的，但是怎么从0/1转化成我们可读的文字，就涉及到编码的知识了。下面是基础的编码概念。</p>
<h2 id="ASCII-（NSASCIIStringEncoding）"><a href="#ASCII-（NSASCIIStringEncoding）" class="headerlink" title="ASCII （NSASCIIStringEncoding）"></a>ASCII （NSASCIIStringEncoding）</h2><p>使用一个字节大小表示的128个字符。其中这些字符主要是英文字符，现在很少使用这个编码，因为不够用。<strong>ASCII字符占用一个字节</strong>。<a href="http://ascii.911cha.com/" target="_blank" rel="external">ASCII码表</a></p>
<p>主要使用到的是英文字母的大小写转换。大写的A~Z编码+32等于小写的a~z。</p>
<h2 id="UNICODE-NSUnicodeStringEncoding"><a href="#UNICODE-NSUnicodeStringEncoding" class="headerlink" title="UNICODE (NSUnicodeStringEncoding)"></a>UNICODE (NSUnicodeStringEncoding)</h2><p>ASCII只能表示128个字符，对于英文国家来说足够了，对于我们中国来说，我们有几万个汉字不够啊。于是我们创造出了GB2312等等我们自己的字符集。日本也觉得我也不够啊，我也搞个字符集。这些字符集彼此是不兼容的，没办法转换，同样的字符<code>ABCD</code>,我们可能表示<code>好</code>,日本就可能就表示<code>坏</code>。于是程序猿们觉得我要搞个标准，大家都按照标准来。</p>
<p>于是就有了UNICODE编码。它是<strong>所有字符的国际标准编码字符集</strong>。这个是为了解决ASCII字符不够的问题。同时让所有组织使用同一套编码规则，解决编码不兼容的问题。所以现在通用的编码规则都是UNICODE编码。UNICODE向下兼容ASCII编码。UNICODE最大长度可以到4个字节。不过通常只使用两个字节表示。所以通常认为<strong>UNICODE占用2字节数据</strong>。</p>
<h2 id="UTF-8-（NSUTF8StringEncoding）"><a href="#UTF-8-（NSUTF8StringEncoding）" class="headerlink" title="UTF-8 （NSUTF8StringEncoding）"></a>UTF-8 （NSUTF8StringEncoding）</h2><p>其实UNICODE已经足够使用了，不过因为如果是ASCII表示的字符（比如英文）只需要1字节就可以了，UNICODE表示的话其中一个字节全是0，这个字节浪费了，<code>英语国家的程序猿觉得：我靠，我又不需要那么多复杂的字符,浪费我流量和空间啊，不行！！</code>，于是出现了对UNICODE的转换，也就是UTF-8格式，可以保证原ASCII字符依然用一个字节表示，非ASCII字符使用多个字符表示。</p>
<p>UNICODE到UTF-8的规则如下：</p>
<ol>
<li>按照UNICODE编码的范围，算出需要几个字节，比如1个字节数，2个字数节，3个字节数，4个字节数。具体范围参考下面的图。</li>
<li>单字节和ASCII码完全相同，</li>
<li>对于其他字节数，字节1的前面用1填充，几个字节数就添加几个<code>1</code>，后面补一个0。其他字节都用<code>10</code>开头。</li>
<li>剩余的位置，按照顺序把原始数据补齐。</li>
</ol>
<p><img src="/2017/05/25/save-encode/utf_8.png" alt="utf_8"></p>
<p>例子：</p>
<p>“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</p>
<p>对于UTF-8编码的文件，会在文件头写入<code>EF BB BF</code>,表明是UTF-8编码。</p>
<h2 id="UTF-16-（NSUTF16StringEncoding）"><a href="#UTF-16-（NSUTF16StringEncoding）" class="headerlink" title="UTF-16 （NSUTF16StringEncoding）"></a>UTF-16 （NSUTF16StringEncoding）</h2><p>UTF-16的编码方法是：</p>
<ul>
<li>如果二进制（流b小于0x10000，也就是十进制的0到65535之内，则直接使用两字节表示。</li>
<li>如果二进制流b大于等于0x10000，将b-0x10000的结果中的前 10 位作为高位和0xD800进行逻辑或操作，将后10 bit作为低位和0xDC00做逻辑或操作，这样组成的4个字节就构成了b的编码。</li>
</ul>
<p>举个例子。假设要算（U+2A6A5，四个繁体字龙）在UTF-16下的值，因为它超过 U+FFFF，所以 2A6A5-10000=0x1A6A5=。</p>
<p>前10位0001 1010 01 | 0xD800 = 0xD896。</p>
<p>后10位10 1010 0101 | 0xDC00 = 0xDEA5。</p>
<p>所以U+ 2A6A5 在UTF-16中的像是D8 96 DE A5。</p>
<p>注：上文参考：<a href="http://blog.csdn.net/gqqnb/article/details/6266542" target="_blank" rel="external">精确解释Unicode</a></p>
<p>在IOS程序里面NSUTF16StringEncoding和NSUnicodeStringEncoding是等价的。</p>
<h2 id="UTF-16大端-小端（NSUTF16BigEndianStringEncoding-NSUTF16LittleEndianStringEncoding）"><a href="#UTF-16大端-小端（NSUTF16BigEndianStringEncoding-NSUTF16LittleEndianStringEncoding）" class="headerlink" title="UTF-16大端/小端（NSUTF16BigEndianStringEncoding/NSUTF16LittleEndianStringEncoding）"></a>UTF-16大端/小端（NSUTF16BigEndianStringEncoding/NSUTF16LittleEndianStringEncoding）</h2><p>大小端主要表明了，系统存储数据的顺序。因为UTF-16至少两个字节，这两个字节传输过来后，接收的人需要知道哪个字节是在前，哪个字节在后。然后系统才知道改如何存取。</p>
<p>Unicode规范中用字节序标记字符（BOM）来标识字节序，它的编码是FEFF。这样如果接收者收到FEFF，就表明这个字节流是高位在前的；如果收到FFFE，就表明这个字节流是低位在前的。</p>
<p>比如“汉”字的Unicode编码是0x6C49。</p>
<p>对于大端的文件数据为：<code>FE FF 6c 49</code><br>对于小端的文件数据为：<code>FF FE 49 6c</code></p>
<p>对于大小端的概念，本人经常搞混，什么高地址存低字节的，绕一绕就晕了。下面是我的理解：</p>
<ol>
<li>对于一个16进制数0x1234,我们知道这个数对应的是两个字节，占用16个比特。</li>
<li>系统中是按照字节为单位去保存数据的。一个地址空间对应1个字节。比如0x1234如果要存储在计算机里，需要占用两个地址空间。我们假设这个地址空间起始是0x00，因为需要两个字节，所以还需要一个地址空间来保存，即0x01。其中明显0x01是高地址空间。</li>
<li>所以问题就在于，对于0x1234这个数据保存，是0x01地址保存0x12还是保存0x24。</li>
<li>如果把0x1234看成字符串形式，按照正常顺序存储，先存0x12,后存0x34,对应的就是大端模式。</li>
<li>如果按照字节顺序，0x12是高位，0x34是低位，应该0x12存储在高位地址0x02,低位字节0x34存储在低位地址0x01。这种方式就是小端模式。</li>
<li>为了怕记混，可以这么记：我最大，按字符串顺序存储，我看的最舒服所以是大端。反面的就是小端的。</li>
</ol>
<table>
<thead>
<tr>
<th>地址偏移</th>
<th>大端模式</th>
<th>小端模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>12</td>
<td>34</td>
</tr>
<tr>
<td>0x01</td>
<td>34</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>附：代码判断大小端的代码。</p>
<p>原理是生成一个两字节的数据，然后转为1字节的char数据。大端取到的是第一个高字节，小端取到的是第二个低字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    short x = 1; //0x0001</div><div class="line">    char *p = (char *)&amp;x;</div><div class="line"></div><div class="line">    if(*p)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;little\n&quot;);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        printf(&quot;large\n&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>详细的本人没看懂，实际中没有用到这个编码，这个编码使用4字节存储。也有大小端之分</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>字符编码就是把可读的字符转化为二进制数据方法，字符解码就是把二进制数据转化为可读的方法。</li>
<li>ASCII占用1个字节，只有128个字符，主要是英文字符。</li>
<li>UNICODE是国际标准编码字符集，包含了所有已知符号。</li>
<li>UTF-8是UNICODE编码的一种实现方式，兼容ASCII码，也就是英文字符占1个字节，汉字可能占两个字节或三个字节。</li>
<li>UTF-16也是UNICODE编码的一种实现方式，通常和UNICODE编码一致，占用两个字节，分大小端。</li>
</ol>
<h1 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h1><p>Base64编码的作用是把非ASCII的字符转换为ASCII的字符。很多加密算法，很喜欢做一次Base64转换。原因是使用Base64编码后，所有的数据都是ASCII字符，方便在网络上传输。</p>
<p>设计思路是：<strong>Base64把每三个8Bit的字节转换为四个6Bit的字节（3<em>8 = 4</em>6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节</strong>。所以Base64算法生成的数据会比原数据大1/3左右。</p>
<p>比如：</p>
<ol>
<li>图片这种二进制数据就可以转换为Base64作为文本传输。</li>
<li>比如有中文的数据，可以通过Base64转为可以显示的ASCII数据</li>
</ol>
<p>简单说明：</p>
<ol>
<li>将字符按照文字编码转化为二进制字节。</li>
<li>每3字节化为一组（24bit），如果字节不够，最后输出结果补<code>=</code>。然后再把每一组拆分成4个组，每个组6bit,如果不足6bit后面补0。</li>
<li>将每个6bit前面补足两个0，凑够8位。</li>
<li>然后按照新分出来的每8位转成10进制数，按照表里面的查找，转为对应的ASCII字符。</li>
</ol>
<p><img src="/2017/05/25/save-encode/base_64.jpeg" alt="base_64"></p>
<p>举例：</p>
<p>字符<code>bl</code>如何转化为Base64编码：</p>
<ol>
<li>bl对应的ASCII码为： <code>01100010</code>和<code>01101100</code>,因为只有两个，所以有一个输出结果是<code>=</code></li>
<li>按照每三个字节分组：<code>0110001001101100</code></li>
<li>按照每个组6bit分4个组,不足6位的补0：<code>011000</code>,<code>100110</code>,<code>110000</code></li>
<li>在前面补<code>0</code>,凑够8位：<code>00011000</code>,<code>00100110</code>,<code>00110000</code></li>
<li>转为10进制：<code>24</code>,<code>38</code>,<code>48</code>。</li>
<li>查表得到：<code>Y</code>,<code>m</code>,<code>w</code></li>
<li>最后补<code>=</code>,所以结果为<code>Ymw=</code></li>
</ol>
<p>标准的程序实现可以参考：<code>GTMBase64.m</code>。</p>
<p>说明：</p>
<p><strong>Base64是一种编码算法，不是加密算法</strong>,他的作用不是加密，而是用最简的ASCII码来传输文本数据，屏蔽掉设备网络差异，是为了方便传输的一种算法。很多加密算法，最后生成的是二进制数据，不是可见字符，而传输的一般是通过字符传输，所以常见的二进制转化方式就是Base64算法。</p>
<h1 id="哈希散列算法"><a href="#哈希散列算法" class="headerlink" title="哈希散列算法"></a>哈希散列算法</h1><p><code>一个萝卜一个坑</code>这个俗语形容这个算法很贴切。官方的定义为：</p>
<p><strong>散列（Hash）函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。</strong></p>
<p>安全的哈希算法要满足下面条件：</p>
<ol>
<li><strong>固定长度</strong>。不同长度的数据，生成的固定长度的数据</li>
<li><strong>唯一性</strong>。不同的数据，生成的结果一定不同。相同的数据，每次输出的结果一定一样。</li>
<li><strong>不可逆</strong>。对于生成后的数据，反推回原数据，通过算法是不可能的。</li>
<li><strong>防篡改</strong>。两个输出的散列值相同，则原数据一定相同。如果两个输出的散列值不同，则原数据一定不同。</li>
</ol>
<p>从上面的特点可以知道散列值主要使用的场景：</p>
<ol>
<li>生成唯一的值做索引，比如哈希表</li>
<li>用作数据签名，校验数据完整性和有效性。</li>
<li>密码脱敏处理。</li>
</ol>
<h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><p>MD5算法是最常用的散列算法。</p>
<p>对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为十六个32位子分组，经过了一系列的处理后，算法的输出由4个32位分组组成，将这4个32位分组级联后将生成1个128位散列值。</p>
<p>算法有点复杂，没有看懂，放下不表。</p>
<p>下面是本人的简单理解：</p>
<ol>
<li>MD5算法效率是比较快的。</li>
<li>MD5防碰撞能力比较强，只有少数的几个例子有出现碰撞的情况。但也不影响安全性。</li>
<li>MD5生成的是固定128位,16个字节。</li>
</ol>
<h3 id="MD5算法安全性"><a href="#MD5算法安全性" class="headerlink" title="MD5算法安全性"></a>MD5算法安全性</h3><p><strong>目前主流看法是MD5逐渐有被攻克的风险。</strong>但是目前还没有有效算法破解。</p>
<p>主要的破解方法是使用数据库保存常见的字符串的MD5值，然后通过反查得到原始数据。也就是如果用户的密码很常见就很容易破解。如果用户密码是随机的，那就没什么平台可以破解了。</p>
<p>下面对于是用MD5的观点：</p>
<ol>
<li>MD5不是加密算法，重要的用户密码应该加密存储。做MD5只是为了脱敏，也就是不让相关人员知道原文是什么（包括内鬼）。</li>
<li>极重要数据是用更安全的算法：比如用户密码数据使用更安全的算法，比如SHA1算法。传输过程中也进一步加密。</li>
<li>如果使用MD5算法，在原始值里面加入盐值。盐值要尽量随机。因为如果加入随机值后原始值也变得随机，使用暴力破解就基本不可能了。即<code>result = MD5(password + salt)</code></li>
</ol>
<h3 id="关于加盐"><a href="#关于加盐" class="headerlink" title="关于加盐"></a>关于加盐</h3><p>这里有个<a href="http://www.cmd5.com/hash.aspx" target="_blank" rel="external">破解的网站</a>，大家可以看下常用的策略其实都可以破解。安全性主要是盐如何选择。 </p>
<ol>
<li>盐值要是随机字符，数据尽量长一些，只有这样才能保证最后数据的随机。</li>
<li>盐值尽量保证每个用户不一样，增加破解的难度。</li>
<li>盐值的保存可以是前后端约定,固化在APP里，但是也应该和用户相关，比如salt=(固化的值+用户信息)。可以是通过一些随机值变化得来：比如用户注册时间等信息做盐值。可以是每次随机生成，当做参数带给后端，后端保存密码+盐值。安全性从低到高。还有做多次MD5的，个人觉得意义不大。</li>
<li>个人推荐的一个方案。<code>result = MD5 (password + salt)</code>。salt的计算方法是：MD5(Random(128)+ uid)。其中Random(128)表示一个随机128位字符串，两端可以一致，固化在代码里。uid是用户唯一标示，比如登陆用的用户名。这样对于破解者来说就需要先拿到这个salt值，然后对每个用户都要生成一个唯一的128位的盐值，去生成对应的库，破解成本就非常高了。</li>
</ol>
<p>其实目前暴漏出来的是攻击者把整个数据库的内容拿到后，暴力解密出原文。但是MD5加盐也好变换也好都是可以通过前端代码查到算法的，通过算法就可以生成常用数据对应的MD5库。<strong>所以密码做MD5更重要的是脱敏处理，不能做为安全的加密使用，重要的用户密码持久化或传输过程中一定是要通过加密算法处理的</strong>。这样只要安全保存私钥就可以了。在很多金融公司，大量使用硬件加密机做加密处理，然后保存，更加大了破解难度。所以如果你的密码是使用加密再保存的，使用固定盐值的已经可以满足要求了。如果担心可以加上用户的注册时间或服务器时间戳做盐值。</p>
<h2 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h2><p>SHA1也是一种HASH算法。是MD5的替代方案。生成的数据是160位，20个字节。</p>
<p>目前SHA1也被认为不安全,<a href="http://www.92to.com/bangong/2017/02-25/17585278.html" target="_blank" rel="external">google找到了算法进行了碰撞</a>,所以普遍推荐使用新的SHA2代替。Google已经开始废弃这个算法了。</p>
<h2 id="SHA2"><a href="#SHA2" class="headerlink" title="SHA2"></a>SHA2</h2><ul>
<li>SHA-224、SHA-256、SHA-384，和SHA-512并称为SHA-2。</li>
<li>新的散列函数并没有接受像SHA-1一样的公众密码社区做详细的检验，所以它们的密码安全性还不被大家广泛的信任。</li>
<li>虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。</li>
</ul>
<p>所以目前推荐使用SHA2相关的算法做散列算法。</p>
<p>其中SHA-256输出为256位，32字节。<br>SHA-512输出为512位，64字节。</p>
<h2 id="HMac"><a href="#HMac" class="headerlink" title="HMac"></a>HMac</h2><p>HMac是秘钥相关的哈希算法。和之前的算法不同的在于需要一个秘钥，才能生成输出。主要是基于签名散列算法。可以认为是散列算法加入了加密逻辑，所以相比SHA算法更难破解，包含下面的算法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line">    @enum       CCHmacAlgorithm</div><div class="line">    @abstract   Algorithms implemented in this module.</div><div class="line"></div><div class="line">    @constant   kCCHmacAlgSHA1      HMAC with SHA1 digest</div><div class="line">    @constant   kCCHmacAlgMD5       HMAC with MD5 digest</div><div class="line">    @constant   kCCHmacAlgSHA256    HMAC with SHA256 digest</div><div class="line">    @constant   kCCHmacAlgSHA384    HMAC with SHA384 digest</div><div class="line">    @constant   kCCHmacAlgSHA512    HMAC with SHA512 digest</div><div class="line">    @constant   kCCHmacAlgSHA224    HMAC with SHA224 digest</div><div class="line"> */</div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    kCCHmacAlgSHA1,</div><div class="line">    kCCHmacAlgMD5,</div><div class="line">    kCCHmacAlgSHA256,</div><div class="line">    kCCHmacAlgSHA384,</div><div class="line">    kCCHmacAlgSHA512,</div><div class="line">    kCCHmacAlgSHA224</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> uint32_t CCHmacAlgorithm;</div></pre></td></tr></table></figure>
<p>HMAC主要应用场景：</p>
<ol>
<li>密码的散列存储，因为需要散列的时候需要密码，实际上相当于算法里加了盐值。使用的密码要随机和用户相关，请参考盐值的生产规则。</li>
<li>用于数据签名。双方使用共同的秘钥，然后做签名验证。秘钥可以固化，也可以会话开始前协商，增加签名篡改和被破解的难度。</li>
</ol>
<p>PS：目前项目中的密码散列算法，采用的就是HMac算法。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>密码保存和传输需要做散列处理。但是散列算法主要是脱敏，不能替代加密算法。</li>
<li>如今常用的Md5算法和SHA1算法都不再安全。所以推荐使用SHA-2相关算法。</li>
<li>散列算法应该加入盐值即：<code>result=HASH(password+salt)</code>。其中盐值应该是随机字符串且每个用户不一样。</li>
<li>HMac引入了秘钥的概念，如果不知道秘钥，秘钥不同，散列值也不同，相当于散列算法加入了盐值。可以把它当做更安全的散列算法使用。</li>
</ol>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>算法都是使用苹果自己的Security.framework框架实现的，只需要调用相关算法就可以了。推荐一个<a href="https://github.com/cocoajin/Security-iOS" target="_blank" rel="external">github</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//</div><div class="line">//  NSData+KKHASH.m</div><div class="line">//  SecurityiOS</div><div class="line">//</div><div class="line">//  Created by cocoa on 16/12/15.</div><div class="line">//  Copyright © 2016年 dev.keke@gmail.com. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;NSData+KKHASH.h&quot;</div><div class="line">#include &lt;CommonCrypto/CommonDigest.h&gt;</div><div class="line">#import &lt;CommonCrypto/CommonHMAC.h&gt;</div><div class="line"></div><div class="line">@implementation NSData (KKHASH)</div><div class="line">- (NSData *)hashDataWith:(CCDIGESTAlgorithm )ccAlgorithm</div><div class="line">&#123;</div><div class="line">    NSData *retData = nil;</div><div class="line">    if (self.length &lt;1) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    unsigned char *md;</div><div class="line">    </div><div class="line">    switch (ccAlgorithm) &#123;</div><div class="line">        case CCDIGEST_MD2:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_MD2_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_MD2_DIGEST_LENGTH);</div><div class="line">            CC_MD2(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_MD2_DIGEST_LENGTH];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_MD4:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_MD4_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_MD4_DIGEST_LENGTH);</div><div class="line">            CC_MD4(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_MD4_DIGEST_LENGTH];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_MD5:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_MD5_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_MD5_DIGEST_LENGTH);</div><div class="line">            CC_MD5(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_MD5_DIGEST_LENGTH];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA1:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA1_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA1_DIGEST_LENGTH);</div><div class="line">            CC_SHA1(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA224:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA224_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA224_DIGEST_LENGTH);</div><div class="line">            CC_SHA224(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA224_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA256:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA256_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA256_DIGEST_LENGTH);</div><div class="line">            CC_SHA256(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA256_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA384:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA384_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA384_DIGEST_LENGTH);</div><div class="line">            CC_SHA384(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA384_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA512:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA512_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA512_DIGEST_LENGTH);</div><div class="line">            CC_SHA512(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA512_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        default:</div><div class="line">            md = malloc(1);</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    free(md);</div><div class="line">    md = NULL;</div><div class="line">    </div><div class="line">    return retData;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSData *)hmacHashDataWith:(CCHmacAlgorithm )ccAlgorithm key:(NSString *)key &#123;</div><div class="line">    NSData *retData = nil;</div><div class="line">    if (self.length &lt;1) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    unsigned char *md;</div><div class="line">    const char *cKey    = [key cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    </div><div class="line">    switch (ccAlgorithm) &#123;</div><div class="line">        case kCCHmacAlgSHA1:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA1_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA1_DIGEST_LENGTH);</div><div class="line">            CC_SHA1(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case kCCHmacAlgSHA224:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA224_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA224_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgSHA224, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA224_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case kCCHmacAlgSHA256:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA256_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA256_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgSHA256, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA256_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case kCCHmacAlgSHA384:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA384_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA384_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgSHA384, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA384_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case kCCHmacAlgSHA512:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA512_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA512_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgSHA512, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA512_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        case CCDIGEST_MD5:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_MD5_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_MD5_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgMD5, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_MD5_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            md = malloc(1);</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    free(md);</div><div class="line">    md = NULL;</div><div class="line">    </div><div class="line">    return retData;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (NSString *)hexString</div><div class="line">&#123;</div><div class="line">    NSMutableString *result = nil;</div><div class="line">    if (self.length &lt;1) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    result = [[NSMutableString alloc] initWithCapacity:self.length * 2];</div><div class="line">    for (size_t i = 0; i &lt; self.length; i++) &#123;</div><div class="line">        [result appendFormat:@&quot;%02x&quot;, ((const uint8_t *) self.bytes)[i]];</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (NSData *)dataWithHexString:(NSString *)hexString &#123;</div><div class="line">    NSMutableData *     result;</div><div class="line">    NSUInteger          cursor;</div><div class="line">    NSUInteger          limit;</div><div class="line">    </div><div class="line">    NSParameterAssert(hexString != nil);</div><div class="line">    </div><div class="line">    result = nil;</div><div class="line">    cursor = 0;</div><div class="line">    limit = hexString.length;</div><div class="line">    if ((limit % 2) == 0) &#123;</div><div class="line">        result = [[NSMutableData alloc] init];</div><div class="line">        </div><div class="line">        while (cursor != limit) &#123;</div><div class="line">            unsigned int    thisUInt;</div><div class="line">            uint8_t         thisByte;</div><div class="line">            </div><div class="line">            if ( sscanf([hexString substringWithRange:NSMakeRange(cursor, 2)].UTF8String, &quot;%x&quot;, &amp;thisUInt) != 1 ) &#123;</div><div class="line">                result = nil;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            thisByte = (uint8_t) thisUInt;</div><div class="line">            [result appendBytes:&amp;thisByte length:sizeof(thisByte)];</div><div class="line">            cursor += 2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h1 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h1><p>对称加密，指双方使用的秘钥是相同的。加密和解密都使用这个秘钥。</p>
<p>对称加密的优点为：</p>
<ol>
<li>加密效率高</li>
<li>加密速度快</li>
<li>可以对大数据进行加密</li>
</ol>
<p>缺点为：</p>
<ol>
<li>秘钥安全性无法保证，以现在的技术手段来说，默认对称秘钥的秘钥是非安全的，可以被拿到的。</li>
</ol>
<h2 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h2><ul>
<li>DES ：数据加密标准。<br>  是一种分组数据加密技术，先将数据分成固定长度64位的小数据块，之后进行加密。<br>  速度较快，适用于大量数据加密。<strong>DES密钥为64位,实际使用56位</strong>。将64位数据加密成64位数据。</li>
<li>3DES：使用三组密钥做三次加密。<br>  是一种基于 DES 的加密算法，使用3个不同密钥对同一个分组数据块进行3次加密，如此以使得密文强度更高。<strong>3DES秘钥为DES两倍或三倍，即112位或168位</strong>。其实就是DES的秘钥加强版。</li>
<li>AES ：高级加密标准。<br>  是美国联邦政府采用的一种区块加密标准。<br>  相较于 DES 和 3DES 算法而言，AES 算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准。<strong>AES秘钥长度为128、192、256位</strong>。</li>
</ul>
<p>使用到的基础数学方法：</p>
<ul>
<li>移位和循环移位<br>　　移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。</li>
<li>置换<br>　　就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。</li>
<li>扩展<br>　　就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。</li>
<li>压缩<br>　　就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。</li>
<li>异或<br>　　这是一种二进制布尔代数运算。异或的数学符号为⊕ ，它的运算法则如下：<br>1⊕1 = 0<br>0⊕0 = 0<br>1⊕0 = 1<br>0⊕1 = 1<br>　　也可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。</li>
<li>迭代<br>　　迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。</li>
</ul>
<p>对于对称加密来说，有几个共同要点：</p>
<ol>
<li>密钥长度；（关系到密钥的强度）</li>
<li>加密模式；（ecb、cbc等等）</li>
<li>块加密算法里的块大小和填充方式区分；</li>
</ol>
<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><h3 id="ECB-模式"><a href="#ECB-模式" class="headerlink" title="ECB 模式"></a>ECB 模式</h3><p>ECB ：电子密本方式，最古老,最简单的模式，将加密的数据分成若干组，每组的大小跟加密密钥长度相同；<br>然后每组都用相同的密钥加密。OC对应的为<code>kCCOptionECBMode</code></p>
<p>ECB的特点为：</p>
<ul>
<li>每次Key、明文、密文的长度都必须是64位；</li>
<li>数据块重复排序不需要检测；</li>
<li>相同的明文块(使用相同的密钥)产生相同的密文块，容易遭受字典攻击；</li>
<li>一个错误仅仅会对一个密文块产生影响，所以支持并行计算；</li>
</ul>
<h3 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h3><ul>
<li>CBC ：密文分组链接方式。与ECB相比，加入了<strong>初始向量IV</strong>。将加密的数据分成若干组，加密时第一个数据需要先和向量异或之后才加密。后面的数据需要先和前面的数据异或，然后再加密。是OC默认的加密模式。</li>
</ul>
<p>CBC的特点为：</p>
<ul>
<li>每次加密的密文长度为64位(8个字节);</li>
<li>当相同的明文使用相同的密钥和初始向量的时候CBC模式总是产生相同的密文;</li>
<li>密文块要依赖以前的操作结果,所以，密文块不能进行重新排列;</li>
<li>可以使用不同的初始化向量来避免相同的明文产生相同的密文,一定程度上抵抗字典攻击;</li>
<li>一个错误发生以后,当前和以后的密文都会被影响;</li>
</ul>
<h2 id="块大小和填充方式"><a href="#块大小和填充方式" class="headerlink" title="块大小和填充方式"></a>块大小和填充方式</h2><p>对称算法的第一步就是对数据进行分组，每一个组的大小称为快大小，比如DES需要将数据分组为64位（8个字节），如果数据不够64位就需要进行补位。</p>
<h3 id="PKCS7Padding填充"><a href="#PKCS7Padding填充" class="headerlink" title="PKCS7Padding填充"></a>PKCS7Padding填充</h3><p>OC中指定的填充方法只有<code>kCCOptionPKCS7Padding</code>，对应JAVA的<code>PKCS5Padding</code>填充方式。算法为计算缺几位数，然后就补几位数，数值为下面的公式：</p>
<p><code>value=k - (l mod k)  ,K=块大小，l=数据长度，如果l=8, 则需要填充额外的8个byte的8</code></p>
<p>比如块大小为8字节，数据为<code>DD DD DD DD</code>4个字节，带入公式，l=4,k=8,计算 8 - （4 mod 8）= 4 ,所以补充4个4，补位后得到<code>DD DD DD DD 04 04 04 04</code>。</p>
<p>唯一特别的是如果最后位数是够的，也需要额外补充，比如数据是<code>DD DD DD DD DD DD DD DD</code>8个字节,带入公式，l=8,k=8,计算 8 - （8 mod 8）= 8，所以补位后得到<code>DD DD DD DD DD DD DD DD 08 08 08 08 08 08 08 08</code>。 所以如果考虑补位，实际输出buffer大小要加上快大小，防止buffer不够。</p>
<h3 id="Zero-Padding（No-Padding）"><a href="#Zero-Padding（No-Padding）" class="headerlink" title="Zero Padding（No Padding）"></a>Zero Padding（No Padding）</h3><p>补位的算法和PKCS7Padding一致，只不过补的位为<code>0x00</code>,比如数据为<code>DD DD DD DD</code>4个字节，带入公式，l=4,k=8,计算 8 - （4 mod 8）= 4 ,所以补充4个00，补位后得到<code>DD DD DD DD 00 00 00 00</code>。</p>
<p><strong>非常不建议用这种模式，因为解密后的数据会多出补的<code>00</code></strong>。如果原始数据以<code>00</code>结尾(ASCII码代表空字符)，就没办法区分出来了。</p>
<h2 id="几种算法比较"><a href="#几种算法比较" class="headerlink" title="几种算法比较"></a>几种算法比较</h2><table>
<thead>
<tr>
<th>算法</th>
<th>秘钥长度（字节）</th>
<th>分组长度（字节）</th>
<th>加密效率</th>
<th>破解难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>DES</td>
<td>8</td>
<td>8</td>
<td>较快（22.5MB/S）</td>
<td>简单</td>
</tr>
<tr>
<td>3DES</td>
<td>24</td>
<td>8</td>
<td>慢（12MB/S）</td>
<td>难</td>
</tr>
<tr>
<td>AES</td>
<td>16/24/32</td>
<td>16</td>
<td>快（51.2MB/s）</td>
<td>难</td>
</tr>
</tbody>
</table>
<h2 id="IOS-代码实现解析"><a href="#IOS-代码实现解析" class="headerlink" title="IOS 代码实现解析"></a>IOS 代码实现解析</h2><p>下面以AES代码实现为例，说明下IOS加解密算法的实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ (<span class="built_in">NSString</span> *)AES128Encrypt:(<span class="built_in">NSString</span> *)plainText key:(<span class="built_in">NSString</span> *)gkey iv:(<span class="built_in">NSString</span> *)gIv padding:(<span class="built_in">BOOL</span>)padding</div><div class="line">&#123;</div><div class="line">    <span class="comment">//先处理秘钥，如果秘钥不够算法长度，就用0填充，如果长于算法长度就截断。</span></div><div class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128+<span class="number">1</span>]; <span class="comment">//申请秘钥buffer，这里根据不同算法导入需要的key长度。AES128是16个字节，对应的值kCCKeySizeAES128。</span></div><div class="line">    memset(keyPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(keyPtr)); <span class="comment">//使用0填充，保证秘钥长度达到要求。</span></div><div class="line">    [gkey getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>]; <span class="comment">//将传入的秘钥copy进秘钥buffer里</span></div><div class="line">    </div><div class="line">    <span class="comment">//注意这个只在模式为CBC下有效，</span></div><div class="line">    <span class="comment">//处理向量值，默认模式为CBC。如果指定了kCCOptionECBMode模式，就不需要这个向量。</span></div><div class="line">    <span class="keyword">char</span> ivPtr[kCCBlockSizeAES128+<span class="number">1</span>]; <span class="comment">//申请向量的buffer，长度为块长度。AES128块长度为kCCBlockSizeAES128。</span></div><div class="line">    memset(ivPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ivPtr));</div><div class="line">    [gIv getCString:ivPtr maxLength:<span class="keyword">sizeof</span>(ivPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>]; <span class="comment">//将传入的值copy进向量buffer</span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="built_in">NSData</span>* data = [plainText dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">    <span class="built_in">NSUInteger</span> dataLength = [data length];</div><div class="line">    </div><div class="line">    <span class="comment">//注意这个只在不指定padding的情况下有效，需要填充0，算法为num_to_fill= k - (length mod k)，如果指定了kCCOptionPKCS7Padding，就不需要人为填充。</span></div><div class="line">    </div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> newSize = dataLength;</div><div class="line">    <span class="keyword">int</span> diff = padding ? <span class="number">0</span> : kCCKeySizeAES128 - (dataLength % kCCKeySizeAES128);</div><div class="line">    <span class="keyword">if</span>(diff &gt; <span class="number">0</span>) &#123;</div><div class="line">        newSize = dataLength + diff;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">char</span> dataPtr[newSize];</div><div class="line">    memcpy(dataPtr, [data bytes], [data length]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; i++) &#123;</div><div class="line">        dataPtr[i + dataLength] = <span class="number">0x00</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//输出的buffer</span></div><div class="line">    size_t bufferSize = newSize + kCCBlockSizeAES128;</div><div class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</div><div class="line">    memset(buffer, <span class="number">0</span>, bufferSize);</div><div class="line">    </div><div class="line">    size_t numBytesCrypted = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    CCOptions option = padding ? kCCOptionPKCS7Padding : <span class="number">0x0000</span>;</div><div class="line">    option = gIv.length &gt; <span class="number">0</span> ? option : option | kCCOptionECBMode;</div><div class="line">    </div><div class="line">    </div><div class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</div><div class="line">                                          kCCAlgorithmAES128,</div><div class="line">                                          option,</div><div class="line"><span class="comment">//                                          0x0000,               //No padding | CBC模式  需要补零且需要iv向量</span></div><div class="line"><span class="comment">//                                          kCCOptionPKCS7Padding,  //  kCCOptionPKCS7Padding | CBC模式   需要iv向量</span></div><div class="line">                                          <span class="comment">//kCCOptionPKCS7Padding | kCCOptionECBMode, // kCCOptionPKCS7Padding | kCCOptionECBMode 不需要iv向量，也不需要补零</span></div><div class="line"><span class="comment">//                                          kCCOptionECBMode, // No padding | kCCOptionECBMode 不需要补零，不需要iv向量</span></div><div class="line">                                          keyPtr,</div><div class="line">                                          kCCKeySizeAES128,</div><div class="line">                                          ivPtr,</div><div class="line">                                          dataPtr,</div><div class="line">                                          <span class="keyword">sizeof</span>(dataPtr),</div><div class="line">                                          buffer,</div><div class="line">                                          bufferSize,</div><div class="line">                                          &amp;numBytesCrypted);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</div><div class="line">        <span class="built_in">NSData</span> *resultData = [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesCrypted];</div><div class="line">        resultData = [resultData base64EncodedDataWithOptions:(<span class="built_in">NSDataBase64EncodingOptions</span>)<span class="number">0</span>];</div><div class="line">        <span class="built_in">NSString</span> *encryptedString = [[<span class="built_in">NSString</span> alloc] initWithData:resultData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">        <span class="keyword">return</span> encryptedString;</div><div class="line">    &#125;</div><div class="line">    free(buffer);</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSString</span> *)AES128Decrypt:(<span class="built_in">NSString</span> *)encryptText key:(<span class="built_in">NSString</span> *)gkey iv:(<span class="built_in">NSString</span> *)gIv padding:(<span class="built_in">BOOL</span>)padding</div><div class="line">&#123;</div><div class="line">    <span class="comment">//复制秘钥buffer</span></div><div class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128 + <span class="number">1</span>];</div><div class="line">    memset(keyPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(keyPtr));</div><div class="line">    [gkey getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//复制向量buffer</span></div><div class="line">    <span class="keyword">char</span> ivPtr[kCCBlockSizeAES128 + <span class="number">1</span>];</div><div class="line">    memset(ivPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ivPtr));</div><div class="line">    [gIv getCString:ivPtr maxLength:<span class="keyword">sizeof</span>(ivPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">    <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc] initWithBase64EncodedString:encryptText options:<span class="number">0</span>];</div><div class="line">    <span class="built_in">NSUInteger</span> dataLength = [data length];</div><div class="line">    size_t bufferSize = dataLength + kCCBlockSizeAES128;</div><div class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</div><div class="line">    </div><div class="line">    <span class="comment">//计算采用哪种模式和填充方式</span></div><div class="line">    CCOptions option = padding ? kCCOptionPKCS7Padding : <span class="number">0x0000</span>;</div><div class="line">    option = gIv.length &gt; <span class="number">0</span> ? option : option | kCCOptionECBMode;</div><div class="line">    </div><div class="line">    size_t numBytesCrypted = <span class="number">0</span>;</div><div class="line">    <span class="comment">//解密</span></div><div class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</div><div class="line">                                          kCCAlgorithmAES128,</div><div class="line">                                          option,</div><div class="line"><span class="comment">//                                          0x0000,               //No padding | CBC模式  需要补零且需要iv向量</span></div><div class="line"><span class="comment">//                                          kCCOptionPKCS7Padding,  //  kCCOptionPKCS7Padding | CBC模式   需要iv向量</span></div><div class="line">                                          <span class="comment">//kCCOptionPKCS7Padding | kCCOptionECBMode, // kCCOptionPKCS7Padding | kCCOptionECBMode 不需要iv向量，也不需要补零</span></div><div class="line"><span class="comment">//                                          kCCOptionECBMode, // No padding | kCCOptionECBMode 不需要补零，不需要iv向量</span></div><div class="line">                                          keyPtr,</div><div class="line">                                          kCCBlockSizeAES128,</div><div class="line">                                          ivPtr,</div><div class="line">                                          [data bytes],</div><div class="line">                                          dataLength,</div><div class="line">                                          buffer,</div><div class="line">                                          bufferSize,</div><div class="line">                                          &amp;numBytesCrypted);</div><div class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</div><div class="line">        <span class="built_in">NSData</span> *resultData = [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesCrypted];</div><div class="line">        <span class="built_in">NSString</span> *result = [[<span class="built_in">NSString</span> alloc] initWithData:resultData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">        <span class="keyword">if</span> ([result length] &gt; <span class="number">0</span> &amp;&amp; !padding) &#123;</div><div class="line">            <span class="comment">//如果是非填充模式，解析后的数据会多出填充的'\0',所以需要去掉。</span></div><div class="line">            <span class="keyword">long</span> byteWithoutZero = numBytesCrypted;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *utf8Str =  [result UTF8String];</div><div class="line">            <span class="comment">//从后开始扫描，查到需要截断的长度</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = byteWithoutZero - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --) &#123;</div><div class="line">                <span class="keyword">if</span> (utf8Str[i] != <span class="string">'\0'</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                byteWithoutZero --;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">NSString</span> *finalReslut = [[<span class="built_in">NSString</span> alloc] initWithBytes:utf8Str length:byteWithoutZero encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> finalReslut;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    free(buffer);</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建议和说明</p>
<ol>
<li>建议使用ECB模式（kCCOptionECBMode），填充采用kCCOptionPKCS7Padding。这种使用最广泛，和PHP、JAVA（AES/ECB/PKCS5Padding）都适配。联调的时候需要注意两端是否一致，不一致是调不通的。</li>
<li>通常数据加密后，会做一次Base64编码进行传输，有些应用也会将数据转为二进制字符串传输。 </li>
<li>如果不指定模式，则默认是CBC模式，需要用到向量IV。</li>
<li>如果不指定填充格式，则需要自行补<code>0x00</code>处理，在解码后也需要把补的<code>0x00</code>去除掉，网上很多资料解码后没有去除，会多出<code>\0</code>。</li>
</ol>
<h2 id="说明和总结"><a href="#说明和总结" class="headerlink" title="说明和总结"></a>说明和总结</h2><ol>
<li>建议对称加密使用AES加密。DES无论安全性和效率都不如AES算法。</li>
<li>加密建议用<code>kCCOptionPKCS7Padding</code>填充方式，对应的JAVA模式为<code>PKCS5Padding</code></li>
<li>如果用CBC模式，需要使用初始向量，初始向量两端应该一致。如果不使用应该指定<code>kCCOptionECBMode</code>。也建议用这个模式，兼容性最好。</li>
<li>秘钥应该用随机数生成对应的位数。AES128为16个字节，也就是16个字符。不要用短密码,比如：<code>111111</code>,这样真的很蠢。</li>
<li>对称加密的安全隐患主要在于秘钥的保存。重要会话的秘钥应该随机生成，使用非对称加密来沟通交换秘钥，策略可以参考我的另一篇文章<a href="https://dishibolei.github.io/2017/05/11/https-safe-1/">IOS应用安全-HTTP/HTTPS网络安全(一)</a>。</li>
<li>如果秘钥需要硬编码到程序里，应该做脱敏运算，比如做位运算进行变形等。后面会专门写怎么解决秘钥硬编码问题。</li>
</ol>
<h1 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h1><p>非对称秘钥加密算法的特点是：<strong>加密和解密使用不同的秘钥</strong>。</p>
<p>非对称加密需要两个秘钥：公开秘钥和私有秘钥。两个秘钥是不同的，而且通过公钥是无法推算出私钥的，使用公钥加密的数据只有用私钥解密。</p>
<p>非对称算法的特点：</p>
<ol>
<li>解决了秘钥保存的问题。公钥可以发布出去，任何人都可以使用，也不用担心被人获取到，只要保证私钥的安全就可以了。而对称加密，因为秘钥相同，客户端泄露了就不安全了。</li>
<li>加密和解密的效率不高，只适合加解密少量的数据。而对称加密效率要高。这里有一篇文章对比<a href="http://blog.csdn.net/yore_/article/details/52733994" target="_blank" rel="external">AES和RSA算法的性能对比</a>。</li>
</ol>
<h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><p>RSA是目前最常用的非对称加密算法。</p>
<p>算法原理可以看下这篇文章：<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">RSA算法原理</a>。</p>
<p>RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。RSA的秘钥长度在2048位，现有的技术手段是无法破解的（实际的可以暴力破解的位数为768位，也就是768位的大数才有可能暴力进行因数分解）。</p>
<p>RSA算法优点：</p>
<ol>
<li>算法原理简单，我都快看懂了。</li>
<li>安全性也足够高，目前没有证据和方案可以破解1048位以上秘钥的RSA算法。</li>
</ol>
<p>缺点：</p>
<ol>
<li>安全性取决于秘钥长度，推荐的要至少1048位，但是这么高位数的秘钥生成速度很慢，所以没法做一次会话一次秘钥。</li>
<li>加解密的效率很低，相对于对称加密，差好几个量级，而且也不支持加密长数据。</li>
</ol>
<h2 id="国密算法SM2"><a href="#国密算法SM2" class="headerlink" title="国密算法SM2"></a>国密算法SM2</h2><p>中国特有的算法，国家强制要求金融机构使用国密算法。包括SM1/SM2/SM3/SM4。其中SM4为对称加密算法。SM3是哈希算法。SM2为非对称加密算法。但是国家只给算法原理，没有给出常用的算法实现，所以是件蛋疼的事情。</p>
<p>算法我也没看懂。因为项目中使用到了，所以做了一些研究。相关代码可以参考我的<a href="https://github.com/dishibolei/SM2.git" target="_blank" rel="external">github</a>,IOS SM2开源实现非常少，而且都有些问题，要么基于openSSL，代码特别大。要么基于libtommath库，但是有一些问题，SM2无法调通。所以两个结合重新整理的下代码。这个代码只保证SM2算法有效性，因为经过实际使用过，其他的项目未用到。</p>
<h3 id="SM2的加密流程"><a href="#SM2的加密流程" class="headerlink" title="SM2的加密流程"></a>SM2的加密流程</h3><p><img src="/2017/05/25/save-encode/safe_encode_sm2.jpg" alt=""></p>
<p>抛出掉数学方法，下面是本人的一些理解：</p>
<ol>
<li><p>SM2需要依赖于一个曲线，一般使用国家<a href="http://www.oscca.gov.cn/News/201012/News_1197.htm" target="_blank" rel="external">推荐曲线</a>。如果曲线不对，肯定是无法加解密的。曲线参数</p>
<pre><code class="objc">
<span class="meta">#define SM2_P     <span class="meta-string">"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF"</span></span>
<span class="meta">#define SM2_A     <span class="meta-string">"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC"</span></span>
<span class="meta">#define SM2_B     <span class="meta-string">"28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93"</span></span>
<span class="meta">#define SM2_N     <span class="meta-string">"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123"</span></span>
<span class="meta">#define SM2_G_X   <span class="meta-string">"32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7"</span></span>
<span class="meta">#define SM2_G_Y   <span class="meta-string">"BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0"</span></span>
</code></pre>
</li>
<li>SM2公钥分为两部分：Pub_x和Pub_y。每个都是32字节，总共是64字节。私钥长度现在还不清楚是多少，有资料说是要32位，但是文档里面未提到。字节数如果不对说明生成秘钥算法有问题。</li>
<li>输出数据分为3段：<code>C1C2C3</code>,其中C1是64个字节，C2和原始数据大小相同，即原文是6个字节，C2就是6个字节，C3是32个字节。所以总长度是64+32+原文长度（字节）。如果长度不对，要看下是否是人为添加了其他字段。</li>
<li>算法涉及到哈希算法，标准是使用SM3的hash算法，SM3的Hash算法生成的字节为32字节，这个联调的时候一定要保证一致。</li>
</ol>
<h4 id="加密步骤说明："><a href="#加密步骤说明：" class="headerlink" title="加密步骤说明："></a>加密步骤说明：</h4><ol>
<li>第一步计算随机数，如果这个不是随机的,是固定的，那后面的结果每次输出就是唯一的。</li>
<li>通过随机数rank和曲线的G_x、G_y、P、A五个参数，通过ECC算法<code>C1=[k]G = (x1,y1)</code>生成一个点（x1,y1）。拼接起来就是C1数据。C1数据应该是64个字节。有些算法里面会在前面填充<code>0x04</code>，变成65个字节</li>
<li>通过公钥的P_x和P_y,随机数rank,A,P，通过ECC算法<code>[k]PukeyB = [k](XB,YB) = (x2,y2)</code>计算出(x2,y2)，x2和y2的大小为分别为32字节</li>
<li>将上面的(x2,y2)拼接，然后做KDF（密码派生算法）计算，输出原文长度（klen）的t值。<code>t= KDF(x2||y2, klen)</code>,KDF一般使用的是SM3的算法。结果t的大小和原文的大小一致。</li>
<li>然后将t和原文做异或运算，得到C2,C2的大小和原文一致。</li>
<li>然后将(x2,原文,x3)拼接，计算一次SM3的Hash算法,生成的数据放入C3中，C3的大小为32字节。</li>
<li>最后把<code>C1C2C3</code>拼接到一起，长度为64+原文长度+32字节。注意，<strong>老的标准为<code>C1C3C2</code>,有些实现的是这种模式。</strong></li>
</ol>
<p>注：这其中ECC算法是标准算法，大部分第三方实现的都没有问题。主要是KDF算法和Hash算法会有不同。这个联调的时候需要搞清楚。</p>
<h3 id="SM2解密流程"><a href="#SM2解密流程" class="headerlink" title="SM2解密流程"></a>SM2解密流程</h3><p>流程图如下：</p>
<p><img src="/2017/05/25/save-encode/safe_decode_sm2.jpg" alt=""></p>
<h4 id="解密步骤说明"><a href="#解密步骤说明" class="headerlink" title="解密步骤说明"></a>解密步骤说明</h4><ol>
<li>先判断C1是否在曲线上。C1长度为64字节，取数据的前64字节就可以了。所以两端一定要用同样的曲线。</li>
<li>使用C1的数据,曲线参数（A,P）,私钥dA，使用ECC算法生成(x2,y2)，<code>dA*C1 = dA*(x2,y2) = dA*[k]*(Xg,Yg)</code></li>
<li>使用(x2,y2)和C2的长度（总长度-64-32），使用KDF计算t。</li>
<li>使用c2异或t，达到M’</li>
<li>计算(x2,M’,y2)的hash值U。</li>
<li>比较U和C3数据是否是一致的，如果一致就输出M’</li>
</ol>
<h3 id="KDF算法说明："><a href="#KDF算法说明：" class="headerlink" title="KDF算法说明："></a>KDF算法说明：</h3><p>文档里的描述</p>
<blockquote>
<blockquote>
<p>密钥派生函数的作用是从一个共享的秘密比特串中派生出密钥数据。在密钥协商过程中，密钥派<br>生函数作用在密钥交换所获共享的秘密比特串上，从中产生所需的会话密钥或进一步加密所需的密钥<br>数据。<br>密钥派生函数需要调用密码杂凑函数。<br>设密码杂凑函数为Hv( )，其输出是长度恰为v比特的杂凑值。<br>密钥派生函数KDF(Z, klen)：<br>输入：比特串Z，整数klen(表示要获得的密钥数据的比特长度，要求该值小于(232-1)v)。<br>输出：长度为klen的密钥数据比特串K。<br>a)初始化一个32比特构成的计数器ct=0x00000001；<br>b)对i从1到⌈klen/v⌉执行：<br>b.1)计算Hai=Hv(Z ∥ ct)；<br>b.2) ct++；<br>c)若klen/v是整数，令Ha!⌈klen/v⌉ = Ha⌈klen/v⌉，否则令Ha!⌈klen/v⌉为Ha⌈klen/v⌉最左边的(klen −<br>(v × ⌊klen/v⌋))比特；<br>d)令K = Ha1||Ha2|| · · · ||Ha⌈klen/v⌉−1||Ha!⌈klen/v⌉。</p>
</blockquote>
</blockquote>
<p>简化下说明：</p>
<ol>
<li>先分组,分组的大小为<code>klen/v</code>,向上取整,其中klen是数据长度，v是HASH算法输出长度。SM3的输出长度为32字节。</li>
<li>然后每一组循环，把原始数据Z和计数器ct拼接，做SM3_Hash运算得到Hai。然后计数器ct+1。</li>
<li>最终生成的数据Ha1,Ha2…拼接起来，然后截断到klen长度也就是数据长度。</li>
</ol>
<h3 id="HASH算法说明"><a href="#HASH算法说明" class="headerlink" title="HASH算法说明"></a>HASH算法说明</h3><p>官方使用的是SM3密码杂凑算法，输入为小于2的64次方bit，输出为<strong>256bit（32字节）</strong>。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>国密算法的基础是使用曲线计算。<strong>曲线应该使用官方推荐的曲线</strong>，曲线不同加解密肯定失败。</li>
<li>国密算法生成的数据为<code>C1C2C3</code>,其中C1为固定的64字节，c2和原始数据一样长，C3为固定的32字节。<strong>有些要求数据前面加上’0x04’,旧的版本输出是<code>C3C1C2</code></strong>，这两点要注意。</li>
<li><strong>公钥分为P_x和P_y,都是32字节长度</strong>。私钥长度从资料上看没有限制，是一个随机数[1,N-2]。N为曲线参数。</li>
<li>加密过程中使用了SM3的散列算法(官方叫杂凑算法)，这个算法输出为32字节的数据。如果对端没有用这个算法，两端也无法加解密成功。</li>
</ol>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><ol>
<li>字符编码是为了把可见字符和二进制之间做一层转化。其中UNICODE编码是国际编码标准。UTF-8是这种编码格式的实现方式。特点是ASCII码的字符占用一个字节，其他的比如中文字符占用两到三个字符。</li>
<li>Base64也是一种编码方式，主要用于把二进制数据转化为ASCII字符，方便传输。现在很多加密算法习惯在加密后把二进制数做一次Base64进行传输。相对于原文，长度会多出1/3。也有把二进制转为字符串的形式，不过长度是原文的2倍。</li>
<li>哈希散列算法，主要用于脱敏处理和信息签名防篡改，做哈希运算应该加盐处理。盐值应该是随机值，而且和用户相关，建议使用（随机数 + 用户名）。</li>
<li>对称加密两端秘钥相同，加密速度快，可以加密大数据，但是秘钥保存一直是个难题。</li>
<li>非对称加密分为公钥和私钥，公钥可以公开。加密速度慢，只能加密小数据，但是只需要妥善保存私钥就可以了。</li>
</ol>
<p>通常一个信息加密传输流程为：</p>
<ol>
<li>双方约定好使用的编码格式。通常常用的是UTF-8编码。</li>
<li>客户端随机生成对称秘钥作为会话秘钥。使用非对称加密传输给后端，后端保存这个对称秘钥用于之后的加解密过程。</li>
<li>用户使用对称加密（通常为AES）加密整个数据，结果通常使用Base64做编码（通常还要做一次URLEncode操作）,整个相关数据按照规则使用Hash算法（通常为SHA256算法）做数据签名。最后做传输</li>
<li>如果是用户密码的话建议用HMac做Hash脱敏处理，然后单独使用非对称加密进一步加强安全性。</li>
</ol>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode和UTF-8</a></li>
<li><a href="http://baike.baidu.com/link?url=FjDXJpkvwA7a2I_XBaIBK84bxaJZ6CGSoQDYnmBNf7nsJN867uLnyBptnJ8jkgRo9gpEXvrRgWcc12_rjqn-5q" target="_blank" rel="external">百度百科-ASCII</a></li>
<li><a href="http://www.cnblogs.com/Alandre/p/4878841.html" target="_blank" rel="external">深入浅出大小端</a></li>
<li><a href="http://www.cnblogs.com/BeyondTechnology/archive/2011/03/27/1997165.html" target="_blank" rel="external">Base64 编码</a></li>
<li><a href="http://www.server110.com/sec_news/201309/995.html" target="_blank" rel="external">MD5+Salt安全浅析</a></li>
<li><a href="http://www.atool.org/hash.php" target="_blank" rel="external">哈希加密算法 MD5,SHA-1,SHA-2,SHA-256,SHA-512,SHA-3,RIPEMD-160 - aTool</a></li>
<li><a href="http://www.blogjava.net/wayne/archive/2011/05/23/350879.html" target="_blank" rel="external">DES加密模式详解</a></li>
<li><a href="http://blog.chinaunix.net/uid-29106641-id-4032988.html" target="_blank" rel="external">DES加密算法原理</a></li>
<li><a href="http://www.cnblogs.com/midea0978/articles/1437257.html" target="_blank" rel="external">关于PKCS5Padding与PKCS7Padding的区别</a></li>
<li><a href="http://www.cnblogs.com/sunxuchu/p/5483956.html" target="_blank" rel="external">各种加密算法比较</a></li>
<li><a href="http://tool.chacuo.net/cryptaes" target="_blank" rel="external">AES在线加解密</a></li>
<li><a href="http://www.cnblogs.com/QianChia/p/6246129.html" target="_blank" rel="external">iOS - Safe iOS 加密安全</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">RSA算法原理</a></li>
<li><a href="http://www.oscca.gov.cn/News/201012/News_1197.htm" target="_blank" rel="external">SM2国密算法官方说明</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;导读&lt;br&gt;客户端经常遇到需要对数据进行加密的情况，那应该如何加密，选用什么样的加密算法，是本文想要讨论的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="安全" scheme="https://dishibolei.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://dishibolei.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="iOS" scheme="https://dishibolei.github.io/tags/iOS/"/>
    
      <category term="加解密" scheme="https://dishibolei.github.io/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    
      <category term="字符编码" scheme="https://dishibolei.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
      <category term="大小端" scheme="https://dishibolei.github.io/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
      <category term="国密算法" scheme="https://dishibolei.github.io/tags/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="HASH" scheme="https://dishibolei.github.io/tags/HASH/"/>
    
      <category term="对称加密" scheme="https://dishibolei.github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="非对称加密" scheme="https://dishibolei.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>IOS应用安全-HTTP/HTTPS网络安全(二)</title>
    <link href="https://dishibolei.github.io/2017/05/15/https-safe-2/"/>
    <id>https://dishibolei.github.io/2017/05/15/https-safe-2/</id>
    <published>2017-05-15T04:46:53.000Z</published>
    <updated>2017-05-25T05:36:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>导读</p>
<p>本文主要讲解IOS中ATS相关的配置说明和使用AFNetworking框架来实现证书验证的方法。讲解了AFNetworking各个配置试用的场景和注意点。</p>
</blockquote>
<a id="more"></a>
<h1 id="ATS"><a href="#ATS" class="headerlink" title="ATS"></a>ATS</h1><p>IOS9之后，苹果开启了App Transport Security（简称ATS）特性,即<strong>禁止HTTP请求，必须使用支持</strong>TLS1.2<strong>的HTTPS请求</strong>。但是也支持在Info.plist中做一些配置，来做缓冲。需要在info.plist中加入<code>App Transport Security Settings</code>字段。</p>
<p>plist里面的结构如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAppTransportSecurity</span> : Dictionary &#123;</div><div class="line">    <span class="built_in">NSAllowsArbitraryLoads</span> : Boolean</div><div class="line">    <span class="built_in">NSAllowsArbitraryLoadsForMedia</span> : Boolean</div><div class="line">    <span class="built_in">NSAllowsArbitraryLoadsInWebContent</span> : Boolean</div><div class="line">    <span class="built_in">NSAllowsLocalNetworking</span> : Boolean</div><div class="line">    <span class="built_in">NSExceptionDomains</span> : Dictionary &#123;</div><div class="line">        &lt;domain-name-string&gt; : Dictionary &#123;</div><div class="line">            <span class="built_in">NSIncludesSubdomains</span> : Boolean</div><div class="line">            <span class="built_in">NSExceptionAllowsInsecureHTTPLoads</span> : Boolean</div><div class="line">            <span class="built_in">NSExceptionMinimumTLSVersion</span> : String</div><div class="line">            <span class="built_in">NSExceptionRequiresForwardSecrecy</span> : Boolean   <span class="comment">// Default value is YES</span></div><div class="line">            <span class="built_in">NSRequiresCertificateTransparency</span> : Boolean</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ATS整体配置（NSAllowsArbitraryLoads）"><a href="#ATS整体配置（NSAllowsArbitraryLoads）" class="headerlink" title="ATS整体配置（NSAllowsArbitraryLoads）"></a>ATS整体配置（NSAllowsArbitraryLoads）</h2><ol>
<li><p>配置ATS生效或不生效</p>
<p> 在<code>App Transport Security Settings</code>字段下加入<code>Allow Arbitrary Loads</code>，或<code>NSAllowsArbitraryLoads</code>，配置为NO。PS：如果要禁用则为YES。但是如果配置为YES会导致审核失败，需要单独向APPStrore申诉说明。</p>
</li>
<li><p>配置web(H5)访问限制生效或不生效 </p>
<p>在<code>App Transport Security Settings</code>字段下加入<code>Allow Arbitrary Loads in Web Content</code>或<code>NSAllowsArbitraryLoadsInWebContent</code>，默认配置生效为NO。如果要容许访问任意web网页内容，配置为YES。但是如果配置为YES会导致审核失败，需要单独向APPStrore申诉说明。</p>
</li>
<li><p>配置多媒体访问限制生效或不生效</p>
<p>在<code>App Transport Security Settings</code>字段下加入<code>Allow Arbitrary Loads in Web Content</code>，默认配置生效为NO。设置YES，容许访问通过AVFoundation框架访问媒体内容。</p>
</li>
</ol>
<h2 id="ATS根据域名配置（Exception-Domains）"><a href="#ATS根据域名配置（Exception-Domains）" class="headerlink" title="ATS根据域名配置（Exception Domains）"></a>ATS根据域名配置（Exception Domains）</h2><p>在<code>App Transport Security Settings</code>字段下加入<code>Exception Domains</code>或<code>NSExceptionDomains</code>,<strong>系统优先响应<code>NSExceptionDomains</code>中的配置</strong>。比如之前设置NSAllowsArbitraryLoadsInMedia为 YES，然而NSExceptionDomain所代表的域名，如果没有特殊配置，依然默认不能访问不安全的媒体内容。</p>
<ol>
<li><p>加入域名配置</p>
<p> 在<code>Exception Domains</code>下，添加字典。其中key为域名的名称，比如<code>baidu.com</code>。</p>
</li>
<li><p>容许访问HTTP</p>
<p>在步骤1对应的域名字典下，加入字段<code>NSExceptionAllowsInsecureHTTPLoads</code>.默认为NO，如果设置YES，则容许访问HTTP</p>
</li>
<li><p>容许TLS支持非正向保密算法（Perfect Forward Secrecy）</p>
<p>在步骤1对应的域名字典下，加入字段<code>NSExceptionRequiresForwardSecrecy</code>.默认为YES。如果设置为NO，则支持非正向保密的加密算法。</p>
<p>正向保密算法（Forward Secrecy），指如果通信密钥泄露，使用FS算法，可以保证这个密钥泄露只会影响之后的加密数据，之前的加密数据无法解密。主要防止攻击者保存之前的数据，等到私钥泄露之后再解密数据。这个算法的基础是基于椭圆曲线向前保密的秘钥交换算法ECDHE（Elliptic Curve Diffie-Hellman Ephemeral）。这些算法有：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</div><div class="line">TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</div><div class="line">TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384</div><div class="line">TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</div><div class="line">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</div><div class="line">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</div><div class="line">TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</div><div class="line">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</div><div class="line">TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384</div><div class="line">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</div><div class="line">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</div></pre></td></tr></table></figure>
<p>如果设置为NO，则非正向保密算法，有下面几种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TLS_RSA_WITH_AES_256_GCM_SHA384</div><div class="line">TLS_RSA_WITH_AES_128_GCM_SHA256</div><div class="line">TLS_RSA_WITH_AES_256_CBC_SHA256</div><div class="line">TLS_RSA_WITH_AES_256_CBC_SHA</div><div class="line">TLS_RSA_WITH_AES_128_CBC_SHA256</div><div class="line">TLS_RSA_WITH_AES_128_CBC_SHA</div></pre></td></tr></table></figure>
<p>具体原理参考<a href="http://www.open-open.com/lib/view/open1477548899809.html" target="_blank" rel="external">TLS/SSL 高级进阶</a>。</p>
</li>
<li><p>容许支持低版本的TLS算法。   </p>
<p>在步骤1对应的域名字典下，加入字段<code>NSExceptionMinimumTLSVersion</code>。值为对应的支持的最低版本。包含下面值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TLSv1.0</div><div class="line">TLSv1.1</div><div class="line">TLSv1.2</div></pre></td></tr></table></figure>
</li>
<li><p>包含域名下的所有子域名。</p>
<p>在步骤1对应的域名字典下，加入字段<code>NSIncludesSubdomains</code>。默认为NO。如果配置为YES则包含域名下的所有子域名。</p>
</li>
<li><p>开启Certificate Transparency</p>
<p> 在步骤1对应的域名字典下，加入字段<code>NSRequiresCertificateTransparency</code>,这个默认为NO.如果设为YES，则开启Certificate Transparency。这个是IETF启动的一个开源项目，目的是进一步验证证书是否安全。个人觉得没什么用，没必要开启。</p>
</li>
</ol>
<h2 id="ATS各种字段含义说明"><a href="#ATS各种字段含义说明" class="headerlink" title="ATS各种字段含义说明"></a>ATS各种字段含义说明</h2><p>主要的几个key：</p>
<ul>
<li><p>NSAllowsArbitraryLoads</p>
<blockquote>
<p>默认NO。如果设置为YES，则不生效ATS规则。但是配置在NSExceptionDomains里面的规则，按照里面的规则生效。配置为YES，提交APP Strore需要说明</p>
</blockquote>
</li>
<li><p>NSAllowsArbitraryLoadsForMedia</p>
<blockquote>
<p>默认NO.如果设置为YES，那使用AVFoundation加载资源不生效ATS。</p>
</blockquote>
</li>
<li><p>NSAllowsArbitraryLoadsInWebContent</p>
<blockquote>
<p>默认NO.如果设置为YES.使用webview加载的页面资源不生效ATS。</p>
</blockquote>
</li>
<li><p>NSExceptionDomains</p>
<blockquote>
<p>用于单独配置其他域名ATS策略的键。值应该是字典类型。</p>
</blockquote>
</li>
</ul>
<p>下面是NSExceptionDomains相关的key</p>
<ul>
<li><p>NSIncludesSubdomains</p>
<blockquote>
<p>默认NO。如果设置为YES，则生效此域名下的子域名</p>
</blockquote>
</li>
<li><p>NSExceptionAllowsInsecureHTTPLoads</p>
<blockquote>
<p>默认NO。如果设置为YES，则容许HTTP请求。设置YES，在审核时需要提供说明。</p>
</blockquote>
</li>
<li><p>NSExceptionMinimumTLSVersion</p>
<blockquote>
<p>默认TLSv1.2。可以设置为：TLSv1.0、TLSv1.1。在审核时需要提供说明</p>
</blockquote>
</li>
<li><p>NSExceptionRequiresForwardSecrecy</p>
<blockquote>
<p>默认YES。设置为NO标示不支持正向保密。</p>
</blockquote>
</li>
<li><p>NSRequiresCertificateTransparency</p>
<blockquote>
<p>默认NO。如果设置为YES，开启Certificate Transparency。</p>
</blockquote>
</li>
</ul>
<p>上面的是方便本人查找，详细设置case也可以参考[ATS 官方文档] (<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35</a>)<br>。目前过渡阶段最多出现的是第三方不兼容的问题+不支持NSExceptionRequiresForwardSecrecy+TLS版本不到1.2+h5访问的链接不支持ATS。按照要求配置就可以了，最重要的是推动第三方和自己后台使用HTTPS。自己的后台如果要求不高，可以用自制证书。</p>
<p>推荐的一个配置：</p>
<p>自己的域名使用最安全的方案，防止被苹果拒绝。第三方可以按照需求配置，但是审核时也建议进一步说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">NSAppTransportSecurity</div><div class="line">    NSExceptionDomains</div><div class="line">        &quot;domain-i-control.example.com&quot; // 后台的域名</div><div class="line">            NSExceptionAllowsInsecureHTTPLoads = NO //不容许HTTP</div><div class="line">            NSExceptionRequiresForwardSecrecy = YES //支持正向加密</div><div class="line">            NSExceptionMinimumTLSVersion = &quot;TLSv1.2&quot; //使用1.2版本</div><div class="line">            NSIncludesSubdomains = YES //包含子域名</div><div class="line">        &quot;other-domain-i-control.example.com&quot; //部分不支持的第三方域名</div><div class="line">            NSExceptionAllowsInsecureHTTPLoads = NO  //支持http</div><div class="line">            NSExceptionRequiresForwardSecrecy = YES  //不支持正向加密</div><div class="line">            NSExceptionMinimumTLSVersion = &quot;TLSv1.0&quot; //第三方支持的TLS版本</div><div class="line">    NSAllowsArbitraryLoads = NO</div></pre></td></tr></table></figure>
<h1 id="使用AFNetworking配置HTTPS安全"><a href="#使用AFNetworking配置HTTPS安全" class="headerlink" title="使用AFNetworking配置HTTPS安全"></a>使用AFNetworking配置HTTPS安全</h1><p>AFNetworking是最常用的网络框架。所以以这个为基础说明一些配置信息。本人是使用2.6版本的。3.x版本和2.6相比安全验证的逻辑没有变化，可以参考。2.6之前的版本，建议所有配置项显示配置，不要用默认配置（因为有个版本有漏洞，默认不校验域名）。下面先讲解下配置参数，清楚之后再讲解代码实现。</p>
<h2 id="AFSecurityPolicy说明"><a href="#AFSecurityPolicy说明" class="headerlink" title="AFSecurityPolicy说明"></a>AFSecurityPolicy说明</h2><p>AFNetworking使用<code>AFSecurityPolicy</code>类来管理安全策略。</p>
<p>主要的属性和方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFSSLPinningMode SSLPinningMode; <span class="comment">//证书验证的策略</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowInvalidCertificates; <span class="comment">//是否容许无效的证书</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> validatesDomainName; <span class="comment">//是否验证证书的域名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSArray</span> *pinnedCertificates; <span class="comment">//app自己导入的证书文件，默认情况下主bundle里面的.cer文件都会导入到这个数组里。</span></div></pre></td></tr></table></figure>
<h3 id="validatesDomainName-说明"><a href="#validatesDomainName-说明" class="headerlink" title="validatesDomainName 说明"></a>validatesDomainName 说明</h3><p>是否容许证书包含的域名和实际访问的域名不匹配，默认为YES。采用的策略为：</p>
<ol>
<li>如果validatesDomainName == YES，则开启域名验证。如果allowInvalidCertificates == NO，则不容许所用的证书里面的域名和实际域名不一致。如果allowInvalidCertificates == YES，则忽略域名验证，直接按照AFSSLPinningMode方式验证。</li>
<li>如果validatesDomainName == NO,则不对证书做域名验证。</li>
</ol>
<h3 id="allowInvalidCertificates-说明"><a href="#allowInvalidCertificates-说明" class="headerlink" title="allowInvalidCertificates 说明"></a>allowInvalidCertificates 说明</h3><p>是否容许无效证书，默认为NO。采用的策略为：</p>
<ol>
<li>如果allowInvalidCertificates == YES，则容许使用自制证书，或容许CA颁发的证书或系统信任的第三方证书（比如手动信任Charles证书）无效（包括域名无效和超过有效期）</li>
<li>如果allowInvalidCertificates == NO，那无法使用自制证书，且不容许CA颁发的证书或系统信任的第三方证书（比如手动信任Charles证书）超过有效期。如果配置了validatesDomainName == YES，则容许证书的域名不匹配，否则也不容许域名不匹配。</li>
</ol>
<h3 id="SSLPinningMode-说明"><a href="#SSLPinningMode-说明" class="headerlink" title="SSLPinningMode 说明"></a>SSLPinningMode 说明</h3><p>证书文件实体验证策略，默认为AFSSLPinningModeNone。AFSSLPinningMode包括的值为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</div><div class="line">    AFSSLPinningModeNone,</div><div class="line">    AFSSLPinningModePublicKey,</div><div class="line">    AFSSLPinningModeCertificate</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>AFSSLPinningModeNone。AFNetworking默认配置模式。采用的策略为：<ol>
<li>如果容许无效证书（allowInvalidCertificates == YES），则直接返回验证成功（YES）</li>
<li>如果不容许无效证书（allowInvalidCertificates == YES），则验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。 </li>
</ol>
</li>
<li>AFSSLPinningModePublicKey。验证证书公钥模式。采用的策略为：<ol>
<li>如果容许无效证书（allowInvalidCertificates == YES），则比对服务端发来的证书链中的公钥和自己加入的所有证书的的公钥是否匹配，只要有一个证书匹配就返回成功。</li>
<li>如果不容许无效证书（allowInvalidCertificates == YES），则先验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。验证通过后，则比对服务端发来的证书链中的公钥和自己加入的所有证书的的公钥是否匹配，只要有一个证书匹配就返回成功。   </li>
</ol>
</li>
<li>AFSSLPinningModeCertificate。证书完全匹配模式。采用的策略为：<ol>
<li>如果容许无效证书（allowInvalidCertificates == YES），则将自己导入的所有证书作为锚点，判断服务端是否有效。如果有效，判断服务端证书链中的证书中，是否有证书包含在导入的证书里（使用二进制比较，也就是必须完全一样）。</li>
<li>如果不容许无效证书（allowInvalidCertificates == YES），则先验证证书是否有效：是否是CA颁发机构颁发的或者是否是系统信任的第三方证书（比如手动信任Charles证书）。如果另外配置了validatesDomainName == YES，则需要证书对应的域名是否匹配。如果配置了validatesDomainName == NO,则不验证证书对应的域名是否匹配。验证通过后，则将自己导入的所有证书作为锚点，判断服务端证书是否有效。如果有效，判断服务端证书链中的证书中，是否有证书包含在导入的证书里（使用二进制比较，也就是必须完全一样）。</li>
</ol>
</li>
</ul>
<p>上面的比较绕，其实就是三个配置的组合。下面把这几种组合起来，看看验证了什么，使用于什么策略。其中AC表示allowInvalidCertificates，VD表示validatesDomainName。需要的可以去查这个表来决定方案。</p>
<style>table th:first-of-type {width: 10px;} th:nth-of-type(2) {width: 70px;} th:nth-of-type(3) {width: 20px;} th:nth-of-type(4) {width: 40px;}</style>

<table>
<thead>
<tr>
<th>场景</th>
<th>mode</th>
<th>AC</th>
<th>VD</th>
<th>验证策略</th>
<th>适用场景</th>
<th>不适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>None</td>
<td>NO</td>
<td>YES</td>
<td><div>1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书</div><div>2.验证证书是否过期</div><div>3.验证证书域名是否匹配</div></td>
<td><div>1.AF默认的安全策略</div><div>2.对于安全有基础的要求</div><div>3.使用CA机构颁发的证书</div></td>
<td><div>1.使用自制证书的</div> <div>2.不容许使用第三方抓包工具抓包的应用</div></td>
</tr>
<tr>
<td>2</td>
<td>None</td>
<td>NO</td>
<td>NO</td>
<td><div>1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书</div><div>2.验证证书是否过期</div></td>
<td>1.证书是正规CA颁发的。但是使用的域名不是证书中的域名</td>
<td><div>1.存在风险，会导致攻击方使用自己的合法的CA证书进行攻击</div> <div>2.使用自制证书的</div> <div>3.不容许使用第三方抓包工具抓包的应用</div></td>
</tr>
<tr>
<td>3</td>
<td>None</td>
<td>YES</td>
<td>YES /NO</td>
<td>不对证书做任何验证</td>
<td>请勿使用这儿配置。 1.对安全没有要求的</td>
<td>1.对安全有要求的</td>
</tr>
<tr>
<td>4</td>
<td>PublicKey</td>
<td>NO</td>
<td>YES</td>
<td><div>1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书</div>2.验证证书是否过期 <div>3.验证证书域名是否匹配</div><div>4.验证证书和埋入的证书的公钥是否一致</div></td>
<td><div>1.证书是正规CA颁发的。</div>2.对安全有比较高的需求 <div>3.需要本地APP中导入证书</div> <div>4.禁止第三方工具抓包</div> <div>5.证书过期后只要保证公钥一致，就可以保证请求有效</div></td>
<td><div>1.使用自制证书的</div>2.害怕攻击者拿到私钥或公钥文件，伪造证书（概率极低，因为需要CA机构再签发） <div>3.证书过期需要更换，但是新旧证书公钥不同</div></td>
</tr>
<tr>
<td>5</td>
<td>PublicKey</td>
<td>NO</td>
<td>NO</td>
<td><div>1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书</div> <div>2.验证证书是否过期</div> <div>3.验证证书和埋入的证书的公钥是否一致</div></td>
<td><div> 1.证书是正规CA颁发的。</div> <div>2.需要本地APP中导入证书</div> <div>3.禁止第三方工具抓包</div> <div>4.使用的域名和证书域名不一致</div> <div>5.证书过期后只要保证公钥一致，就可以保证请求有效</div></td>
<td><div>1.使用自制证书的<div> <div>2.害怕攻击者拿到私钥或公钥文件，伪造证书（概率极低，因为需要CA机构再签发）<div> <div>3.证书过期需要更换，但是新旧证书公钥不同<div></div></div></div></div></div></div></td>
</tr>
<tr>
<td>6</td>
<td>PublicKey</td>
<td>YES</td>
<td>YES/NO</td>
<td><div>1.验证证书和埋入的证书公钥是否一致<div></div></div></td>
<td><div>1.使用自制证书 </div>  <div>2.需要本地APP中导入证书 </div>  <div>3.禁止第三方工具抓包 </div>  <div>4.不需要关心证书的有效期 </div></td>
<td><div>1.攻击者可以拿到私钥或公钥文件，伪造证书。相对于场景4和5，更容易攻击一些。 </div> <div> 2.攻击者可以用不在有效期的证书对进行攻击</div></td>
</tr>
<tr>
<td>7</td>
<td>Certificate</td>
<td>NO</td>
<td>YES</td>
<td><div>1.验证证书域名是否匹配</div><div>2.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书</div><div>3.验证证书是否过期</div><div>4.验证证书和埋入的证书是否完全一致</div></td>
<td><div>1.证书是正规CA颁发的。</div><div>2.对安全有最高的需求</div><div>3.需要本地APP中导入证书</div><div>4.禁止第三方工具抓包</div></td>
<td><div>1.需要考虑证书更新的场景</div> <div>2.证书如果失效，客户端网络请求将会失效</div> <div>3.自制证书</div></td>
</tr>
<tr>
<td>8</td>
<td>Certificate</td>
<td>NO</td>
<td>NO</td>
<td><div>1.验证证书是否为信任的颁发机构颁发或是否为用户手动信任的证书</div><div>2.验证证书是否过期</div><div>3.验证证书和埋入的证书是否完全一致</div></td>
<td><div>1.证书是正规CA颁发的。</div><div>2.对安全有最高的需求</div><div>3.需要本地APP中导入证书</div><div>4.禁止第三方工具抓包</div><div>5.证书域名和实际域名不一致</div></td>
<td><div>1.需要考虑证书更新的场景</div><div>2.证书如果失效，客户端网络请求将会失效</div><div>3.自制证书</div><div>4.攻击者拿到公私钥的前提下，可以利用不校验域名，攻击或重定向其他域名。</div></td>
</tr>
<tr>
<td>9</td>
<td>Certificate</td>
<td>YES</td>
<td>YES</td>
<td><div>1.验证证书的域名是否匹配？</div> <div>2.验证证书是否过期？</div> <div>3.验证证书和埋入的证书是否完全一致</div></td>
<td><div>1.使用自制证书</div><div>2.需要本地APP中导入证书</div><div>3.禁止中间人攻击</div></td>
<td><div>1.需要考虑证书更新的场景</div><div>2.证书如果失效，客户端网络请求将会失效</div><div>3.无法作废不安全的证书。在攻击者拿到公私钥的前提下,可以监听数据。</div></td>
</tr>
<tr>
<td>10</td>
<td>Certificate</td>
<td>YES</td>
<td>NO</td>
<td><div>1.验证证书是否过期？</div><div>2.验证证书和埋入的证书是否完全一致</div></td>
<td><div>1.使用自制证书</div><div>2.需要本地APP中导入证书</div><div>3.禁止禁止中间人攻击</div></td>
<td><div>1.需要考虑证书更新的场景</div><div>2.证书如果失效，客户端网络请求将会失效</div><div>3.攻击者拿到公私钥的前提下，可以利用不校验域名，定位到其他域名。</div></td>
</tr>
</tbody>
</table>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>下面是一些疑问：</p>
<ol>
<li><p>如何选择合适的方案?</p>
<blockquote>
<ol>
<li>建议对安全没有特别要求的或在测试环境下方便抓包，采用默认规则就可以了，重要的数据单独做加密。即选场景1</li>
<li>要校验域名，即：validatesDomainName不要设置为NO。如果设为NO，不校验域名，也最好自己加一层验证方法。</li>
<li>如果是自制证书，allowInvalidCertificates设置为YES。如果是ca颁发的证书则建议设置为YES。</li>
<li>无论是使用AFSSLPinningModePublicKey还是AFSSLPinningModeCertificate都应该考虑证书失效需要更换的问题。</li>
<li>如果用AFSSLPinningModePublicKey方式，使用场景6只要<strong>保证后续更换的证书公钥不变化就可以了</strong>。个人觉得是安全和方便性最平衡的一种模式，只要私钥不泄露就可以了。这个要求公司的证书管理机构知道这点，不过如果出了意外，也可以延缓部署。</li>
<li>最安全的方案是7。也就是强校验，漏洞最少，安全防护最高。但是必须考虑证书失效更换的问题。</li>
</ol>
</blockquote>
</li>
<li><p>如何防止证书过期导致不过的问题？<br>有以下方案：</p>
<blockquote>
<ol>
<li>可以用场景6，<strong>保证后续更换的证书公钥不变化就可以了</strong></li>
<li>APP强制升级，全局通知，热更新等保护通道，建议不要使用强校验策略，使用强的加密手段保证安全，作为最后手段。</li>
<li>加入证书更新的通道，每次应用启动的时候访问，查看是否有证书更新，如果有就去下载证书。</li>
</ol>
</blockquote>
</li>
<li><p>证书更新有什么方案？</p>
<blockquote>
<ol>
<li>建议启动检查是否有证书更新，可以合并在检查APP更新或热更新里面。</li>
<li>发现有更新的时候，服务端把证书二进制数据转为16进制字符串下发给客户端。服务端对数据使用私钥签名，客户端使用公钥对数据进行验签。</li>
<li>客户端将下载的文件按照签名等规则保存。下次加载前，继续对文件验证签名，保证没有篡改。</li>
</ol>
</blockquote>
</li>
<li><p>对于场景9，容许无效的证书，使用AFSSLPinningModeCertificate模式，为什么说明里面还说会验证证书过期？</p>
<blockquote>
<p>我个人也不确定，但是这个模式在加入证书锚点后，代码里还是会调用<code>AFServerTrustIsValid()</code>方法，然后再匹配证书数据是否一致。这个<code>AFServerTrustIsValid()</code>最终调用的是系统验证的方法，不确定系统是否还是会验证有效期，还是只验证包含证书就可以了，目前没有手段验证，大概率认为系统还是会验证是否过期。所以相对来说验证AFSSLPinningModePublicKey需要考虑更新的情况更少。</p>
</blockquote>
</li>
<li><p>如果使用AFSSLPinningModePublicKey模式，更换证书怎么保证公钥不变？</p>
<blockquote>
<p>参考上一篇文章的附录，有一步是使用私钥<code>.key</code>文件生成<code>.csr</code>。只要<code>.key</code>和<code>.csr</code>，下次签发的时候直接用这两文件，签发就可以了。这样能保证下次的证书公钥也不变化。建议生产私钥的时候使用位数在2048位以上，可以保证安全性。</p>
</blockquote>
</li>
</ol>
<h2 id="代码具体实现"><a href="#代码具体实现" class="headerlink" title="代码具体实现"></a>代码具体实现</h2><h3 id="导出证书"><a href="#导出证书" class="headerlink" title="导出证书"></a>导出证书</h3><p>建议向自己公司的网络管理员导出对应的crt文件。或者使用命令：</p>
<p><code>openssl s_client -connect www.google.com:443 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer  //获取www.google.com:443的ssl证书，地址可以换成自己的</code></p>
<p>建议最好导出根证书的crt文件。因为根证书crt文件有效期长，很少更换。</p>
<p>如果是crt格式，使用时需要转化为cer格式。两种转化方式都可以：</p>
<ol>
<li><p>命令行 <code>openssl x509 -in 你的证书.crt -out 你的证书.cer -outform der</code></p>
</li>
<li><p>通过电脑导出。</p>
<ul>
<li>双击crt，安装到钥匙链中。</li>
<li>钥匙链中选中需要导出的证书，鼠标右键，菜单中选择&gt;&gt;导出，点击存储即可。</li>
</ul>
</li>
</ol>
<p>然后将.cer文件导入到工程中。注意选<code>Copy items if needed</code> .</p>
<p><img src="/2017/05/15/https-safe-2/safe_af_ssl.png" alt="https-safe-2/safe_af_ss"></p>
<h3 id="设置生效规则"><a href="#设置生效规则" class="headerlink" title="设置生效规则"></a>设置生效规则</h3><p>代码实现其实非常简单，重要的是规则的设置，建议认真搞清楚上面讲的配置说明，然后再配置。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置模式</span></div><div class="line"> AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</div><div class="line"> <span class="comment">//设置是否验证域名，不建议设置为NO</span></div><div class="line"> policy.validatesDomainName = <span class="literal">YES</span>;</div><div class="line"> <span class="comment">//设置是否容许无效的证书，自制证书选YES</span></div><div class="line"> policy.allowInvalidCertificates = <span class="literal">NO</span>;</div><div class="line"></div><div class="line"> </div><div class="line"> <span class="comment">//AF如果模式为AFSSLPinningModeCertificate或AFSSLPinningModePublicKey会默认导入mainBundle里的所有cer文件，如果没有特别需求，没必要实现下面加载cer的代码</span></div><div class="line"> <span class="comment">//先导入证书路径</span></div><div class="line"> <span class="built_in">NSString</span> *cerPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"myCer"</span> ofType:<span class="string">@"cer"</span>];<span class="comment">//证书的路径</span></div><div class="line"> <span class="comment">// 有多个加多个</span></div><div class="line"> <span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:cerPath];</div><div class="line"> policy.pinnedCertificates = @[certData];</div><div class="line"></div><div class="line">  </div><div class="line"> AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line"> <span class="comment">//生效policy</span></div><div class="line"> manager.securityPolicy = policy;</div><div class="line"> </div><div class="line"> <span class="comment">//调用</span></div><div class="line"> <span class="built_in">NSString</span> *host = <span class="string">@"exmple"</span>;</div><div class="line"> <span class="built_in">NSDictionary</span> *params = @&#123;&#125;;</div><div class="line"> [manager GET:host</div><div class="line">   parameters:params</div><div class="line">      success:^(AFHTTPRequestOperation *_Nonnull operation, <span class="keyword">id</span> _Nonnull responseObject) &#123;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"> failure:^(AFHTTPRequestOperation *_Nonnull operation, <span class="built_in">NSError</span> *_Nonnull error)&#123;</div><div class="line">          _hasUpdating = <span class="literal">NO</span>;</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>具体配置请参考上面AFSecurityPolicy的介绍。通常测试环境下使用默认模式，其他环境使用校验模式。</p>
<h2 id="验证策略源码解读"><a href="#验证策略源码解读" class="headerlink" title="验证策略源码解读"></a>验证策略源码解读</h2><p>AF 2.6版本，在系统框架需要进行证书验证的时候会调用AFURLCOnnectionOpeation.m中的<code>evaluateServerTrust:forDomain</code>方法： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</div><div class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</div><div class="line">&#123;</div><div class="line">    <span class="comment">//自制证书且验证域名不能用AFSSLPinningModeNone模式</span></div><div class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</div><div class="line">        <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></div><div class="line">        <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></div><div class="line">        <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></div><div class="line">        <span class="comment">//  there is nothing to evaluate against.</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="comment">//  From Apple Docs:</span></div><div class="line">        <span class="comment">//          "Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></div><div class="line">        <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors."</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</div><div class="line">        <span class="comment">//如果要验证域名需要把域名加入到规则里</span></div><div class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//设置验证规则，如果有域名验证就加入域名验证</span></div><div class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">        <span class="comment">//AFSSLPinningModeNone下，如果容许无效证书或者证书通过验证就返回成功，否则返回失败</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</div><div class="line">        <span class="comment">//其他模式，如果没有容许无效证书，就做证书验证，失效了就返回失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//抽取服务端的所有证书链数据</span></div><div class="line">    <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</div><div class="line">            <span class="comment">//不会进入到这个case</span></div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//将导入的证书加入到锚点里</span></div><div class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// PS:查看相关文档发现，如果只调用了SecTrustSetAnchorCertificates而没有调用SecTrustSetAnchorCertificatesOnly(serverTrust,false)方法，会导致只信任SecTrustSetAnchorCertificatesOnly设置的锚点的证书，不信任系统默认内置的锚点证书</span></div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</div><div class="line"></div><div class="line">            <span class="comment">//验证是否证书是否在加入的锚点证书列表里。猜测会验证证书的有效期，如果有域名验证，验证域名。</span></div><div class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//查看证书链中的证书是否和埋入的证书完全一致。</span></div><div class="line">            <span class="built_in">NSUInteger</span> trustedCertificateCount = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> serverCertificates) &#123;</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                    trustedCertificateCount++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> trustedCertificateCount &gt; <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</div><div class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</div><div class="line">            <span class="comment">//从证书链中抽取所有公钥列表</span></div><div class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line">            <span class="comment">//验证证书链中的公钥是否在导入的证书里面的公钥链中</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</div><div class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面实际验证是否有效的方法为：<code>AFServerTrustIsValid(SecTrustRef serverTrust)</code>。实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</div><div class="line">    <span class="built_in">BOOL</span> isValid = <span class="literal">NO</span>;</div><div class="line">    SecTrustResultType result;</div><div class="line">    <span class="comment">// 具体实现，因为看不到源码无法确认，应该是标准的证书链验证方式，验证证书有效性，验证证书链的对应的CA根证书是否在颁发机构里或者是否是用户手动同意或拒绝的证书。如果设置了SecTrustSetAnchorCertificates,则验证是否在SecTrustSetAnchorCertificates方法设置的锚点证书里（不包含系统的证书）</span></div><div class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _<span class="keyword">out</span>);</div><div class="line"></div><div class="line">    <span class="comment">//kSecTrustResultUnspecified:证书通过验证，但用户没有设置这些证书是否被信任</span></div><div class="line">    <span class="comment">//kSecTrustResultProceed:证书通过验证，用户有操作设置了证书被信任，例如在弹出的是否信任的alert框中选择always trust</span></div><div class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</div><div class="line"></div><div class="line">_<span class="keyword">out</span>:</div><div class="line">    <span class="keyword">return</span> isValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="WebView进行证书验证"><a href="#WebView进行证书验证" class="headerlink" title="WebView进行证书验证"></a>WebView进行证书验证</h1><p>如果不配置，webview执行系统默认的策略。因为项目中没用到，暂时不敢评判，下面是相关<a href="http://www.cnblogs.com/lijizhuang/p/4884868.html" target="_blank" rel="external">博客</a>供参考。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="http://www.jianshu.com/p/36ddc5b009a7" target="_blank" rel="external">iOS 10 适配 ATS（app支持https通过App Store审核）</a></li>
<li>[ATS 官方文档] (<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35</a>)</li>
<li><a href="https://www.zhihu.com/question/25912483" target="_blank" rel="external">RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密?</a></li>
<li><a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/" target="_blank" rel="external">iOS安全系列之二：HTTPS进阶</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导读&lt;/p&gt;
&lt;p&gt;本文主要讲解IOS中ATS相关的配置说明和使用AFNetworking框架来实现证书验证的方法。讲解了AFNetworking各个配置试用的场景和注意点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://dishibolei.github.io/categories/iOS/"/>
    
      <category term="安全" scheme="https://dishibolei.github.io/categories/iOS/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://dishibolei.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="HTTPS" scheme="https://dishibolei.github.io/tags/HTTPS/"/>
    
      <category term="iOS" scheme="https://dishibolei.github.io/tags/iOS/"/>
    
      <category term="ATS" scheme="https://dishibolei.github.io/tags/ATS/"/>
    
      <category term="AFNetworking" scheme="https://dishibolei.github.io/tags/AFNetworking/"/>
    
  </entry>
  
  <entry>
    <title>IOS应用安全-HTTP/HTTPS网络安全(一)</title>
    <link href="https://dishibolei.github.io/2017/05/11/https-safe-1/"/>
    <id>https://dishibolei.github.io/2017/05/11/https-safe-1/</id>
    <published>2017-05-11T07:21:51.000Z</published>
    <updated>2017-05-19T03:28:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>导读：</p>
<p>本文主要讲在HTTP和HTTPS实际开发中有用和有意思的地方，希望读者能够有所启发。</p>
<p>主要包括：HTTP和HTTPS的简单介绍。介绍HTTPS加密逻辑。介绍SSL证书和SSL证书校验的规则。</p>
<p>本文简化了相关的技术细节，主要关注于前端开发需要关注的点和可以借鉴的地方，希望能对开发能有所帮助。开发更关心的技术代码实现细节，会单独文章中说明。</p>
</blockquote>
<a id="more"></a>
<h1 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h1><p>具体细节可以参考后面的参考文献，只写我觉得有意思和实际中可以参考的地方。</p>
<ol>
<li><p>HTTP协议构建于TCP之上。意味着http是可靠的数据传输。所以不用担心丢包和乱序的问题。</p>
</li>
<li><p>HTTP协议是基于请求和响应的协议。与之对比MQTT协议是基于订阅的协议。</p>
<p> 比如我想要一个资源的种子，如果知道哪个老司机有，我直接问他，他有就给我，没有也告诉我没有。这种模式就是请求和响应，好处是一对一，可以<strong>准确完整的按照自己的需求拿到需要的数据</strong>，但是坏处是消息会滞后，我想知道老司机后面是不是有资源了，我就只能一遍遍重复的问，直到拿到想要的结果为止（循环延迟请求，之前专门写个looperRequest就是为了解决这种问题）。</p>
<p> 另外一种方案，我发布消息到一个论坛，然后留下邮箱，求好人一生平安。然后很多好人有资源就发给我，这样也能拿到数据。这种模式就是订阅模式，好处是可以一对多，可以<strong>快速实时拿到数据</strong>。但是<strong>坏处是：需要长链接</strong>，且推送消息时不清楚客户端的状态，推送的东西不一定需要，比如这个种子可能我已经有了，再发给我就浪费大家的流量了。</p>
<p> 总结下。利用请求应答的模式，可以快速的和服务端同步数据，保证当前请求数据的有效性，有时候我们也叫拉（pull）数据。订阅模块可以快速的更新需要保证实时性的数据，比如聊天数据，交易结果，账户异常，有时候我们也叫推送（push）数据。</p>
<p> 这两种方案是和服务端常用的两种交互方案，有些交互可以考虑两者结合的方式解决。比如之前项目中解决聊天数据的实时有效性，就采用后端推送当前有新消息或其他状态信息，前端收到状态信息后，主动拉取消息到本地，既能保证能够快速更新消息或状态，又能通过本地的状态，按照需求拉取需要的消息。</p>
<p> 推/拉这种设计思路也可以用于应用间的数据同步，应用于模块间数据通信来进行模块解耦等。现在的项目工程模块化设计方案也借鉴了这两种思想。</p>
</li>
<li><p>URL。URL定义了一个资源的地址。大部分格式如下</p>
<p> <code>protocol :// hostname[:port] / abs_path / [;parameters][?query]#fragment</code></p>
<p> 详细说明<a href="http://baike.baidu.com/link?url=9uGFzaUuMRGf4Nn-ucSUqrSYI4vwDls4jVrxZ_7iHZqCnp7FJJTW1ZGp8lzyJ28m9uweSaN6CREycgIObuspD7UQeq1_WlQjnbEzvpjBBK7" target="_blank" rel="external">参考</a></p>
<p> 其中query用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。例如：<code>http://www.joes.com/inventory-check.cgi?item=12731&amp;color=blue</code>。唯一需要注意的是，URL里面不容许有非ASCII字符（常见的就是汉字），也不容许有保留字符比如：<code>!*&#39;\&quot;();:@&amp;=+$,/?%#[]%</code>,所以通常拼接请求时（GET），需要对传进来的参数做<strong>一次URLEncode</strong>操作。</p>
<p> <strong>可以参考这个做私有协议跳转，比如push消息协议，模块跳转协议，外部跳转协议等。</strong></p>
</li>
</ol>
<ol>
<li><p>http请求由三部分组成，分别是：请求行、消息报头、请求正文.详细的建议使用charles抓一个请求看下就知道了。</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_http_header_struct.png" alt=""> </p>
<p>注：来源于<a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="external">http://www.cnblogs.com/ranyonsue/p/5984001.html</a>.</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_http_header1.png" alt=""></p>
<p>重要的几个请求报头字段：</p>
<ul>
<li>Accept: 指定客户端接受的消息类型（通常没人使用,因为客户端大量使用json做数据解析）</li>
<li>Host:请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</li>
<li>User-Agent:用于附加操作系统名称和浏览器版本，通常给H5使用的，UA很容易被修改，项目中有遇到修改UA导致H5页面识别不出来当前操作系统和版本的问题，遇到这种可以查下UA被谁篡改了。</li>
<li>Referer:用于标示请求来源，一般用于防盗链，这个实际中也遇到过。</li>
</ul>
</li>
<li><p>http的响应一般由三个部分组成，分别是:状态行，消息报头，响应正文。</p>
<p> <img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_http_response_struct.jpg" alt=""><br> 注：来源于<a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="external">http://www.cnblogs.com/ranyonsue/p/5984001.html</a>.</p>
<p> 重要的几个消息报头</p>
<ul>
<li>Content-Type 正文媒体类型和编码格式，比如：<code>Content-Type:text/html;charset=ISO-8859-1</code>.Content-Type这个字段被AFNetworking框架用于决定用什么解析器，注意后端不要配置错了。charset被用于AFNetworking字符解码，也应该前后端配置正确。这个配置不正确是经常联调不过的原因。 具体实现参考<code>AFURLResonseSerialization.m</code>。</li>
<li>Content-Length 用于表示正文长度，下载长资源时，需要使用这个字段来计算进度，也可以用这个字段推算下载流量。</li>
<li>Content-Encoding 通常用于记录压缩方法，比如：<code>gzip</code>。</li>
</ul>
</li>
<li><p>GET和POST的方法。HTTP有定义了几种常用的方法，不过通常前端只和这两个打交道。这两个区别：</p>
<ul>
<li>通常认为get是获取消息，不改变数据，post是用来改变数据，不过实际中，并不是那么明确。</li>
<li>get参数是附在URL链接上的，参数拼接前需要做URLEncode，post是附在请求正文里的,格式为key=value，使用&amp;分割，所以对传入数据也要做URLEncode，拼接后和头部用回车换行隔开。</li>
<li>get的URL长度有一定限制，不过也取决于系统支持，具体长度需要实际调研，ie的限制为2083字节，post理论上不存在长度限制。</li>
<li>安全性，post相对安全，get相对不安全。不过post属于防君子不防小人的那种，实际没有什么安全可言。<br>所以综合来说，如果没有技术洁癖，建议都用post处理。</li>
</ul>
</li>
<li><p>上传图片等二进制资源。上传资源一般是post协议，但是通常post是用于传送文本的，如何传图片等资源呢？就需要<code>multipart</code>协议了。</p>
<p> mutipart和普通的post有两点不同：请求头，请求报文。其中关键字是<code>boundary</code>这个属性。</p>
<ul>
<li>请求头： 必须包含<code>content-Type</code>，且值为：<code>multipart/form-data;boundary=${bond}</code>,其中${bound}为具体分割符，在AFNetworking中，如果不指定是<code>Boundary+${random}</code>。</li>
<li>请求体:内容不再是用name=value的形式，而是使用上面的boundary进行分割的一段一段的结构体。具体示例：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">POST /btoa/work/common/uploadImage HTTP/<span class="number">1.1</span></div><div class="line">Host: www.example.com</div><div class="line">Content-Type: multipart/form-data; boundary=Boundary+<span class="number">49</span>F77F66A65EEA58</div><div class="line">Cookie: BIGipServerPOOL_PACLOUD_STGR2016080900646=<span class="number">1274288556.52384</span><span class="number">.0000</span>; FF_SESSION2_ID=Sf503bee3691b4a31a53c6e3c5ae1c1f00912e8</div><div class="line">Connection: keep-alive</div><div class="line">Accept: *<span class="comment">/*</span></div><div class="line">User-Agent: FFProject/2.0.0 (iPhone; iOS 10.3.1; Scale/3.00)</div><div class="line">Accept-Language: zh-Hans-CN;q=1, th-TH;q=0.9</div><div class="line">Content-Length: 418864</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line"></div><div class="line">--Boundary+49F77F66A65EEA58</div><div class="line">Content-Disposition: form-data; name="ffAppID"</div><div class="line"></div><div class="line">10004</div><div class="line">--Boundary+49F77F66A65EEA58</div><div class="line">Content-Disposition: form-data; name="imageSeq"</div><div class="line"></div><div class="line">1</div><div class="line">--Boundary+49F77F66A65EEA58</div><div class="line">Content-Disposition: form-data; name="imageType"</div><div class="line"></div><div class="line">5</div><div class="line">--Boundary+49F77F66A65EEA58</div><div class="line">Content-Disposition: form-data; name="image"; filename="xxxx.jpg"</div><div class="line">Content-Type: image/jpeg</div><div class="line"></div><div class="line">***image hex data***</div><div class="line"></div><div class="line">--Boundary+49F77F66A65EEA58--</div></pre></td></tr></table></figure>
<p>看到上面的例子可以知道，有几个参数是必须的，name、filename、Content-Type、具体资源数据 ，对应的AF接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)appendPartWithFileData:(<span class="built_in">NSData</span> *)data</div><div class="line">                    name:(<span class="built_in">NSString</span> *)name</div><div class="line">                fileName:(<span class="built_in">NSString</span> *)fileName</div><div class="line">                mimeType:(<span class="built_in">NSString</span> *)mimeType;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h1><p>苹果ATS政策出来之前，后端极少使用HTTPS协议，而是使用HTTP协议+自定义的安全数据加密策略来保证安全性。这是因为虽然HTTPS更安全，但是也更加耗费性能。如今苹果强推HTTPS（有说法是苹果可能会全面禁止HTTP的使用），使得HTTPS大范围使用，并且使用HTTPS作为安全扫描项，被安全机构接纳。但是如果不正确的使用HTTPS，还是会带来安全风险。</p>
<h2 id="SSL-TLS简介"><a href="#SSL-TLS简介" class="headerlink" title="SSL/TLS简介"></a>SSL/TLS简介</h2><p>HTTPS的关键字就是SSL（TLS）。和HTTP唯一的不同就是加入了SSL（TLS）协议，这一层在TCP之上，负责保证安全连接和数据传输安全。</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_https_protocol.png" alt=""></p>
<p>注：来自 <a href="https://www.zybuluo.com/qidiandasheng/note/713956" target="_blank" rel="external">深入解析HTTPS</a> </p>
<p>SSL实际上是一套加密通信机制。SSL和TLS两者的协议基本一致，区别简单可以理解是TLS是SSL的升级版本。<strong>但是使用SSL所有协议版本都不再安全。请勿使用SSL协议</strong> 具体可以参考<a href="http://kb.cnblogs.com/page/197396/" target="_blank" rel="external">SSL与TLS的区别以及介绍</a></p>
<p>ios加入了ATS限制，强制原来HTTP必须使用HTTPS传输，也强制要求服务器必须使用TLS v1.2版本以上。所以简化为：</p>
<p><strong>要使用支持TLS1.2及以上协议的HTTPS传输数据</strong></p>
<p>PS：后面如无特殊说明，不再区分TLS和SSL，统一称为SSL</p>
<h2 id="HTTPS原理"><a href="#HTTPS原理" class="headerlink" title="HTTPS原理"></a>HTTPS原理</h2><p>建议看下<a href="http://blog.csdn.net/muzhengjun/article/details/53379593" target="_blank" rel="external">浅析HTTPS中间人攻击与证书校验</a>和<a href="http://www.open-open.com/lib/view/open1411260089562.html" target="_blank" rel="external">阮一峰：图解SSL/TLS协议</a>和<a href="http://www.cnblogs.com/LittleHann/p/3733469.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">SSL、TLS协议格式入门学习 - .Little Hann</a></p>
<p>下面是协议流程图：</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_https_message.jpg" alt=""></p>
<p>注：来自<a href="http://blog.csdn.net/muzhengjun/article/details/53379593" target="_blank" rel="external">http://blog.csdn.net/muzhengjun/article/details/53379593</a></p>
<p>简单描述：</p>
<ol>
<li>TCP握手</li>
<li>SSL握手，握手成功就开始传输，失败就断开链接</li>
<li>数据传输</li>
</ol>
<p>下面也是只讲一些有意思的点和注意的地方。</p>
<h3 id="HTTPS加密流程"><a href="#HTTPS加密流程" class="headerlink" title="HTTPS加密流程"></a>HTTPS加密流程</h3><p>整个加密的流程，体现了一个非常安全的信息加密的方案。 简化的流程如下：</p>
<ol>
<li>客户发送一个随机数给服务端：random-c（明文）</li>
<li>服务端发送自己SSL证书给客户端。发送服务端随机数：random-s（明文）</li>
<li><strong>客户端验证SSL证书有效性，如果判定有效，生成一个随机数random-p,然后使用证书中的公钥进行非对称加密，发送给服务端。</strong> （这一步是整个安全环节最重要也是最薄弱的环节）</li>
<li>服务端拿到加密后的秘钥，通过私钥解密，得到random-p ，将random-c、random-s、random-p三个随机数做因子，两端都按照一定算法生成会话对称秘钥secret_key。</li>
<li>客户端计算之前的握手消息（除了Change Cipher Spec外）的Hash值，利用secret_key做对称加密后发给服务端。</li>
<li>服务端拿到后，利用secret_key解密，然后利用同样的算法计算之前的握手消息的Hash值，如果能解密成功，且验证Hash值正确则说明客户端的加密算法和秘钥没问题。</li>
<li>服务端再计算之前的握手消息的Hash值，利用secret_key做对称加密后发给客户端，客户端如果能够解密出来，且与自己计算的Hash值相同，则最后链接正式建立成功。</li>
</ol>
<p>注明：上面是以RSA为基础的秘钥加密流程，即需要客户端将随机数加密传输给后端。还有一种基于秘钥交换的形式，双方的对称秘钥是通过交换的参数本地的，不会通过信道传输，会更安全些。具体参考<a href="http://www.open-open.com/lib/view/open1477548899809.html" target="_blank" rel="external">TLS/SSL 高级进阶</a></p>
<p>先简单说明几个概念，详细的会专门抽出来分享：</p>
<ol>
<li>对称加密：双方使用的秘钥是相同的，使用同一个秘钥进行加解密。</li>
<li>非对称加密：加密使用公钥加密，解密使用私钥加密。或者私钥加密，使用公钥解密。但是公钥和私钥是不同的。公钥是公开的，可以被第三方拿到而不会引起任何安全问题，因为通过公钥是无法得到私钥的，因而没办法解密使用公钥加密的数据。</li>
<li>散列（hash）：散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。好的散列算法是一对一的，不同的原文生成的一定是不同的散列。</li>
</ol>
<p>这其中使用的加密策略：</p>
<ol>
<li>传输数据应该加密，整个加密过程使用了两种加密方案，一种对称加密，一种非对称加密。</li>
<li>传输数据使用了对称加密，而秘钥生成中使用了非对称加密。</li>
<li>使用了散列算法（hash）来做数据验证。</li>
</ol>
<p>回答这里面常见的几个问题：</p>
<ol>
<li><p>为什么又要用非对称加密，又要用对称加密，只使用一个不可以么？</p>
<blockquote>
<blockquote>
<p>不能只是用对称加密，因为对称加密，两个使用的秘钥是一致的，有一端的秘钥泄露了，两端的通信就不再安全了，尤其是客户端的对称秘钥非常容易泄露，拿到秘钥后，整个系统就不安全了。</p>
<p>也不只用非对称加密，主要是因为性能，非对称加密相对于对称加密，计算时间要长非常多，对于性能要求很高的场景，会明显降低性能。<a href="http://blog.csdn.net/yore_/article/details/52733994" target="_blank" rel="external">RSA算法和AES算法性能测试</a></p>
<p>所以设计者结合了两种方案。两端通过非对称加密协商秘钥，攻击者因为拿不到私钥，是无法解开通信秘钥的。一旦协商成功，通过对称加密又解决了性能问题。</p>
</blockquote>
</blockquote>
</li>
<li><p>为什么使用三个随机数</p>
<blockquote>
<blockquote>
<p>还是为了进一步加强安全，客户端或者服务端生成的随机数可能是伪随机的，有可能被攻击者猜出，但是如果三个伪随机的数一起使用就大大加强了随机性，这样攻击者就很难破解了。</p>
</blockquote>
</blockquote>
</li>
<li><p>为什么最后要做hash验证</p>
<blockquote>
<blockquote>
<p>为了保证两端通信中的数据不会做篡改，由于HASH算法，可以保证唯一性，所以如果中间消息被人篡改，就可以断开链接。</p>
</blockquote>
</blockquote>
</li>
</ol>
<p><strong>如果对原理不感兴趣，那建议记住下面推荐的加密方案</strong>，完全可以解决大部分的加密需求：</p>
<ol>
<li>使用随机数做对称加密秘钥，将对称加密秘钥使用公钥进行非对称加密传给后端。这样因为秘钥随机，所以即使客户端被破解，也拿不到任何对称秘钥。而公钥建议老客户过3456让她进行动态获取，避免私钥泄露带来的问题。</li>
<li>使用非对称加密秘钥，可以保证网络数据即使劫持，因为没有私钥，也解不出来对应的加密秘钥，所以加密的隐私数据也是安全的</li>
<li>两者结合，可以保证一定的性能要求。</li>
<li>对数据进行加签（加盐+hash算法），保证中间的数据不会篡改。</li>
</ol>
<p>ps:用户的密码，因为保密性要求更高。建议的算法是做HMAC哈希做脱敏，然后使用非对称加密给后端。</p>
<h1 id="常用的网络传输攻击手段"><a href="#常用的网络传输攻击手段" class="headerlink" title="常用的网络传输攻击手段"></a>常用的网络传输攻击手段</h1><p>先思考下，刚才的通信链路有三个参与者：</p>
<ol>
<li>客户端</li>
<li>传输信道</li>
<li>服务端</li>
</ol>
<p>如果新加入一个攻击者，他想要窃取用户的隐私数据，他该怎么做？常见的做法：</p>
<ol>
<li>攻击客户端。对于IOS系统来说，非越狱手机，由于权限问题，几乎无法攻击（之前<a href="https://www.baidu.com/link?url=gtxpH2omxSt5NpX-5RmuUYCFmWA-C49q7fQPWnJMO7wtUCpSIXTuEoYZ4B94QDc9Po6lrX7SzKvtEMH8R46XGfGKtnx42FxROp5zbVZ6Irm&amp;wd=&amp;eqid=aa656a8100001a250000000659127d0b" target="_blank" rel="external">XcodeGhost</a>真的是很nb的攻击思路）。对于越狱手机，通过HOOK API，然后重新打包应用，诱导用户下载。或者劫持系统的输入框等常用控件可以达到攻击目的。相关的以后整理输出。但是从移动APP来说，直接攻击APP带来的危害和利用性很低，通常只会泄露很少的用户信息。大多是利用来薅羊毛的。</li>
<li>攻击传输信道。攻击手段有中间人攻击，DNS劫持等。</li>
<li>攻击服务端。也非常难做到。一般是模板注入，撞库等。</li>
</ol>
<p>这里面其实最容易的就是攻击传输信道。排除技术术语，手段有：</p>
<ol>
<li>伪装成正常的客户端攻击服务端</li>
<li>伪装成正常的服务端，劫持客户端数据</li>
<li>监听修改信道数据</li>
</ol>
<p>这几种怎么解决？</p>
<p>问：如何处理伪装成正常的客户端攻击服务端</p>
<blockquote>
<p>在认为客户端app本身是无法攻破的前提下：</p>
<ol>
<li>请求中一定加入签名策略。攻击者不知道签名策略是无法仿造请求的，也防止劫持者修改。发现签名不对，服务端认为是假的客户端。</li>
<li>请求中一定加入请求防重放策略。服务端发现是之前的请求，重复发送过来的（可能只有签名不一致），应该忽略</li>
<li>加入风险控制策略。比如异地登陆，同一设备ip反复请求，一些金融类app也会加入公安部认证的风控系统，防止一些有金融犯罪前科的用户注册。后端使用风控策略，禁止用户登录，或者强制要求用户再次身份认证，比如手机验证码认证。</li>
</ol>
</blockquote>
<p>问：如何处理监听修改信道数据<br>&gt;</p>
<blockquote>
<ol>
<li>请求关键数据做加密，加密方案建议使用上面提到的加密方案。这样即使被监听，拿到数据也无法处理</li>
<li>加入请求签名，防止数据篡改。</li>
</ol>
</blockquote>
<p>问：如何处理伪装成正常的服务端，劫持客户端数据</p>
<blockquote>
<p>这一种方式是目前攻击最常见且有效的手段。使用http的时候，因为没有任何认证措施，通过ARP或者DNS劫持，非常容易将网址定向到其他攻击者的地址，攻击者可以做劫持和修改相关数据。所以HTTP现在已经被各大平台所抛弃。很多开发遇到的访问一个h5页面，被运营商强插入广告就是这么做的。解决办法就是正确的使用HTTPS</p>
</blockquote>
<p>HTTPS，很大一部分作用就是解决上述问题。也就是通过SSL握手，校验服务端证书，达到验证是否是伪装的服务端的目的。HTTPS握手阶段算法原理都是安全的，只有验证身份这一步有漏洞，即只要想办法让客户端认为证书是可信的，证书里面的公钥就是生成者的公钥，自然就有相对应的私钥，后面非对称加密生成的对称秘钥就可以被截取到，造成整个链路不安全。如何攻击这个策略，行业上主要称为<strong>中间人攻击</strong>。</p>
<h1 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h1><p>可以说<strong>验证SSL证书是整个HTTPS的关键</strong>，如果这一步出问题，后面的就没有任何安全可言。而对于我们前端开发来说，SSL证书也是最需要关注的地方。</p>
<p>这里讲两个问题。SSL证书是什么？为什么通过SSL证书可以防止攻击者伪装成服务端。</p>
<h2 id="SSL证书是什么"><a href="#SSL证书是什么" class="headerlink" title="SSL证书是什么"></a>SSL证书是什么</h2><p>SSL证书是一个文件。里面的内容包括：用户的信息、用户的公钥、还有CA中心对该证书里面的信息的签名。<br>一个证书的实例：</p>
<p>打开safari，打开百度，<code>https://www.baidu.com</code>,在地址栏点击锁按钮，然后选显示证书。</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_https_cer.png" alt=""></p>
<p>里面的内容只有几个需要关注的：</p>
<ol>
<li>常用名称：<code>baidu.com</code> 。客户端或浏览器，根据常用名称和访问的域名做匹配，访问的域名和证书的域名不一致，就会拒绝访问，达到<strong>防止域名劫持的目的</strong>。这个信息可以被伪造。</li>
<li>公共密钥：SSL握手生成的第二段随机串是通过这个公钥来加密的。这个信息可以被伪造，但是伪造没有异议。（想知道为啥的可以看看证书生成的步骤。）</li>
<li>签名：是对整个证书内容做hash之后，使用颁发机构的<strong>私钥</strong>加密的值。这个信息可以被伪造，但是伪造没有异议。</li>
<li>签名者信息：颁发机构的信息，由于验证上一级的证书信息。这个信息可以被伪造。</li>
<li>证书有效期。这个信息可以被伪造。</li>
</ol>
<p>可以看到在百度这个证书上面还有两个证书，这是因为百度这个证书是有GS这个机构的二级机构颁发的，而GS这个二级机构是由GS的CA根证书颁发的。</p>
<p>也就是证书有证书链的概念，即这个证书可能是上一层机构颁发的，从CA根证书开始-&gt;二级CA证书-&gt;三级CA证书-&gt;…。</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_http_ssl_chain.png" alt=""></p>
<p>注：来自<a href="http://blog.csdn.net/shen_guo/article/details/49891459" target="_blank" rel="external">SSL 之证书链</a></p>
<h2 id="SSL证书如何验证的"><a href="#SSL证书如何验证的" class="headerlink" title="SSL证书如何验证的"></a>SSL证书如何验证的</h2><p>推荐这篇文章，是目前看到讲的最清楚。<a href="http://www.2cto.com/article/201607/523509.html" target="_blank" rel="external">浅析HTTPS中间人攻击与证书校验</a></p>
<p>根据HTTPS协议，服务端会在握手的时候将证书传送给客户单，<strong>而且是将整个证书链发过来</strong>。</p>
<p>通常的验证传过来的证书是否有效的步骤为：</p>
<ol>
<li>验证证书的常用名称是否是访问的域名，是否在有效期内。（域名校验+有效期校验）</li>
<li>计算这个证书内容的散列值得到MD5-a，然后用颁发机构的公钥解密这个证书的签名得到MD5-b，比较两个值是否相同，如果相同说明这个证书确实是上个颁发机构颁发的。</li>
<li>重复上面的操作，直到验证到CA根证书。CA证书是自签名的，也就是签名是用自己的私钥签名的。<br>可是CA根证书签名是用自己的私钥做签名，怎么去验证这个证书是否正确呢？</li>
</ol>
<p>最终上面的问题简化为：</p>
<h2 id="如何验证CA根证书有效性"><a href="#如何验证CA根证书有效性" class="headerlink" title="如何验证CA根证书有效性"></a>如何验证CA根证书有效性</h2><p>最终层层拨茧，HTTPS的安全性关键钥匙就在这一章了。</p>
<p>CA根证书有两种生成方式：</p>
<ol>
<li>由可信的颁发机构颁发</li>
<li>本地自己生成</li>
</ol>
<p>对于第一种，因为可信的颁发机构很少，这些机构的CA证书会默认保存在浏览器里或者手机操作系统里，由可信的机构颁发的证书的有效性会由颁发机构保证。不过这种证书需要向颁发机构申请，颁发机构会花时间去进行公司域名身份等信息验证，所以花费也不少。</p>
<p>对于第二种，本地生成的证书（后面会附录如何生成自签名证书），证书常用的信息都可以生成，可以认为证书信息内容都不可靠，尤其是证书中的域名。使用自制证书在浏览器会弹出警告不可信，用户可以手动添加到信任列表里，之后可信了才可以访问，12306之前让下载证书导入，就是这个原因。在应用APP里，如果使用默认配置，会拒绝，返回SSL验证失败。</p>
<p>在应用内信任自生成证书有两种办法：</p>
<p>第一种</p>
<blockquote>
<p>安装描述文件到系统里。在安装charles过程中，其中一步就是打开一个网址，在弹出安装的时候，安装这个证书，也可以把这个证书下载到云盘里，然后打开。这个过程需要用户手动授权。这个起效后是全局的，任何应用都会影响。</p>
</blockquote>
<p>第二种</p>
<blockquote>
<p>把这个根证书，埋入APP里,然后设置为证书锚点（可以设置多个），然后在SSL握手需要验证证书的时候，系统会认为这个证书是有效的。这个方案也是很多自签名证书进行校验的方法。这个只会在本应用里起作用。</p>
</blockquote>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人攻击是最常见的攻击HTTPS手段。</p>
<p>建议看这篇文章：<a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/" target="_blank" rel="external">iOS安全系列之二：HTTPS进阶</a></p>
<p>看到上面的验证手段，其实关键就在于如何信任CA根证书上面。攻击者就是想尽一切办法让客户端安装他自己的CA证书到你的手机里。</p>
<p>如果手机没有越狱，一定会引诱你去安装这个证书，并且手动设为可信。一旦信任，在访问服务器的时候，攻击者通过代理劫持，通过这个信任的CA证书，生成对应的域名的证书。最终因为<strong>域名可信，有效期可信，证书可信</strong>整个HTTPS建立成功，攻击者拿到相关的数据。</p>
<p>使用charles抓包的整个过程，其实就是中间人攻击的过程。</p>
<p>附：下面是charles开启SSL代理后，访问新浪弹出的证书信息，可以看到charles生成了新浪域名的证书：</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_https_fake.png" alt=""></p>
<p>提示：<strong>对于用户来说，不要信任任何CA证书，不安装任何描述文件是最安全的方法。</strong>比如安装飙车软件，让你信任一个证书。比如链接外部wifi，提示你安装证书才可以链接。比如翻墙设置代理，提示你安装信任证书。描述文件在通用-&gt;描述文件与设备管理中找到。</p>
<h2 id="校验证书的姿势"><a href="#校验证书的姿势" class="headerlink" title="校验证书的姿势"></a>校验证书的姿势</h2><p>校验证书有两种方案：</p>
<blockquote>
<blockquote>
<p>弱校验</p>
</blockquote>
</blockquote>
<p>对于服务端证书，校验下面的case。</p>
<ol>
<li>校验证书的域名</li>
<li>校验证书的有效期</li>
<li>校验证书链和证书的有效性</li>
</ol>
<p>保证这三者有效，已经可以解决大部分的攻击了。唯一的风险就是中间人攻击，被安装CA证书之后，<strong>一个被信任的CA根证书可以生成符合上面要求的任何域名的证书</strong>。存在着风险，但是攻击难度已经大大增加了。<em>AFNetworking框架默认采用的就是这个策略</em>。</p>
<blockquote>
<blockquote>
<p>强校验</p>
</blockquote>
</blockquote>
<p>将证书放入APP中作为证书锚点。在上面的基础上再验证证书。这样可以完全保证服务端的证书是真正需要的证书，从而真正解决中间人攻击。</p>
<p>下面主要讲下强校验面临的坑，各位开发一定要注意。</p>
<h2 id="证书强校验的坑"><a href="#证书强校验的坑" class="headerlink" title="证书强校验的坑"></a>证书强校验的坑</h2><p>证书是有有效期的，尤其是非自制证书，通常都在三年以内（很多资料根本不谈这个问题）。一旦有效期过了，服务端就需要更换证书,但是由于APP存在发版的情况，老的APP由于所有链接失败，导致老APP任何请求都失效，然后无法通知用户更新，老用户也不知道因为什么访问失败。（这些都是血的教训啊）</p>
<p>有几个建议的地方：</p>
<ol>
<li>尽量埋CA证书，因为CA证书的有效期要长，有足够的时间准备。</li>
<li>有些通道不要使用证书强校验，比如检查升级，一些热修复策略，尽量使用自有的安全逻辑保证安全。</li>
<li>如果是自制证书，建议有效期设置长一些。</li>
</ol>
<p>上面的是尽量降低风险，该出问题的时候还是会出，有一些不完美的方案大家可以参考下：</p>
<p>方案1：动态更新证书。</p>
<blockquote>
<blockquote>
<p>在APP中放入RSA公钥，应用启动的时候，证书信息通过私钥加密，发送给前端保存，前端把这个新证书和埋入的证书一起做锚点，进行验证。这样可以保证老APP可以使用一段时间。缺点是这个下发的机制要尽量安全可靠，有可能被攻击者利用，而且后续的请求需要依赖这个请求，所以方案复杂一些。</p>
</blockquote>
</blockquote>
<p>方案2：只验证证书的公钥</p>
<blockquote>
<blockquote>
<p>只使用证书的公钥进行验证，因为更换证书，一般是通过.csr文件生成crt证书文件的（也就是证书文件），在.csr文件没变的情况下，生成的证书的公钥是一致的，也就即使服务端更换了证书，只要公钥不变，依然可以通过验证。所以验证公钥也是相对安全的。缺点是如果新的证书换了公钥还是出问题。我遇到的case就是需要更换私钥和证书算法，公钥也不一样了。</p>
</blockquote>
</blockquote>
<p>其他不太靠谱的方案：</p>
<p>方案3：</p>
<blockquote>
<blockquote>
<p>在弱校验的基础上，加上验证颁发机构。只要读到颁发机构是可信的，证书就认为是有效的。可以解决第三方抓包工具的抓包问题，因为第三方抓包工具，一般使用自己的颁发机构，和实际的颁发机构不一致。缺点是，证书是可以完全伪造的，包括颁发结构的名字，有效期等等都可以伪造。</p>
</blockquote>
</blockquote>
<p>方案4：</p>
<blockquote>
<blockquote>
<p>信任无效的证书。 信任无效的证书，但是做本地证书校验，在失效的一段时间内，后端先不部署新证书，在新版本里面提前埋入新证书，在几个版本后再上线新的证书。优点是简单，不怕哪天忘了更换证书导致出问题。缺点是信任失效的证书，如果真的有需求要强制更换证书，就没办法处理。</p>
</blockquote>
</blockquote>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h1><h2 id="如何生成自签名证书"><a href="#如何生成自签名证书" class="headerlink" title="如何生成自签名证书"></a>如何生成自签名证书</h2><p>参考 <a href="https://www.zybuluo.com/qidiandasheng/note/713956" target="_blank" rel="external">深入解析HTTPS</a>和<a href="https://my.oschina.net/wayhk/blog/491958?p=1" target="_blank" rel="external">利用OpenSSL创建自签名的SSL证书</a> 和 <a href="http://blog.csdn.net/sdcxyz/article/details/47220129" target="_blank" rel="external">自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名</a></p>
<ol>
<li><p>生成私钥</p>
<p> <code>openssl genrsa -out ca.key 4096</code> </p>
</li>
<li><p>利用私钥创建根证书</p>
<p><code>openssl req -new -x509 -days 36500 -key ca.key -out ca.crt</code></p>
<p>弹出的对话框按照提示填写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Guangdong</div><div class="line">Locality Name (eg, city) []:Shenzhen</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:BL.inc</div><div class="line">Organizational Unit Name (eg, section) []:</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:BL</div><div class="line">Email Address []:</div></pre></td></tr></table></figure>
</li>
<li><p>创建SSL证书私钥</p>
<p><code>openssl genrsa -out server.key 4096</code></p>
</li>
<li><p>使用刚才的私钥签名</p>
<p><code>openssl req -new -key server.key -out server.csr</code></p>
<p>弹出的对话框按照提示填写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">  Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Guangdong</div><div class="line">Locality Name (eg, city) []:Shenzhen</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:BL.inc</div><div class="line">Organizational Unit Name (eg, section) []:</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:*.sina.com.cn</div><div class="line">Email Address []:</div><div class="line"></div><div class="line">Please enter the following &apos;extra&apos; attributes</div><div class="line">to be sent with your certificate request</div><div class="line">A challenge password []:1111</div><div class="line">An optional company name []:</div></pre></td></tr></table></figure>
<p>注意，这里的Common Name 应该和实际的域名匹配。而且生成的.csr这个文件最好长期保留，下次过期的时候，建议直接用这个文件做签名。如果是向CA颁发机构申请，提交的文件也是这个文件。</p>
</li>
<li><p>对上一步的csr使用CA进行签名生成证书</p>
<p><code>openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt</code>   </p>
<p>如果是向CA机构申请，提交这个文件就可以了。</p>
</li>
<li><p>如果有必要可以重复上面必要步骤，使用上一步的证书的.crt和.key继续签名下一级证书。</p>
<p>一些常用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  openssl s_client -connect www.google.com:443 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer  //获取www.google.com:443的ssl证书，地址可以换成自己的</div><div class="line">openssl rsa -noout -text -in server.key 查看私钥信息</div><div class="line">openssl req -noout -text -in server.csr 查看签名请求信息</div><div class="line">openssl x509 -noout -text -in ca.crt 查看证书信息</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="MAC下使用Charles抓包"><a href="#MAC下使用Charles抓包" class="headerlink" title="MAC下使用Charles抓包"></a>MAC下使用Charles抓包</h2><p>参考 <a href="https://www.zybuluo.com/qidiandasheng/note/713956" target="_blank" rel="external">深入解析HTTPS</a> 和 <a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/" target="_blank" rel="external">iOS安全系列之二：HTTPS进阶</a></p>
<ul>
<li><p>安装Charles CA根证书 </p>
<p>点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certification …，会弹出如下提示，链接代理，手机浏览器输入chls.pro/ssl，就可以安装根证书了。 </p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_1.png" alt=""></p>
</li>
</ul>
<ul>
<li><p>设置SSL代理 </p>
<p>  点击Proxy-&gt;SSL Proxying Setting，勾选Enable SSL Proxying，然后点击Add输入要SSL代理的请求Host和Port，可以使用通配符来表示某一类请求。<br> <img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_2.png" alt=""></p>
<p> 或者在对应的请求上右键选择Enable SSL Proxying，就会把这一个请求加入到上面的SSL代理列表中（类似于点击Add的效果）。 </p>
<p> <img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_3.png" alt=""></p>
<p>  做完上述步骤后重新请求就能得到解密后的信息了。ps:抓取PC端的HTTPS包也类似，在Help-&gt;SSL Proxying中下载证书，双击安装证书，并选择始终信任即可。</p>
</li>
</ul>
<ul>
<li><p>在iPhone端设置HTTP代理</p>
<p>  在Mac上获取当前机器的IP地址：</p>
<p>  ifconfig en0:</p>
<p>  <img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_4.jpg" alt=""></p>
<p> ch将iPhone连接到与电脑相同的WiFi，在iPhone设置中：无线局域网 -&gt; 已连接WiFi右边的Info详情图标 -&gt; HTTP代理 -&gt; 手动 -&gt; 设置HTTP代理：</p>
<p> <img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_5.jpg" alt=""></p>
<p> 设置完成之后，打开Safari随便访问一个网页，初次设置代理的话，Charles会弹出一个iPhone请求代理的确认框，点击Allow即可。然后在Charles上就可以看到iPhone上的HTTP请求了。为了避免Mac上的请求过多影响对被代理iPhone上HTTP请求的查看和调试，可以在Charles取消Mac的代理：Menu -&gt; Proxy -&gt; 取消勾选Mac OS X Proxy 即可。</p>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><p><a href="http://blog.csdn.net/gueter/archive/2007/03/08/1524447.aspx" target="_blank" rel="external">HTTP协议详解（真的很经典）</a></p>
</li>
<li><p><a href="https://github.com/mqttjs/MQTT.js" target="_blank" rel="external">MQTT_github</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/zhao1949/p/5545064.html" target="_blank" rel="external">说说http协议中的编码和解码</a></p>
</li>
<li><p><a href="https://my.oschina.net/cnlw/blog/168466" target="_blank" rel="external">HTTP协议之multipart/form-data请求分析</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/1ec3fa1ec00f" target="_blank" rel="external">苹果文档翻译 iOS10 NSAppTransportSecurity</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/2bfe1110f3b5" target="_blank" rel="external">iOS中的HTTPS, 你知道多少?</a></p>
</li>
<li><p><a href="http://www.open-open.com/lib/view/open1411260089562.html" target="_blank" rel="external">阮一峰：图解SSL/TLS协议</a></p>
</li>
<li><p><a href="http://kb.cnblogs.com/page/197396/" target="_blank" rel="external">SSL与TLS的区别以及介绍</a></p>
</li>
<li><p><a href="http://www.2cto.com/article/201607/523509.html" target="_blank" rel="external">浅析HTTPS中间人攻击与证书校验</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/LittleHann/p/3733469.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">SSL、TLS协议格式入门学习 - .Little Hann</a></p>
</li>
<li><p><a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/" target="_blank" rel="external">iOS安全系列之二：HTTPS进阶</a></p>
</li>
<li><p><a href="http://www.open-open.com/lib/view/open1461324289052.html" target="_blank" rel="external">HTTPS 理论详解与实践</a></p>
</li>
<li><p><a href="https://my.oschina.net/wayhk/blog/491958?p=1" target="_blank" rel="external">利用OpenSSL创建自签名的SSL证书</a></p>
</li>
<li><p><a href="http://blog.csdn.net/sdcxyz/article/details/47220129" target="_blank" rel="external">自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名</a></p>
</li>
<li><p><a href="https://www.zybuluo.com/qidiandasheng/note/713956" target="_blank" rel="external">深入解析HTTPS</a></p>
</li>
<li><p><a href="http://www.open-open.com/lib/view/open1477548899809.html" target="_blank" rel="external">TLS/SSL 高级进阶</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导读：&lt;/p&gt;
&lt;p&gt;本文主要讲在HTTP和HTTPS实际开发中有用和有意思的地方，希望读者能够有所启发。&lt;/p&gt;
&lt;p&gt;主要包括：HTTP和HTTPS的简单介绍。介绍HTTPS加密逻辑。介绍SSL证书和SSL证书校验的规则。&lt;/p&gt;
&lt;p&gt;本文简化了相关的技术细节，主要关注于前端开发需要关注的点和可以借鉴的地方，希望能对开发能有所帮助。开发更关心的技术代码实现细节，会单独文章中说明。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="安全" scheme="https://dishibolei.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://dishibolei.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="HTTPS" scheme="https://dishibolei.github.io/tags/HTTPS/"/>
    
      <category term="SSL证书" scheme="https://dishibolei.github.io/tags/SSL%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
</feed>
