<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="专注于IOS客户端安全、性能、架构和react-native技术">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://dishibolei.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="专注于IOS客户端安全、性能、架构和react-native技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="专注于IOS客户端安全、性能、架构和react-native技术">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dishibolei.github.io/"/>





  <title>Hexo - 我的小博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我的小博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dishibolei.github.io/2017/05/11/IOS应用安全-HTTP-HTTPS网络安全-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bolei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/11/IOS应用安全-HTTP-HTTPS网络安全-一/" itemprop="url">IOS应用安全-HTTP/HTTPS网络安全(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-11T15:21:51+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IOS应用安全-HTTP-HTTPS网络安全-一"><a href="#IOS应用安全-HTTP-HTTPS网络安全-一" class="headerlink" title="IOS应用安全-HTTP/HTTPS网络安全(一)"></a>IOS应用安全-HTTP/HTTPS网络安全(一)</h1><blockquote>
<p>导读：</p>
<p>本文主要讲在HTTP和HTTPS实际开发中有用和有意思的地方，希望读者能够有所启发。</p>
<p>主要包括：先讲HTTP协议，然后讲HTTPS协议，主要是HTTPS中加密流程和其中的策略，然后通过这个流程切入到常用的攻击手段、最后开始介绍SSL证书和说明为什么SSL证书验证可以有效的解决安全问题。</p>
<p>本文主要是简化的说明，和应用开发实际中真正接触到的知识。先偏理论，后续偏代码应用方面讲如何处理HTTPS的安全问题。</p>
</blockquote>
<h2 id="1-HTTP简介"><a href="#1-HTTP简介" class="headerlink" title="1. HTTP简介"></a>1. HTTP简介</h2><p>具体说明不想过多讨论，可以参考后面的参考文献，只写我觉得有意思和实际中可以参考的地方。</p>
<ol>
<li><p>HTTP协议构建于TCP之上。意味着http是可靠的数据传输。所以不用担心丢包和乱序的问题。</p>
</li>
<li><p>HTTP协议是基于请求和响应的协议。与之对比MQTT协议是基于订阅的协议。</p>
<p> 比如我想要一个资源的种子，如果知道哪个老司机有，我直接问他，他有就给我，没有也告诉我没有。这种模式就是请求和响应，好处是一对一，可以<strong>准确完整的按照自己的需求拿到需要的数据</strong>，但是坏处是消息会滞后，我想知道老司机后面是不是有资源了，我就只能一遍遍重复的问，直到拿到想要的结果为止（循环延迟请求，之前专门写个looperRequest就是为了解决这种问题）。</p>
<p> 另外一种方案，我发布消息到一个论坛，然后留下邮箱，求好人一生平安。然后很多好人有资源就发给我，这样也能拿到数据。这种模式就是订阅模式，好处是可以一对多，可以<strong>快速实时拿到数据</strong>。但是<strong>坏处是：需要长链接</strong>，且推送消息时不清楚客户端的状态，推送的东西不一定需要，比如这个种子可能我已经有了，再发给我就浪费大家的流量了。</p>
<p> 总结下。利用请求应答的模式，可以快速的和服务端同步数据，保证当前请求数据的有效性，有时候我们也叫拉（pull）数据。订阅模块可以快速的更新需要保证实时性的数据，比如聊天数据，交易结果，账户异常，有时候我们也叫推送（push）数据。</p>
<p> 这两种方案是和服务端常用的两种交互方案，有些交互可以考虑两者结合的方式解决。比如之前项目中解决聊天数据的实时有效性，就采用后端推送当前有新消息或其他状态信息，前端收到状态信息后，主动拉取消息到本地，既能保证能够快速更新消息或状态，又能通过本地的状态，按照需求拉取需要的消息。</p>
<p> 推/拉这种设计思路也可以用于应用间的数据同步，应用于模块间数据通信来进行模块解耦等。现在的项目工程模块化设计方案也借鉴了这两种思想。</p>
</li>
<li><p>URL。URL定义了一个资源的地址。大部分格式如下</p>
<p> <code>protocol :// hostname[:port] / abs_path / [;parameters][?query]#fragment</code></p>
<p> 详细说明<a href="http://baike.baidu.com/link?url=9uGFzaUuMRGf4Nn-ucSUqrSYI4vwDls4jVrxZ_7iHZqCnp7FJJTW1ZGp8lzyJ28m9uweSaN6CREycgIObuspD7UQeq1_WlQjnbEzvpjBBK7" target="_blank" rel="external">参考</a></p>
<p> 其中query用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。例如：<code>http://www.joes.com/inventory-check.cgi?item=12731&amp;color=blue</code>。唯一需要注意的是，URL里面不容许有非ASCII字符（常见的就是汉字），也不容许有保留字符比如：<code>!*&#39;\&quot;();:@&amp;=+$,/?%#[]%</code>,所以通常拼接请求时（GET），需要对传进来的参数做<strong>一次URLEncode</strong>操作。</p>
<p> <strong>可以参考这个做私有协议跳转，比如push消息协议，模块跳转协议，外部跳转协议等。</strong></p>
</li>
</ol>
<ol>
<li><p>http请求由三部分组成，分别是：请求行、消息报头、请求正文.详细的建议使用charles抓一个请求看下就知道了。</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_http_header_struct.png" alt=""> </p>
<p>注：来源于<a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="external">http://www.cnblogs.com/ranyonsue/p/5984001.html</a>.</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_http_header1.png" alt=""></p>
<p>重要的几个请求报头字段：</p>
<ul>
<li>Accept: 指定客户端接受的消息类型（通常没人使用,因为客户端大量使用json做数据解析）</li>
<li>Host:请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</li>
<li>User-Agent:用于附加操作系统名称和浏览器版本，通常给H5使用的，UA很容易被修改，项目中有遇到修改UA导致H5页面识别不出来当前操作系统和版本的问题，遇到这种可以查下UA被谁篡改了。</li>
<li>Referer:用于标示请求来源，一般用于防盗链，这个实际中也遇到过。</li>
</ul>
</li>
<li><p>http的响应一般由三个部分组成，分别是:状态行，消息报头，响应正文。</p>
<p> <img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_http_response_struct.jpg" alt=""><br> 注：来源于<a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="external">http://www.cnblogs.com/ranyonsue/p/5984001.html</a>.</p>
<p> 重要的几个消息报头</p>
<ul>
<li>Content-Type 正文媒体类型和编码格式，比如：<code>Content-Type:text/html;charset=ISO-8859-1</code>.Content-Type这个字段被AFNetworking框架用于决定用什么解析器，注意后端不要配置错了。charset被用于AFNetworking字符解码，也应该前后端配置正确。这个配置不正确是经常联调不过的原因。 具体实现参考<code>AFURLResonseSerialization.m</code>。</li>
<li>Content-Length 用于表示正文长度，下载长资源时，需要使用这个字段来计算进度，也可以用这个字段推算下载流量。</li>
<li>Content-Encoding 通常用于记录压缩方法，比如：<code>gzip</code>。</li>
</ul>
</li>
<li><p>GET和POST的方法。HTTP有定义了几种常用的方法，不过通常前端只和这两个打交道。这两个区别：</p>
<ul>
<li>通常认为get是获取消息，不改变数据，post是用来改变数据，不过实际中，并不是那么明确。</li>
<li>get参数是附在URL链接上的，参数拼接前需要做URLEncode，post是附在请求正文里的,格式为key=value，使用&amp;分割，所以对传入数据也要做URLEncode，拼接后和头部用回车换行隔开。</li>
<li>get的URL长度有一定限制，不过也取决于系统支持，具体长度需要实际调研，ie的限制为2083字节，post理论上不存在长度限制。</li>
<li>安全性，post相对安全，get相对不安全。不过post属于防君子不防小人的那种，实际没有什么安全可言。<br>所以综合来说，如果没有技术洁癖，建议都用post处理。</li>
</ul>
</li>
<li><p>上传图片等文本资源。上传资源一般是post协议，但是通常post是用于传送文本的，如何传图片等资源呢？就需要<code>multipart</code>协议了。</p>
<p> mutipart和普通的post有两点不同：请求头，请求报文。其中关键字是<code>boundary</code>这个属性。</p>
<ul>
<li>请求头： 必须包含<code>content-Type</code>，且值为：<code>multipart/form-data;boundary=${bond}</code>,其中${bound}为具体分割符，在AFNetworking中，如果不指定是<code>Boundary+${random}</code>。</li>
<li><p>请求体:内容不再是用name=value的形式，而是使用上面的boundary进行分割的一段一段的结构体。具体示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">POST /btoa/work/common/uploadImage HTTP/1.1</div><div class="line">Host: www.example.com</div><div class="line">Content-Type: multipart/form-data; boundary=Boundary+49F77F66A65EEA58</div><div class="line">Cookie: BIGipServerPOOL_PACLOUD_STGR2016080900646=1274288556.52384.0000; FF_SESSION2_ID=Sf503bee3691b4a31a53c6e3c5ae1c1f00912e8</div><div class="line">Connection: keep-alive</div><div class="line">Accept: */*</div><div class="line">User-Agent: FFProject/2.0.0 (iPhone; iOS 10.3.1; Scale/3.00)</div><div class="line">Accept-Language: zh-Hans-CN;q=1, th-TH;q=0.9</div><div class="line">Content-Length: 418864</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line"></div><div class="line">--Boundary+49F77F66A65EEA58</div><div class="line">Content-Disposition: form-data; name=&quot;ffAppID&quot;</div><div class="line"></div><div class="line">10004</div><div class="line">--Boundary+49F77F66A65EEA58</div><div class="line">Content-Disposition: form-data; name=&quot;imageSeq&quot;</div><div class="line"></div><div class="line">1</div><div class="line">--Boundary+49F77F66A65EEA58</div><div class="line">Content-Disposition: form-data; name=&quot;imageType&quot;</div><div class="line"></div><div class="line">5</div><div class="line">--Boundary+49F77F66A65EEA58</div><div class="line">Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;xxxx.jpg&quot;</div><div class="line">Content-Type: image/jpeg</div><div class="line"></div><div class="line">***image hex data***</div><div class="line"></div><div class="line">--Boundary+49F77F66A65EEA58--</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>   看到上面的例子可以知道，有几个参数是必须的，<code>name、filename、Content-Type、具体资源数据</code> ，对应的AF接口：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)appendPartWithFileData:(NSData *)data</div><div class="line">                      name:(NSString *)name</div><div class="line">                  fileName:(NSString *)fileName</div><div class="line">                  mimeType:(NSString *)mimeType;</div></pre></td></tr></table></figure>
</code></pre><h2 id="2-HTTPS简介"><a href="#2-HTTPS简介" class="headerlink" title="2. HTTPS简介"></a>2. HTTPS简介</h2><p>苹果ATS政策出来之前，后端极少使用HTTPS协议，而是使用HTTP协议+自定义的安全数据加密策略来保证安全性。这是因为虽然HTTPS更安全，但是也更加耗费性能。如今苹果强推HTTPS（有说法是苹果可能会全面禁止HTTP的使用），使得HTTPS大范围使用，并且使用HTTPS作为安全扫描项，被安全机构接纳。但是如果不正确的使用HTTPS，还是会带来安全风险。</p>
<h3 id="2-1-SSL-TLS简介"><a href="#2-1-SSL-TLS简介" class="headerlink" title="2.1 SSL/TLS简介"></a>2.1 SSL/TLS简介</h3><p>HTTPS的关键字就是SSL（TLS）。和HTTP唯一的不同就是加入了SSL（TLS）协议，这一层在TCP之上，负责保证安全连接和数据传输安全。</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_https_protocol.png" alt=""></p>
<p>注：来自 <a href="https://www.zybuluo.com/qidiandasheng/note/713956" target="_blank" rel="external">深入解析HTTPS</a> </p>
<p>SSL实际上是一套加密通信机制。SSL和TLS两者的协议基本一致，区别简单可以理解是TLS是SSL的升级版本。<strong>但是使用SSL所有协议版本都不再安全。请勿使用SSL协议</strong> 具体可以参考<a href="http://kb.cnblogs.com/page/197396/" target="_blank" rel="external">SSL与TLS的区别以及介绍</a></p>
<p>ios加入了ATS限制，强制原来HTTP必须使用HTTPS传输，也强制要求服务器必须使用TLS v1.2版本以上。所以简化为：</p>
<p><strong>要使用支持TLS1.2及以上协议的HTTPS传输数据</strong></p>
<p>PS：后面如无特殊说明，不再区分TLS和SSL，统一称为SSL</p>
<h3 id="2-2-HTTPS原理"><a href="#2-2-HTTPS原理" class="headerlink" title="2.2 HTTPS原理"></a>2.2 HTTPS原理</h3><p>建议看下<a href="http://blog.csdn.net/muzhengjun/article/details/53379593" target="_blank" rel="external">浅析HTTPS中间人攻击与证书校验</a>和<a href="http://www.open-open.com/lib/view/open1411260089562.html" target="_blank" rel="external">阮一峰：图解SSL/TLS协议</a>和<a href="http://www.cnblogs.com/LittleHann/p/3733469.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">SSL、TLS协议格式入门学习 - .Little Hann</a></p>
<p>下面是协议流程图：</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_https_message.jpg" alt=""></p>
<p>注：来自<a href="http://blog.csdn.net/muzhengjun/article/details/53379593" target="_blank" rel="external">http://blog.csdn.net/muzhengjun/article/details/53379593</a></p>
<p>简单描述：</p>
<ol>
<li>TCP握手</li>
<li>SSL握手，握手成功就开始传输，失败就断开链接</li>
<li>数据传输</li>
</ol>
<p>下面也是只讲一些有意思的点和注意的地方。</p>
<h4 id="2-2-1-HTTPS加密流程"><a href="#2-2-1-HTTPS加密流程" class="headerlink" title="2.2.1 HTTPS加密流程"></a>2.2.1 HTTPS加密流程</h4><p>整个加密的流程，体现了一个非常安全的信息加密的方案。 简化的流程如下：</p>
<ol>
<li>客户发送一个随机数给服务端，random-c（明文）</li>
<li>服务端发送自己SSL证书给客户端。发送服务端随机数，random-s（明文）</li>
<li><strong>客户端验证SSL证书有效性，如果判定有效，生成一个随机数random-p,然后使用证书中的公钥进行非对称加密，发送给服务端。</strong> （这一步是整个安全环节最重要也是最薄弱的环节）</li>
<li>服务端拿到加密后的秘钥，通过私钥解密，得到random-p ，将random-c、random-s、random-p三个随机数做因子，两端都按照一定算法生成会话对称秘钥secret_key。</li>
<li>客户端计算之前的握手消息（除了Change Cipher Spec外）的Hash值，利用secret_key做对称加密后发给服务端。</li>
<li>服务端拿到后，利用secret_key解密，然后利用同样的算法计算之前的握手消息的Hash值，如果能解密成功，且验证Hash值正确则说明客户端的加密算法和秘钥没问题。</li>
<li>服务端再计算之前的握手消息的Hash值，利用secret_key做对称加密后发给客户端，客户端如果能够解密出来，且与自己计算的Hash值相同，则最后链接正式建立成功。</li>
</ol>
<p>先简单说明几个概念，详细的会专门抽出来分享：</p>
<ol>
<li>对称加密：双方使用的秘钥是相同的，使用同一个秘钥进行加解密。</li>
<li>非对称加密：加密使用公钥加密，解密使用私钥加密。或者私钥加密，使用公钥解密。但是公钥和私钥是不同的。公钥是公开的，可以被第三方拿到而不会引起任何安全问题，因为通过公钥是无法得到私钥的，也没办法解密使用公钥加密的数据。</li>
<li>散列（hash）：散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。好的散列算法是一对一的，不同的原文生成的一定是不同的散列。</li>
</ol>
<p>这其中使用的加密策略：</p>
<ol>
<li>传输数据应该加密，整个加密过程使用了两种加密方案，一种对称加密，一种非对称加密。</li>
<li>传输数据使用了对称加密，而秘钥生成中使用了非对称加密。</li>
<li>使用了散列算法（hash）来做数据验证。</li>
</ol>
<p>回答这里面常见的几个问题：</p>
<ol>
<li><p>为什么又要用非对称加密，又要用对称加密，只使用一个不可以么？</p>
<blockquote>
<blockquote>
<p>不能只是用对称加密，因为对称加密，两个使用的秘钥是一致的，有一端的秘钥泄露了，两端的通信就不再安全了，尤其是客户端的对称秘钥非常容易泄露，拿到秘钥后，整个系统就不安全了。</p>
<p>也不只用非对称加密，主要是因为性能，非对称加密相对于对称加密，计算时间要长非常多，对于性能要求很高的场景，会明显降低性能。<a href="http://blog.csdn.net/yore_/article/details/52733994" target="_blank" rel="external">RSA算法和AES算法性能测试</a></p>
<p>所以设计者结合了两种方案。两端通过非对称加密协商秘钥，攻击者因为拿不到私钥，是无法解开通信秘钥的。一旦协商成功，通过对称加密又解决了性能问题。</p>
</blockquote>
</blockquote>
</li>
<li><p>为什么使用三个随机数</p>
<blockquote>
<blockquote>
<p>还是为了进一步加强安全，客户端或者服务端生成的随机数可能是伪随机的，有可能被攻击者猜出，但是如果三个伪随机的数一起使用就大大加强了随机性，这样攻击者就很难破解了。</p>
</blockquote>
</blockquote>
</li>
<li><p>为什么最后要做hash验证</p>
<blockquote>
<blockquote>
<p>为了保证两端通信中的数据不会做篡改，由于HASH算法，可以保证唯一性，所以如果中间消息被人篡改，就可以断开链接。</p>
</blockquote>
</blockquote>
</li>
</ol>
<p><strong>所以下面是非常建议的一个信道传输加密的方案</strong>：</p>
<ol>
<li>使用随机数做对称加密秘钥，将对称加密秘钥使用公钥进行非对称加密传给后端。这样因为秘钥随机，所以即使客户端被破解，也拿不到任何对称秘钥。而公钥进行动态获取，避免私钥泄露带来的问题。</li>
<li>使用非对称加密秘钥，可以保证网络数据即使劫持，因为没有私钥，也解不出来对应的加密秘钥，所以加密的隐私数据也是安全的</li>
<li>两者结合，可以保证一定的性能要求。</li>
<li>对数据进行加签（加盐+hash算法），保证中间的数据不会篡改。</li>
</ol>
<p>ps:用户的密码，因为保密性要求更高。建议的算法是做HMAC哈希做脱敏，然后使用非对称加密给后端。</p>
<h2 id="3-常用的网络传输攻击手段"><a href="#3-常用的网络传输攻击手段" class="headerlink" title="3. 常用的网络传输攻击手段"></a>3. 常用的网络传输攻击手段</h2><p>先思考下，刚才的通信链路有三个参与者：</p>
<ol>
<li>客户端</li>
<li>传输信道</li>
<li>服务端</li>
</ol>
<p>如果新加入一个攻击者，他想要窃取用户的隐私数据，他该怎么做？常见的做法：</p>
<ol>
<li>攻击客户端。对于IOS系统来说，非越狱手机，由于权限问题，几乎无法攻击（之前<a href="https://www.baidu.com/link?url=gtxpH2omxSt5NpX-5RmuUYCFmWA-C49q7fQPWnJMO7wtUCpSIXTuEoYZ4B94QDc9Po6lrX7SzKvtEMH8R46XGfGKtnx42FxROp5zbVZ6Irm&amp;wd=&amp;eqid=aa656a8100001a250000000659127d0b" target="_blank" rel="external">XcodeGhost</a>真的是很nb的攻击思路）。对于越狱手机，通过HOOK API，然后重新打包应用，诱导用户下载。或者劫持系统的输入框等常用控件。相关的以后整理输出。但是从移动APP来说，直接攻击APP带来的危害和利用性很低，通常只会泄露很少的用户信息。大多是利用来薅羊毛的。</li>
<li>攻击传输信道。攻击手段有中间人攻击，DNS劫持等。</li>
<li>攻击服务端。也非常难做到。一般是模板注入，撞库等。</li>
</ol>
<p>这里面其实最容易的就是攻击传输信道。排除技术术语，手段有：</p>
<ol>
<li>伪装成正常的客户端攻击服务端</li>
<li>伪装成正常的服务端，劫持客户端数据</li>
<li>监听修改信道数据</li>
</ol>
<p>这几种怎么解决？</p>
<p>问：如何处理伪装成正常的客户端攻击服务端</p>
<blockquote>
<p>在认为客户端app本身是无法攻破的前提下：</p>
<ol>
<li>请求中一定加入签名策略。攻击者不知道签名策略是无法仿造请求的，也防止劫持者修改。发现签名不对，服务端认为是假的客户端。</li>
<li>请求中一定加入请求防重放策略。服务端发现是之前的请求，重复发送过来的（可能只有签名不一致），应该忽略</li>
<li>加入风险控制策略。比如异地登陆，同一设备ip反复请求，一些金融类app也会加入公安部认证的风控系统，防止一些有金融犯罪前科的用户请求。后端使用风控策略，禁止用户登录，或者强制要求用户再次身份认证，比如手机验证码认证。</li>
</ol>
</blockquote>
<p>问：如何处理监听修改信道数据<br>&gt;</p>
<blockquote>
<ol>
<li>请求关键数据做加密，加密方案建议使用上面提到的加密方案。这样即使被监听，拿到数据也无法处理</li>
<li>加入签名，防止数据篡改。</li>
</ol>
</blockquote>
<p>问：如何处理伪装成正常的服务端，劫持客户端数据</p>
<blockquote>
<p>这一种方式是目前攻击最常见且有效的手段。使用http的时候，因为没有任何认证措施，通过ARP或者DNS劫持，非常容易将网址定向到其他攻击者的地址，攻击者可以做劫持和修改相关数据。所以HTTP现在已经被各大平台所抛弃。很多开发遇到的访问一个h5页面，被运营商强插入广告就是这么做的。解决办法就是正确的使用HTTPS</p>
</blockquote>
<p>HTTPS，很大一部分作用就是解决上述问题。也就是通过SSL握手，校验服务端证书，达到验证是否是伪装的服务端的目的。HTTPS握手阶段算法原理都是安全的，只有验证身份这一步有漏洞，即只要想办法让客户端认为证书是可信的，证书里面的公钥就是生成者的公钥，自然就有相对应的私钥，后面非对称加密生成的对称秘钥就可以被截取到，造成整个链路不安全。如何攻击这个策略，行业上主要称为<strong>中间人攻击</strong>。</p>
<h2 id="4-SSL证书"><a href="#4-SSL证书" class="headerlink" title="4. SSL证书"></a>4. SSL证书</h2><p>可以说<strong>验证SSL证书是整个HTTPS的关键</strong>，如果这一步出问题，后面的就没有任何安全可言。而对于我们前端开发来说，SSL证书也是最需要关注的地方。</p>
<p>这里讲两个问题。SSL证书是什么？为什么通过SSL证书可以防止攻击者伪装成服务端。</p>
<h3 id="4-1-SSL证书是什么"><a href="#4-1-SSL证书是什么" class="headerlink" title="4.1 SSL证书是什么"></a>4.1 SSL证书是什么</h3><p>SSL证书是一个文件。里面的内容包括：用户的信息、用户的公钥、还有CA中心对该证书里面的信息的签名。<br>一个证书的实例：</p>
<p>打开safari，打开百度，<code>https://www.baidu.com</code>,在地址栏点击锁按钮，然后选显示证书。</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_https_cer.png" alt=""></p>
<p>里面的内容只有几个需要关注的：</p>
<ol>
<li>常用名称：<code>baidu.com</code> 。客户端或浏览器，根据常用名称和访问的域名做匹配，访问的域名和证书的域名不一致，就会拒绝访问，达到<strong>防止域名劫持的目的</strong>。这个信息可以被伪造。</li>
<li>公共密钥：SSL握手生成的第二段随机串是通过这个公钥来加密的。这个信息可以被伪造，但是伪造没有异议。（想知道为啥的可以看看证书生成的步骤。）</li>
<li>签名：是对整个证书内容做hash之后，使用颁发机构的<strong>私钥</strong>加密的值。这个信息可以被伪造，但是伪造没有异议。</li>
<li>签名者信息：颁发机构的信息，由于验证上一级的证书信息。这个信息可以被伪造。</li>
<li>证书有效期。这个信息可以被伪造。</li>
</ol>
<p>可以看到在百度这个证书上面还有两个证书，这是因为百度这个证书是有GS这个机构的二级机构颁发的，而GS这个二级机构是由GS的CA根证书颁发的。</p>
<p>也就是证书有证书链的概念，即这个证书可能是上一层机构颁发的，从CA根证书开始-&gt;二级CA证书-&gt;三级CA证书-&gt;…。</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_http_ssl_chain.png" alt=""></p>
<p>注：来自<a href="http://blog.csdn.net/shen_guo/article/details/49891459" target="_blank" rel="external">SSL 之证书链</a></p>
<h3 id="4-2-SSL证书如何验证的"><a href="#4-2-SSL证书如何验证的" class="headerlink" title="4.2 SSL证书如何验证的"></a>4.2 SSL证书如何验证的</h3><p>推荐这篇文章，是目前看到讲的最清楚。<a href="http://www.2cto.com/article/201607/523509.html" target="_blank" rel="external">浅析HTTPS中间人攻击与证书校验</a></p>
<p>根据HTTPS协议，服务端会在握手的时候将证书传送给客户单，<strong>而且是将整个证书链发过来</strong>。</p>
<p>通常的验证传过来的证书是否有效的步骤为：</p>
<ol>
<li>验证证书的常用名称是否是访问的域名，是否在有效期内。（域名校验+有效期校验）</li>
<li>计算这个证书内容的散列值得到MD5-a，然后用颁发机构的公钥解密这个证书的签名得到MD5-b，比较两个值是否相同，如果相同说明这个证书确实是上个颁发机构颁发的。</li>
<li>重复上面的操作，直到验证到CA根证书。CA证书是自签名的，也就是签名是用自己的私钥签名的。<br>可是CA根证书签名是用自己的私钥做签名，怎么去验证这个证书是否正确呢？</li>
</ol>
<p>最终上面的问题简化为：</p>
<h3 id="4-3-如何验证CA根证书有效性"><a href="#4-3-如何验证CA根证书有效性" class="headerlink" title="4.3 如何验证CA根证书有效性"></a>4.3 如何验证CA根证书有效性</h3><p>最终层层拨茧，HTTPS的安全性关键钥匙就在这一章了。</p>
<p>CA根证书有两种生成方式：</p>
<ol>
<li>由可信的颁发机构办法</li>
<li>本地自己生成</li>
</ol>
<p>对于第一种，因为可信的颁发机构很少，这些机构的CA证书会默认保存在浏览器里或者手机操作系统里，这种证书的有效性会由办法机构保证。不过这种证书需要向颁发机构申请，颁发机构会花时间去进行公司域名身份等信息验证，所以花费也不少。</p>
<p>对于第二种，本地生成的证书（后面会附录如何生成自签名证书），证书常用的信息都可以生成，可以认为证书信息内容都不可靠，尤其是证书中的域名。使用自制证书在浏览器会弹出警告不可信，用户可以手动添加到信任列表里，之后可信了才可以访问，12306之前让下载证书导入，就是这个原因。在应用APP里，如果使用默认配置，会拒绝，返回SSL验证失败。</p>
<p>这时候两种办法：</p>
<p>第一种</p>
<blockquote>
<p>安装描述文件到系统里。在安装charles过程中，其中一步就是打开一个网址，在弹出安装的时候，安装这个证书，也可以把这个证书下载到云盘里，然后打开。这个过程需要用户手动授权。</p>
</blockquote>
<p>第二种</p>
<blockquote>
<p>把这个根证书，埋入APP里,然后设置为证书锚点（可以设置多个），然后在SSL握手需要验证证书的时候，这样系统会认为这个证书是有效的。这个方案也是很多自签名证书进行校验的方法。</p>
</blockquote>
<h3 id="4-4-中间人攻击"><a href="#4-4-中间人攻击" class="headerlink" title="4.4 中间人攻击"></a>4.4 中间人攻击</h3><p>中间人攻击是最常见的攻击HTTPS手段。</p>
<p>建议看这篇文章：<a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/" target="_blank" rel="external">iOS安全系列之二：HTTPS进阶</a></p>
<p>看到上面的验证手段，其实关键就在于如何信任CA根证书上面。攻击者就是想尽一切办法让客户端安装他自己的CA证书到你的手机里。</p>
<p>如果手机没有越狱，一定会引诱你去安装这个证书，并且手动设为可信。一旦信任，在访问服务器的时候，攻击者通过代理劫持，通过这个信任的CA证书，生成对应的域名的证书。最终因为域名可信，有效期可信，证书可信所以整个HTTPS建立成功，攻击者拿到相关的数据。</p>
<p>使用charles抓包的整个过程，其实就是中间人攻击的过程。</p>
<p>下面是charles开启SSL代理后，访问新浪弹出的证书信息：</p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/safe_https_fake.png" alt=""></p>
<p>提示：<strong>对于用户来说，不要信任任何CA证书，不安装任何描述文件是最安全的方法。</strong>比如安装飙车软件，让你信任一个证书。比如链接外部wifi，提示你安装证书才可以链接。比如翻墙设置代理，提示你安装信任证书。描述文件在通用-&gt;描述文件与设备管理中找到。</p>
<h3 id="4-5-校验证书的姿势"><a href="#4-5-校验证书的姿势" class="headerlink" title="4.5 校验证书的姿势"></a>4.5 校验证书的姿势</h3><p>校验证书有两种方案：</p>
<blockquote>
<blockquote>
<p>弱校验</p>
</blockquote>
</blockquote>
<p>对于服务端证书，校验下面的case。</p>
<ol>
<li>校验证书的域名</li>
<li>校验证书的有效期</li>
<li>校验证书链和证书的有效性</li>
</ol>
<p>保证这三者有效，已经可以解决大部分的攻击了，对于大部分APP已经试用。唯一的风险就是中间人攻击，被安装CA证书之后，存在着风险，但是攻击难度已经大大增加了。<em>AFNetworking框架默认采用的就是这个策略</em>。</p>
<blockquote>
<blockquote>
<p>强校验</p>
</blockquote>
</blockquote>
<p>将证书放入APP中作为证书锚点。在上面的基础上在验证证书。这样可以完全保证服务端的证书是真正需要的证书，从而真正解决中间人攻击。</p>
<p>下面主要讲下强校验面临的坑，各位开发一定要注意。</p>
<h3 id="4-6-证书强校验的坑"><a href="#4-6-证书强校验的坑" class="headerlink" title="4.6 证书强校验的坑"></a>4.6 证书强校验的坑</h3><p>证书是有有效期的，尤其是非自制证书，通常都在三年以内，自制证书一般没有限制（所以很多资料根本不谈这个问题）。一旦有效期过了，服务端就需要更换证书,但是由于APP存在发版的情况，老的APP由于所有链接失败，导致老APP任何请求都失效，然后无法通知用户更新，老用户也不知道因为什么访问失败。（这些都是血的教训啊）</p>
<p>有几个建议的地方：</p>
<ol>
<li>尽量埋CA证书，因为CA证书的有效期要长，有足够的时间准备。</li>
<li>有些通道不要使用证书强校验，比如检查升级，一些热修复策略，尽量使用自有的安全逻辑保证安全。</li>
</ol>
<p>上面的是尽量降低风险，该出问题的时候还是会出，有一些不完美的方案大家可以参考下：</p>
<p>方案1：动态更新证书。</p>
<blockquote>
<blockquote>
<p>在APP中放入RSA公钥，应用启动的时候，证书信息通过私钥加密，发送给前端保存，前端把这个新证书和埋入的证书一起做锚点，进行验证。这样可以保证老APP可以使用一段时间。缺点是这个下发的机制要尽量安全可靠，有可能被攻击者利用，所以方案复杂一些。</p>
</blockquote>
</blockquote>
<p>方案2：只验证证书的公钥</p>
<blockquote>
<blockquote>
<p>只使用证书的公钥进行验证，因为更换证书，一般是通过.csr文件生成crt证书文件的（也就是证书文件），在.csr文件没变的情况下，生成的证书的公钥是一致的，也就即使服务端更换了证书，只要公钥不变，依然可以通过验证。而中间人是没法通过公钥反推出私钥的，即使知道了公钥也没办法解密。所以验证公钥也是相对安全的。缺点是如果新的证书换了公钥还是出问题。我遇到的case就是需要更换私钥和证书算法，公钥也不一样了。</p>
</blockquote>
</blockquote>
<p>其他不太靠谱的方案：</p>
<p>方案3：</p>
<blockquote>
<blockquote>
<p>在弱校验的基础上，加上验证颁发机构。只要读到颁发机构是可信的，证书就认为是有效的。可以解决第三方抓包工具的抓包问题，因为第三方抓包工具，一般使用自己的颁发机构，和实际的颁发机构不一致。缺点是，证书是可以完全伪造的，包括颁发结构的名字，有效期等等都可以伪造。</p>
</blockquote>
</blockquote>
<p>方案4：</p>
<blockquote>
<blockquote>
<p>信任无效的证书。 信任无效的证书，但是做本地证书校验，在失效的一段时间内，后端先不部署新证书，在新版本里面提前埋入新证书，在几个版本后再上线新的证书。优点是简单，不怕哪天忘了更换证书导致出问题。缺点是信任失效的证书，如果真的有需求要强制更换证书，就没办法处理。</p>
</blockquote>
</blockquote>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><h3 id="如何生成自签名证书"><a href="#如何生成自签名证书" class="headerlink" title="如何生成自签名证书"></a>如何生成自签名证书</h3><p>参考 <a href="https://www.zybuluo.com/qidiandasheng/note/713956" target="_blank" rel="external">深入解析HTTPS</a>和<a href="https://my.oschina.net/wayhk/blog/491958?p=1" target="_blank" rel="external">利用OpenSSL创建自签名的SSL证书</a> 和 <a href="http://blog.csdn.net/sdcxyz/article/details/47220129" target="_blank" rel="external">自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名</a></p>
<ol>
<li><p>生成私钥</p>
<p> <code>openssl genrsa -out ca.key 2048</code> </p>
</li>
<li><p>利用私钥创建根证书</p>
<p><code>openssl req -new -x509 -days 36500 -key ca.key -out ca.crt</code></p>
<p>弹出的对话框按照提示填写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Guangdong</div><div class="line">Locality Name (eg, city) []:Shenzhen</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:BL.inc</div><div class="line">Organizational Unit Name (eg, section) []:</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:BL</div><div class="line">Email Address []:</div></pre></td></tr></table></figure>
</li>
<li><p>创建SSL证书私钥</p>
<p><code>openssl genrsa -out server.key 2048</code></p>
</li>
<li><p>使用刚才的私钥签名</p>
<p><code>openssl req -new -key server.key -out server.csr</code></p>
<p>弹出的对话框按照提示填写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Guangdong</div><div class="line">Locality Name (eg, city) []:Shenzhen</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:BL.inc</div><div class="line">Organizational Unit Name (eg, section) []:</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:*.sina.com.cn</div><div class="line">Email Address []:</div><div class="line"></div><div class="line">Please enter the following &apos;extra&apos; attributes</div><div class="line">to be sent with your certificate request</div><div class="line">A challenge password []:1111</div><div class="line">An optional company name []:</div></pre></td></tr></table></figure>
</li>
</ol>
<p>   注意，这里的Common Name 应该和实际的域名匹配。而且生成的.csr这个文件最好长期保留，下次过期的时候，建议直接用这个文件做签名。如果是向CA颁发机构申请，提交的文件也是这个文件。</p>
<ol>
<li><p>对上一步的csr使用CA进行签名生成证书</p>
<p><code>openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt</code>   </p>
</li>
<li><p>如果有必要可以重复上面必要步骤，使用上一步的证书的.crt和.key继续签名下一级证书。</p>
<p>一些常用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl rsa -noout -text -in server.key 查看私钥信息</div><div class="line">openssl req -noout -text -in server.csr 查看签名请求信息</div><div class="line">openssl x509 -noout -text -in ca.crt 查看证书信息</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="MAC下使用Charles抓包"><a href="#MAC下使用Charles抓包" class="headerlink" title="MAC下使用Charles抓包"></a>MAC下使用Charles抓包</h3><p>参考 <a href="https://www.zybuluo.com/qidiandasheng/note/713956" target="_blank" rel="external">深入解析HTTPS</a> 和 <a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/" target="_blank" rel="external">iOS安全系列之二：HTTPS进阶</a></p>
<ul>
<li><p>安装Charles CA根证书 </p>
<p>点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certification …，会弹出如下提示，链接代理，手机浏览器输入chls.pro/ssl，就可以安装根证书了。 </p>
<p><img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_1.png" alt=""></p>
</li>
</ul>
<ul>
<li><p>设置SSL代理 </p>
<p>  点击Proxy-&gt;SSL Proxying Setting，勾选Enable SSL Proxying，然后点击Add输入要SSL代理的请求Host和Port，可以使用通配符来表示某一类请求。<br> <img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_2.png" alt=""></p>
<p> 或者在对应的请求上右键选择Enable SSL Proxying，就会把这一个请求加入到上面的SSL代理列表中（类似于点击Add的效果）。 </p>
<p> <img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_3.png" alt=""></p>
<p>  做完上述步骤后重新请求就能得到解密后的信息了。ps:抓取PC端的HTTPS包也类似，在Help-&gt;SSL Proxying中下载证书，双击安装证书，并选择始终信任即可。</p>
</li>
</ul>
<ul>
<li><p>在iPhone端设置HTTP代理</p>
<p>  在Mac上获取当前机器的IP地址：</p>
<p>  ifconfig en0:</p>
<p>  <img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_4.jpg" alt=""></p>
<p> ch将iPhone连接到与电脑相同的WiFi，在iPhone设置中：无线局域网 -&gt; 已连接WiFi右边的Info详情图标 -&gt; HTTP代理 -&gt; 手动 -&gt; 设置HTTP代理：</p>
<p> <img src="https://github.com/dishibolei/img/raw/master/safe/http/charles_5.jpg" alt=""></p>
<p> 设置完成之后，打开Safari随便访问一个网页，初次设置代理的话，Charles会弹出一个iPhone请求代理的确认框，点击Allow即可。然后在Charles上就可以看到iPhone上的HTTP请求了。为了避免Mac上的请求过多影响对被代理iPhone上HTTP请求的查看和调试，可以在Charles取消Mac的代理：Menu -&gt; Proxy -&gt; 取消勾选Mac OS X Proxy 即可。</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><p><a href="http://blog.csdn.net/gueter/archive/2007/03/08/1524447.aspx" target="_blank" rel="external">HTTP协议详解（真的很经典）</a></p>
</li>
<li><p><a href="https://github.com/mqttjs/MQTT.js" target="_blank" rel="external">MQTT_github</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/zhao1949/p/5545064.html" target="_blank" rel="external">说说http协议中的编码和解码</a></p>
</li>
<li><p><a href="https://my.oschina.net/cnlw/blog/168466" target="_blank" rel="external">HTTP协议之multipart/form-data请求分析</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/1ec3fa1ec00f" target="_blank" rel="external">苹果文档翻译 iOS10 NSAppTransportSecurity</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/2bfe1110f3b5" target="_blank" rel="external">iOS中的HTTPS, 你知道多少?</a></p>
</li>
<li><p><a href="http://www.open-open.com/lib/view/open1411260089562.html" target="_blank" rel="external">阮一峰：图解SSL/TLS协议</a></p>
</li>
<li><p><a href="http://kb.cnblogs.com/page/197396/" target="_blank" rel="external">SSL与TLS的区别以及介绍</a></p>
</li>
<li><p><a href="http://www.2cto.com/article/201607/523509.html" target="_blank" rel="external">浅析HTTPS中间人攻击与证书校验</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/LittleHann/p/3733469.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">SSL、TLS协议格式入门学习 - .Little Hann</a></p>
</li>
<li><p><a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/" target="_blank" rel="external">iOS安全系列之二：HTTPS进阶</a></p>
</li>
<li><p><a href="http://www.open-open.com/lib/view/open1461324289052.html" target="_blank" rel="external">HTTPS 理论详解与实践</a></p>
</li>
<li><p><a href="https://my.oschina.net/wayhk/blog/491958?p=1" target="_blank" rel="external">利用OpenSSL创建自签名的SSL证书</a></p>
</li>
<li><p><a href="http://blog.csdn.net/sdcxyz/article/details/47220129" target="_blank" rel="external">自签名证书和私有CA签名的证书的区别 创建自签名证书 创建私有CA 证书类型 证书扩展名</a></p>
</li>
<li><p><a href="https://www.zybuluo.com/qidiandasheng/note/713956" target="_blank" rel="external">深入解析HTTPS</a></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dishibolei.github.io/2017/05/08/我的第一篇博文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bolei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/08/我的第一篇博文/" itemprop="url">我的第一篇博文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-08T17:58:54+08:00">
                2017-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dishibolei.github.io/2017/04/14/test1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bolei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/14/test1/" itemprop="url">Learning AV Foundation(四)AVAsset元数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-14T09:32:50+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-AVAsset/MacHi%202017-04-14%2009-18-10.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇讲述的<code>AVAsset</code>元数据(可以简单理解成 比如一个mp3音频格式的model信息. title:xxxx, art:刘德华, album:专辑 爱你一万年…. 等这些数据的来源). 当然这种意义上的字段信息 属于<code>AVAsset</code>的一个属性。<code>AV Foundation</code>通过<code>AVAsset</code>封装来处理各种音频的元数据, <strong>比如从mp3文件中解析出来封面图(artwork)</strong>等。 本章的具体内容如下:</p>
<h3 id="理解资源含义"><a href="#理解资源含义" class="headerlink" title="理解资源含义"></a><strong>理解资源含义</strong></h3><h3 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a><strong>创建资源</strong></h3><ul>
<li>iOS Asset库</li>
<li>iOS iPod库</li>
<li>macOS iTunes库</li>
</ul>
<h3 id="异步载入"><a href="#异步载入" class="headerlink" title="异步载入"></a><strong>异步载入</strong></h3><h3 id="媒体元数据"><a href="#媒体元数据" class="headerlink" title="媒体元数据"></a><strong>媒体元数据</strong></h3><ul>
<li>元数据格式  <ol>
<li>QuickTime  </li>
<li>MPEG-4音频和视频(mp4)  </li>
<li>MP3  </li>
</ol>
</li>
</ul>
<h3 id="使用元数据"><a href="#使用元数据" class="headerlink" title="使用元数据"></a><strong>使用元数据</strong></h3><ul>
<li>查询元数据</li>
<li>使用<code>AVMetadataItem</code></li>
</ul>
<h3 id="创建MetaManager-Demo"><a href="#创建MetaManager-Demo" class="headerlink" title="创建MetaManager Demo"></a><strong>创建MetaManager Demo</strong></h3><ul>
<li>MediaItem(相当于Model)</li>
<li>MediaItem实现</li>
<li>数据转换器(model to AVMetadataItem || AVMetadataItem to mode)</li>
<li>DefaultMetadata默认转换</li>
<li>转换Artwork(唱片的封面或者专辑图那种)</li>
<li>转换注释</li>
<li>转换音轨数据(track)</li>
<li>转换唱片数据</li>
<li>转换风格数据(genre, eg: blue蓝调, classic古典,pop流行等126种..)</li>
<li>完成最终demo  </li>
</ul>
<h4 id="保存元数据"><a href="#保存元数据" class="headerlink" title="保存元数据"></a><strong>保存元数据</strong></h4><hr>
<h3 id="理解AVAsset资源含义"><a href="#理解AVAsset资源含义" class="headerlink" title="理解AVAsset资源含义"></a><strong>理解<code>AVAsset</code>资源含义</strong></h3><p><code>AVAsset</code>是一个不可变的抽象类,定义媒体资源混合呈现方式.里面包含音视频的<strong>曲目</strong>、<strong>格式</strong>、<strong>时长</strong>, 以及<strong>元数据NSData</strong>(二进制的bytes).</p>
<p><code>AVAsset</code>不用考虑媒体资源具有的两个范畴: </p>
<ul>
<li>提供对基本媒体格式的抽象层  </li>
<li>不用考虑处理因为不同格式获取内容方式不一样</li>
</ul>
<p>这意味着无论是处理<code>Quick Time</code>影片、<code>MPEG-4</code>视频还是<code>MP3</code>音频，框架提供统一的接口，我们只需要理解只有资源这个概念。这样做的目的是为了<strong>开发者在面对不同格式的内容时有一个统一的处理方法。不需要care多种编码器和容器格式因为细节不同而带来的困扰</strong>. 当然获取这些其余信息可以通过其它方式实现. <code>AVAsset</code>还隐藏了资源位置(GPS定位)信息,当处理一个媒体对象时，通过URL来初始化init. URL可以是Bundle里面 也可以是沙盒的本地文件系统URL.也可以从iPod库中取到的URL。还可以是远程服务器的音频流或视频流的URL。</p>
<p><code>AVAsset</code>属于低耦合组件方式的封装 让框架来处理那些繁重的工作, 我们就可以很方便的不用考虑文件位置的前提下获取或者载入媒体。由于不用care文件合适和文件位置等复杂的问题。<code>AVAsset</code>为开发者处理<code>timed media(时基媒体)</code>提供了一种简单统一的方式.</p>
<p><code>AVAsset</code>本身不是媒体资源. 可以把它理解成承载<code>timed media(时基媒体)</code>的容器类。它有很多描述自身元数据的媒体组成. <code>AVAssetTrack</code>才是我们真正存储媒体资源的统一媒体类型。并对每个资源建立相应的model.  <code>AVAssetTrack</code>最常见的形式就是 音频流和视频流, 但是他还可以用于表示诸如<strong>文本</strong>、<strong>副标题</strong>、<strong>隐藏字幕</strong>等媒体类型. 如下示意图理解<code>AVAsset</code> 和 <code>AVAssetTrack</code></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-AVAsset/MacHi%202017-04-14%2011-44-16.png" alt=""></p>
<p><em><strong><code>AVAsset.tracks</code></strong></em> 如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *tracks;</div></pre></td></tr></table></figure>
<p> 资源曲目可通过tracks属性访问到. 该属性返回一个NSArray的数组,这个数组中的元素就是专辑包含的所有曲目. 此外，<code>AVAsset</code>还可以通过标识符、媒体类型或媒体特征等信息找到相应的曲目.这使得在未来更高级的处理中我们可以很容易获取一组需要的曲目</p>
<h4 id="创建资源-1"><a href="#创建资源-1" class="headerlink" title="创建资源"></a><strong>创建资源</strong></h4><p>当为一个现有的媒体资源创建<code>AVAsset</code>对象时, 可以通过URL对它的进行的初始化来实现. 一般来说是一个本地文件URL, 也可以是远程的资源URL</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">    <span class="built_in">NSURL</span> *assetURL = <span class="comment">//....</span></div><div class="line">    <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL: assetURL];</div><div class="line">```    </div><div class="line"></div><div class="line">`<span class="built_in">AVAsset</span>`是个抽象类, 它不能直接被实例化. 当使用`assetWithURL:`方法创建实例时,实际上是创建了`<span class="built_in">AVAsset</span>`的子类`<span class="built_in">AVURLAsset</span>` 有时候会直接使用这个类, 因为它允许通过传递选项字典来精细调整资源的创建方式, 举个例子,比如创建 用在音频或视频编辑场景中的资源, 可能希望传递一个选项(option)的字典来告诉程序提供更精确的时长和计时等信息 例如:</div><div class="line"></div><div class="line">``` objc</div><div class="line">    <span class="built_in">NSURL</span> *assetURL = <span class="comment">//....</span></div><div class="line">    <span class="built_in">NSDictionary</span> *options = @&#123;<span class="built_in">AVURLAssetPreferPreciseDurationAndTimingKey</span>:@YES&#125;;</div><div class="line">    <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL: assetURL];</div><div class="line">```  </div><div class="line">这里传递的是希望得到稍长一点的加载事件,来获取更精确的时长及时间信息.很多常见的位置是开发时大家想创建资源对象的地方. 在iOS设备上我们希望在用户的照片库中访问视频文件, 或者在iPod库中访问歌曲. 在Mac上 我们希望从用户的iTunes库中找到媒体项. 借助iOS和macOS中的这些辅助framework我们可以使用上边的媒体资源。下面介绍一下这些要用到的framework的例子</div><div class="line"></div><div class="line"><span class="meta">##### iOS Assets库</span></div><div class="line"></div><div class="line">在iOS上拍照或者通过前置和后置相机捕捉到的音视频,它们保存在用户的照片库中.iOS提供的Assets库框架可以实现从照片库中读写的功能, 下例从用户资源库中的视频创建一个<span class="built_in">AVAsset</span>:</div><div class="line"></div><div class="line">``` objc</div><div class="line">ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];</div><div class="line">    [library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">        <span class="comment">//Filter down to only videos</span></div><div class="line">        [group setAssetsFilter:[ALAssetsFilter allVideos]];</div><div class="line">        </div><div class="line">        <span class="comment">//Grab the first video returned</span></div><div class="line">        [group enumerateAssetsAtIndexes:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:<span class="number">0</span>] options:<span class="number">0</span> usingBlock:^(ALAsset *result, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">            <span class="keyword">if</span> (result) &#123;</div><div class="line">                <span class="keyword">id</span> representation = [result defaultRepresentation];</div><div class="line">                <span class="built_in">NSURL</span> *url = [representation url];</div><div class="line">                <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:url];</div><div class="line">                <span class="comment">//创建 调用一些其它API</span></div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125; failureBlock:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [error localizedDescription]);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>上面是如何获取保存在 相册中的视频资源(iOS10.10以后就废弃了上述方式) 获取出筛选结果的第一个视频, 库中的条目全部被建模为<code>ALAsset</code>对象, 为默认的呈现方式选用<code>ALAsset</code>类型返回一个<code>ALAssetRepresentation</code>对象,它提供了一个适用于创建<code>AVAset</code>的URL.</p>
<h5 id="iOS-iPod库"><a href="#iOS-iPod库" class="headerlink" title="iOS iPod库"></a>iOS iPod库</h5><p>我们获取媒体的一个常见位置就是用户的iPod库. <code>MediaPlayer</code> framework 框架提供了API, 用于在iPod库中查询和获取条目. 当找到想获取的item时, 可以得到一个存储的URL并使用这个得到的URL初始化一个资源, 如下例所示:  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//艺术家</span></div><div class="line"><span class="built_in">MPMediaPropertyPredicate</span> *artistPredicate = [<span class="built_in">MPMediaPropertyPredicate</span> predicateWithValue:<span class="string">@"刘德华"</span> forProperty:<span class="built_in">MPMediaItemPropertyArtist</span>];</div><div class="line"><span class="comment">//专辑</span></div><div class="line"><span class="built_in">MPMediaPropertyPredicate</span> *albumPredicate = [<span class="built_in">MPMediaPropertyPredicate</span> predicateWithValue:<span class="string">@"真永远"</span> forProperty:<span class="built_in">MPMediaItemPropertyAlbumTitle</span>];</div><div class="line"><span class="comment">//歌曲名称</span></div><div class="line"><span class="built_in">MPMediaPropertyPredicate</span> *songPredicate = [<span class="built_in">MPMediaPropertyPredicate</span> predicateWithValue:<span class="string">@"爱你一万年"</span> forProperty:<span class="built_in">MPMediaItemPropertyTitle</span>];</div><div class="line"><span class="comment">//查询</span></div><div class="line"><span class="built_in">MPMediaQuery</span> *query = [[<span class="built_in">MPMediaQuery</span> alloc] init];</div><div class="line">[query addFilterPredicate:artistPredicate];</div><div class="line">[query addFilterPredicate:albumPredicate];</div><div class="line">[query addFilterPredicate:songPredicate];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *result = [query items];</div><div class="line"><span class="keyword">if</span> (result.count &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">MPMediaItem</span> *item = result[<span class="number">0</span>];</div><div class="line">    <span class="built_in">NSURL</span> *assetURL = [item valueForProperty:<span class="built_in">MPMediaItemPropertyAssetURL</span>];</div><div class="line">    <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:assetURL];</div><div class="line">    <span class="comment">// Asset 信息</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MediaPlayer</code>framework提供了一个为<code>MPMediaPropertyPredicate</code>的类,用户帮助用户在iPod库中查找到具体内容所用的查询语句<br>上边举例一个例子: 在<code>刘德华</code>的<code>真永远</code>(真永远专辑)  唱片中查找<code>爱你一万年</code>这首歌, 执行完查询 会返回这个媒体 条目的资源URL属性(<code>MPMediaItemPropertyAssetURL</code>). 并使用这个属性创建<code>AVAsset</code></p>
<h5 id="macOS-iTunes库"><a href="#macOS-iTunes库" class="headerlink" title="macOS iTunes库"></a>macOS iTunes库</h5><p>在 macOS(以前叫 OS X)上, iTunes是用户的媒体资源中心. 要识别这个库中的资源, 我们通常要对iTunes音乐目录中的iTunes Music Library.xml 文件进行解析, 从而得到相关数据. 不过在 Mac OS X 10.8山狮之后 有了比较简单的方法–<code>iTunesLibrary</code>framework.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ITLibrary *library = [ITLibrary libraryWithAPIVersion:<span class="string">@"1.0"</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSArray</span> *items = library.allMediaItems;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *query = <span class="string">@"artist.name == '刘德华'"</span></div><div class="line">                      <span class="string">"album.title == '真永远'"</span></div><div class="line">                      <span class="string">"title == '爱你一万年'"</span>;</div><div class="line">    <span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:query];</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *songs = [items filteredArrayUsingPredicate:predicate];</div><div class="line">    <span class="keyword">if</span> (songs.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        ITLibMediaItem *item = songs[<span class="number">0</span>];</div><div class="line">        <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:item.location];</div><div class="line">        <span class="comment">// asset info</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>iTunesLibrary</code>框架并没有像MediaPlayer框架那样给出具体的查询API. 不过开发者可使用标准的Cocoa NSPredicate(谓词)类来构建一个复杂的查询,当筛出需要的media item集合后，可使用<code>ITLibMediaItem</code>的<code>location</code>属性得到一个URL并创建<code>AVAsset</code>.</p>
<h4 id="异步载入-1"><a href="#异步载入-1" class="headerlink" title="异步载入"></a>异步载入</h4><p><code>AVAsset</code>具有多种有用的方法和属性, 可以提供有关资源的信息, 比如时长、创建日期、元数据等.<br><code>AVAsset</code>还包含一些用于获取和使用曲目集合的方法. 不过有一点很重要, 就是当创建时资源就是对基础文件的处理, <code>AVAsset</code> 采用一种lazy load的加载方式, 提升了快速创建资源和立即载入的速度.<br><strong><em>注意<code>AVAsset</code>的属性访问是同步的,如果正在请求的属性没有预先载入,程序就会阻塞,直到它做出响应为止</em></strong>这个搞法不是很好,eg: avasset.duration 可能是个比较耗时的操作,如果使用MP3文件时没有在头文件中设置<code>TLEN</code>标签,这个标签用于定义duration值,则整个音频曲目都需要进行解析来准确的知道它的duration, 如果在主线程做这样的访问操作就会阻塞主线程,直到相关操作完成为止, APP可能会出现卡顿,导致系统监视器介入,并终止APP运行,如果解决这种问题,我们应该使用异步的 方式来查询资源属性.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">AVKeyValueStatus</span>)statusOfValueForKey:(<span class="built_in">NSString</span> *)key error:(<span class="built_in">NSError</span> * _Nullable *)outError;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)loadValuesAsynchronouslyForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))handler;</div></pre></td></tr></table></figure>
<p>可以使用statusOfValueForKey:error:方法查询一个给定的属性状态,返回一个<code>AVKeyValueStatus</code>的枚举值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="built_in">AVKeyValueStatus</span> : <span class="built_in">NSInteger</span> &#123;</div><div class="line">    <span class="built_in">AVKeyValueStatusUnknown</span>,</div><div class="line">    <span class="built_in">AVKeyValueStatusLoading</span>,</div><div class="line">    <span class="built_in">AVKeyValueStatusLoaded</span>,</div><div class="line">    <span class="built_in">AVKeyValueStatusFailed</span>,</div><div class="line">    <span class="built_in">AVKeyValueStatusCancelled</span></div><div class="line">&#125; <span class="built_in">AVKeyValueStatus</span>;</div></pre></td></tr></table></figure>
<p>用于表示当前所请求的属性的状态, 如果状态不是<code>AVKeyValueStatusLoaded</code>说明此时这个属性可能导致程序卡顿,要异步载入一个给定的属性loadValuesAsynchronouslyForKeys:completionHandler:方法,参数keys 是一个或多个<code>资源属性名</code>的数组和一个callback,当资源处于回应状态时,就会调用这个<code>completionHandler</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *assetURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"384551_1438267683"</span> withExtension:<span class="string">@"mov"</span>];</div><div class="line">   <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:assetURL];</div><div class="line">   <span class="comment">//异步加在 tracks property</span></div><div class="line">   <span class="built_in">NSArray</span> *keys = @[<span class="string">@"tracks"</span>];</div><div class="line">   [asset loadValuesAsynchronouslyForKeys:keys completionHandler:^&#123;</div><div class="line">       <span class="comment">//查询tracks的属性状态</span></div><div class="line">       <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">       <span class="built_in">AVKeyValueStatus</span> status = [asset statusOfValueForKey:<span class="string">@"tracks"</span> error:&amp;error];</div><div class="line">       <span class="keyword">switch</span> (status) &#123;</div><div class="line">           <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusLoaded</span>:</div><div class="line">               <span class="comment">//继续处理后续逻辑</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusFailed</span>:</div><div class="line">               <span class="comment">//有error</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusCancelled</span>:</div><div class="line">               <span class="comment">// 处理意外取消等情况的逻辑</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           </div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>这里用bundle中的<code>QuickTime</code>电影创建一个AVAsset, 并异步载入该对象的<code>tracks</code>属性.在<code>completionHandler</code> block中,我们希望通过调用资源的statusOfValueForKey:error:方法来拿出请求属性的状态,NSError用于判断资源包含错误信息. <em><em>注意:<code>completionHandler:</code>block可能在任意一个队列中调用,在对UI界面做出相应更新之前,必须先回到主线程队列,否则必被坑！！！</em></em></p>
<blockquote>
<p><em><em>注意:上面的demo载入了一个tracks属性,其实可以在一个吊用中请求多个属性,如果请求多个属性的时候需要注意以下两点:</em></em><br>(1) 每次调用 <code>loadValuesAsynchronouslyForKeys:completionHandler:</code>方法时只会调用一次<code>completionHandler</code>block, 调用这个callback的次数不是根据传递给这个方法的key个数决定的.<br>(2) 需要为每个请求的属性调用<code>statusOfValueForKey:error:</code>,不能假设所有属性都返回相同的状态值.</p>
</blockquote>
<h3 id="使用元数据-1"><a href="#使用元数据-1" class="headerlink" title="使用元数据"></a><strong>使用元数据</strong></h3><p>当创建一个媒体应用程序时,了解该媒体的组织格式非常重要, 简单的展示一堆文件名也许在文件不多的时候还能接受, 如果大规模批量的文件需要展示就比较蛋疼了, 我们真正需要的是 <em>找到一种方法对媒体进行描述,当用户可以方便的找到、识别和组织这些媒体.</em> 我们所使用的<code>AV Foundation</code>中的主要媒体格式(<em>.mp4、</em>.mp3、<em>.mov、</em>.mkv…..)都可以嵌入描述其内容的元数据.因为各种媒体格式的描述不尽相同,要搞一套通用的策略去解析各种媒体的格式文件,这要求我们对底层技术有一些了解.不过<code>AV Foundation</code>让这些变得简单,因为它使开发者不需要考虑大多数特定格式的细节; 在处理媒体元数据方面, AV Foundation`提供了一套统一的方法.</p>
<h4 id="元数据格式"><a href="#元数据格式" class="headerlink" title="元数据格式"></a>元数据格式</h4><p>虽然存在多种格式的媒体资源,但是我们在Apple环境下遇到的媒体类型主要有4种, 分别是:<code>QuickTime(mov)</code>、<code>MPEG-4 video(mp4和m4v)</code>、<code>MPEG-4 audio(m4a)</code>和<code>MPEG-Layer Ⅲ audio(mp3)</code>. 虽然<code>AV Foundation</code>处理这些文件中嵌入的元数据时都使用一个接口, 但是理解这些不同类型资源的元数据如何存储及存储位置仍然很有价值. 这里只做概述, 但是如果深入研究这些都是必学的基础.</p>
<ol>
<li><p>QuickTime<br> <code>QuickTime</code>是苹果自己开发的一种跨平台媒体架构, 其中一部分是Quick File Format规范, 定义了 .mov文件的内部结构.<code>QuickTime</code>文件由一种称为<code>atom</code>的数据结构组成. 一般规则是这样的:<br> 一个<code>atom</code>包含了描述媒体资源的某一方面的数据, 或者嵌套包含其它<code>atom</code>,但不能两者都包含.有时候苹果自己的方法实现可能会违背这一规则.<code>atom</code>以一种复杂的树状结构组合在一起, 详细的对布局、音频样本格式、视频帧信息乃至需要呈现的元数据信息(作者,版权等)做了描述.   </p>
<p> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-AVAsset/atom.jpg" alt=""><br> <em>为了能记住<code>atom</code>我把它戏称为<code>阿童木</code>哈哈-跟阿童木压根没啥关系</em>.  </p>
<p> 了解<code>QuickTime</code>的一个好办法是用十六进制编辑器中打开一个.mov格式的文件.(常见的十六进制编辑器有Hex Fiend或Synalyze It! Pro).典型的十六进制工具会将一个真实的<code>QuickTime</code>文件的数据显示出来,但其中的结构和<code>atom</code>间的关系不是很直观能理解,推荐苹果有一个<code>Atom Inspector</code>工具.这个工具将atom结构以<code>NSOutlineView</code>(树形UI控件类似UITableView)方式显示.所以<code>atom</code>的树形瓜西会很清晰的看到,这个工具还提供一个小型的十六进制查看器,可以从中查看到<strong>实际字节布局</strong>.</p>
<p> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-AVAsset/atom_inspector.png" alt=""></p>
<p> 下载地址:<a href="http://adcdownload.apple.com/QuickTime/atom_inspector/atom_inspector.dmg" target="_blank" rel="external">Atom Inspector 猛击这里</a>  貌似需要登录开发者帐号<br> 下载中心:<a href="https://developer.apple.com/download/more/" target="_blank" rel="external">苹果官方软件下载中心</a>  貌似需要登录开发者帐号 </p>
<p> 下图就是atom格式<br> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-AVAsset/quick_time_atom_structure.jpeg" alt=""><br> <em>atom格式</em></p>
<p> <strong><code>QuickTime</code>文件最少包含三个高级的<code>atom</code></strong></p>
<ul>
<li><strong>用于描述文件类型和兼容类型的<code>fypy</code></strong></li>
<li><strong>包含实际音频和视频媒体的<code>mdat</code></strong></li>
<li><p><strong>moov atom(moo-vee) 媒体资源的所有细节做了完整描述包括原始的二进制数据</strong></p>
<p>下图是我实际测试一个mov文件的atom<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-AVAsset/quick_time_atom_structure_real.jpeg" alt=""><br><em>实测</em></p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="bolei" />
          <p class="site-author-name" itemprop="name">bolei</p>
           
              <p class="site-description motion-element" itemprop="description">专注于IOS客户端安全、性能、架构和react-native技术</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/dishibolei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bolei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
