<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS,安全,加解密,字符编码,大小端,国密算法,HASH,对称加密,非对称加密," />





  <link rel="alternate" href="/atom.xml" title="萝卜的空间" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="导读客户端经常遇到需要对数据进行加密的情况，那应该如何加密，选用什么样的加密算法，是本文想要讨论的问题。">
<meta name="keywords" content="iOS,安全,加解密,字符编码,大小端,国密算法,HASH,对称加密,非对称加密">
<meta property="og:type" content="article">
<meta property="og:title" content="IOS应用安全-加解密算法简述">
<meta property="og:url" content="https://dishibolei.github.io/2017/05/25/save-encode/index.html">
<meta property="og:site_name" content="萝卜的空间">
<meta property="og:description" content="导读客户端经常遇到需要对数据进行加密的情况，那应该如何加密，选用什么样的加密算法，是本文想要讨论的问题。">
<meta property="og:image" content="https://dishibolei.github.io/2017/05/25/save-encode/utf_8.png">
<meta property="og:image" content="https://dishibolei.github.io/2017/05/25/save-encode/base_64.jpeg">
<meta property="og:image" content="https://dishibolei.github.io/2017/05/25/save-encode/safe_encode_sm2.jpg">
<meta property="og:image" content="https://dishibolei.github.io/2017/05/25/save-encode/safe_decode_sm2.jpg">
<meta property="og:updated_time" content="2017-06-02T02:22:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IOS应用安全-加解密算法简述">
<meta name="twitter:description" content="导读客户端经常遇到需要对数据进行加密的情况，那应该如何加密，选用什么样的加密算法，是本文想要讨论的问题。">
<meta name="twitter:image" content="https://dishibolei.github.io/2017/05/25/save-encode/utf_8.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dishibolei.github.io/2017/05/25/save-encode/"/>





  <title>IOS应用安全-加解密算法简述 | 萝卜的空间</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3d37ed280a5354742296ba32e7046ac8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">萝卜的空间</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我的小博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dishibolei.github.io/2017/05/25/save-encode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bolei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萝卜的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IOS应用安全-加解密算法简述</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T13:54:41+08:00">
                2017-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<blockquote>
<p>导读<br>客户端经常遇到需要对数据进行加密的情况，那应该如何加密，选用什么样的加密算法，是本文想要讨论的问题。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<p>如果把我们的数据比作笔记，那数据加密相当于给笔记本上了锁，解密相当于打开锁看到笔记。而打开锁的钥匙一定是在私人手里的，外人是打不开的。所以数据加密一定有三个关键字：</p>
<p><strong>1.加密<br>2.解密<br>3.秘钥</strong></p>
<p>所以有些常见的算法不是数据加密的范围，这个开发需要注意。比如Base64编码，MD5算法。</p>
<p>Base64只是把数据编码，通俗讲只是把原来用汉语写的笔记内容，改成用英语写的内容，只要懂转换规则的任何人都能得到数据。所以老板说把数据加下密，一定不是让你Base64一下或者用其他编码重新编码下，编码算法不涉及到数据安全。</p>
<p>MD5算法也是数据处理的一种方式，更多的被用在数据验证身上。用上面的例子来讲，MD5算法把整本书的内容变成了一句标题，通过标题是没办法推算出整个书讲什么的。因为根本没有解密的步骤，所以也不属于加密算法。</p>
<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>计算机的所有数据，最终都是由多个二进制bit(0/1)来存储和传输的，但是怎么从0/1转化成我们可读的文字，就涉及到编码的知识了。下面是基础的编码概念。</p>
<h2 id="ASCII-（NSASCIIStringEncoding）"><a href="#ASCII-（NSASCIIStringEncoding）" class="headerlink" title="ASCII （NSASCIIStringEncoding）"></a>ASCII （NSASCIIStringEncoding）</h2><p>使用一个字节大小表示的128个字符。其中这些字符主要是因为字符，现在很少使用这个编码，因为不够用。<strong>ASCII字符占用一个字节</strong>。<a href="http://ascii.911cha.com/" target="_blank" rel="external">ASCII码表</a></p>
<p>主要使用到的是英文字母的大小写转换。大写的A~Z编码+32等于小写的a~z。</p>
<h2 id="UNICODE-NSUnicodeStringEncoding"><a href="#UNICODE-NSUnicodeStringEncoding" class="headerlink" title="UNICODE (NSUnicodeStringEncoding)"></a>UNICODE (NSUnicodeStringEncoding)</h2><p>ASCII只能表示128个字符，对于英文国家来说足够了，对于我们中国来说，我们有几万个汉字不够啊。于是我们创造出了GB2312等等我们自己的字符集。日本也觉得我也不够啊，我也搞个字符集。这些字符集彼此是不兼容的，没办法转换，同样的字符<code>ABCD</code>,我们可能表示<code>好</code>,日本就可能就表示<code>坏</code>。于是程序猿们觉得我要搞个标准，大家都按照标准来。</p>
<p>于是就有了UNICODE编码。它是<strong>所有字符的国际标准编码字符集</strong>。这个是为了解决ASCII字符不够的问题。同时让所有组织使用同一套编码规则，解决编码不兼容的问题。所以现在通用的编码规则都是UNICODE编码。UNICODE向下兼容ASCII编码。UNICODE最大长度可以到4个字节。不过通常只使用两个字节表示。所以通常认为<strong>UNICODE占用2字节数据</strong>。</p>
<h2 id="UTF-8-（NSUTF8StringEncoding）"><a href="#UTF-8-（NSUTF8StringEncoding）" class="headerlink" title="UTF-8 （NSUTF8StringEncoding）"></a>UTF-8 （NSUTF8StringEncoding）</h2><p>其实UNICODE已经足够使用了，不过因为如果是ASCII表示的字符（比如英文）只需要1字节就可以了，UNICODE表示的话其中一个字节全是0，这个字节浪费了，<code>英语国家的程序猿觉得：我靠，我又不需要那么多复杂的字符,浪费我流量和空间啊，不行！！</code>，于是出现了对UNICODE的转换，也就是UTF-8格式，可以保证原ASCII字符依然用一个字节表示，非ASCII字符使用多个字符表示。</p>
<p>UNICODE到UTF-8的规则如下：</p>
<ol>
<li>按照UNICODE编码的范围，算出需要几个字节，比如1个字节数，2个字数节，3个字节数，4个字节数。具体范围参考下面的图。</li>
<li>单字节和ASCII码完全相同，</li>
<li>对于其他字节数，字节1的前面用1填充，几个字节数就添加几个<code>1</code>，后面补一个0。其他字节都用<code>10</code>开头。</li>
<li>剩余的位置，按照顺序把原始数据补齐。</li>
</ol>
<p><img src="/2017/05/25/save-encode/utf_8.png" alt="utf_8"></p>
<p>例子：</p>
<p>“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</p>
<p>对于UTF-8编码的文件，会在文件头写入<code>EF BB BF</code>,表明是UTF-8编码。</p>
<h2 id="UTF-16-（NSUTF16StringEncoding）"><a href="#UTF-16-（NSUTF16StringEncoding）" class="headerlink" title="UTF-16 （NSUTF16StringEncoding）"></a>UTF-16 （NSUTF16StringEncoding）</h2><p>UTF-16的编码方法是：</p>
<ul>
<li>如果二进制流b小于0x10000，也就是十进制的0到65535之内，则直接使用两字节表示。</li>
<li>如果二进制流b大于等于0x10000，将b-0x10000的结果中的前 10 位作为高位和0xD800进行逻辑或操作，将后10 bit作为低位和0xDC00做逻辑或操作，这样组成的4个字节就构成了b的编码。</li>
</ul>
<p>举个例子。假设要算（U+2A6A5，四个繁体字龙）在UTF-16下的值，因为它超过 U+FFFF，所以 2A6A5-10000=0x1A6A5=。</p>
<p>前10位0001 1010 01 | 0xD800 = 0xD896。</p>
<p>后10位10 1010 0101 | 0xDC00 = 0xDEA5。</p>
<p>所以U+ 2A6A5 在UTF-16中的像是D8 96 DE A5。</p>
<p>注：上文参考：<a href="http://blog.csdn.net/gqqnb/article/details/6266542" target="_blank" rel="external">精确解释Unicode</a></p>
<p>在IOS程序里面NSUTF16StringEncoding和NSUnicodeStringEncoding是等价的。</p>
<h2 id="UTF-16大端-小端（NSUTF16BigEndianStringEncoding-NSUTF16LittleEndianStringEncoding）"><a href="#UTF-16大端-小端（NSUTF16BigEndianStringEncoding-NSUTF16LittleEndianStringEncoding）" class="headerlink" title="UTF-16大端/小端（NSUTF16BigEndianStringEncoding/NSUTF16LittleEndianStringEncoding）"></a>UTF-16大端/小端（NSUTF16BigEndianStringEncoding/NSUTF16LittleEndianStringEncoding）</h2><p>大小端主要表明了，系统存储数据的顺序。因为UTF-16至少两个字节，这两个字节传输过来后，接收的人需要知道哪个字节是在前，哪个字节在后。然后系统才知道改如何存取。</p>
<p>Unicode规范中用字节序标记字符（BOM）来标识字节序，它的编码是FEFF。这样如果接收者收到FEFF，就表明这个字节流是高位在前的；如果收到FFFE，就表明这个字节流是低位在前的。</p>
<p>比如“汉”字的Unicode编码是0x6C49。</p>
<p>对于大端的文件数据为：<code>FE FF 6c 49</code><br>对于小端的文件数据为：<code>FF FE 49 6c</code></p>
<p>对于大小端的概念，本人经常搞混，什么高地址存低字节的，绕一绕就晕了。下面是我的理解：</p>
<ol>
<li>对于一个16进制数0x1234,我们知道这个数对应的是两个字节，占用16个比特。</li>
<li>系统中是按照字节为单位去保存数据的。一个地址空间对应1个字节。比如0x1234如果要存储在计算机里，需要占用两个地址空间。我们假设这个地址空间起始是0x00，因为需要两个字节，所以还需要一个地址空间来保存，即0x01。其中明显0x01是高地址空间。</li>
<li>所以问题就在于，对于0x1234这个数据保存，是0x01地址保存0x12还是保存0x24。</li>
<li>如果把0x1234看成字符串形式，按照正常顺序存储，先存0x12,后存0x34,对应的就是大端模式。</li>
<li>如果按照字节顺序，0x12是高位，0x34是低位，应该0x12存储在高位地址0x02,低位字节0x34存储在低位地址0x01。这种方式就是小端模式。</li>
<li>为了怕记混，可以这么记：我最大，按字符串顺序存储，我看的最舒服所以是大端。反面的就是小端的。</li>
</ol>
<table>
<thead>
<tr>
<th>地址偏移</th>
<th>大端模式</th>
<th>小端模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>12</td>
<td>34</td>
</tr>
<tr>
<td>0x01</td>
<td>34</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>附：代码判断大小端的代码。</p>
<p>原理是生成一个两字节的数据，然后转为1字节的char数据。大端取到的是第一个高字节，小端取到的是第二个低字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    short x = 1; //0x0001</div><div class="line">    char *p = (char *)&amp;x;</div><div class="line"></div><div class="line">    if(*p)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;little\n&quot;);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        printf(&quot;large\n&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>详细的本人没看懂，实际中没有用到这个编码，这个编码使用4字节存储。也有大小端之分</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>字符编码就是把可读的字符转化为二进制数据方法，字符解码就是把二进制数据转化为可读的方法。</li>
<li>ASCII占用1个字节，只有128个字符，主要是英文字符。</li>
<li>UNICODE是国际标准编码字符集，包含了所有已知符号。</li>
<li>UTF-8是UNICODE编码的一种实现方式，兼容ASCII码，也就是英文字符占1个字节，汉字可能占两个字节或三个字节。</li>
<li>UTF-16也是UNICODE编码的一种实现方式，通常和UNICODE编码一致，占用两个字节，分大小端。</li>
</ol>
<h1 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h1><p>Base64编码的作用是把非ASCII的字符转换为ASCII的字符。很多加密算法，很喜欢做一次Base64转换。原因是使用Base64编码后，所有的数据都是ASCII字符，方便在网络上传输。</p>
<p>设计思路是：<strong>Base64把每三个8Bit的字节转换为四个6Bit的字节（3<em>8 = 4</em>6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节</strong>。所以Base64算法生成的数据会比原数据大1/3左右。</p>
<p>比如：</p>
<ol>
<li>图片这种二进制数据就可以转换为Base64作为文本传输。</li>
<li>比如有中文的数据，可以通过Base64转为可以显示的ASCII数据</li>
</ol>
<p>简单说明：</p>
<ol>
<li>将字符按照文字编码转化为二进制字节。</li>
<li>每3字节化为一组（24bit），如果字节不够，最后输出结果补<code>=</code>。然后再把每一组拆分成4个组，每个组6bit,如果不足6bit后面补0。</li>
<li>将每个6bit前面补足两个0，凑够8位。</li>
<li>然后按照新分出来的每8位转成10进制数，按照表里面的查找，转为对应的ASCII字符。</li>
</ol>
<p><img src="/2017/05/25/save-encode/base_64.jpeg" alt="base_64"></p>
<p>举例：</p>
<p>字符<code>bl</code>如何转化为Base64编码：</p>
<ol>
<li>bl对应的ASCII码为： <code>01100010</code>和<code>01101100</code>,因为只有两个，所以有一个输出结果是<code>=</code></li>
<li>按照每三个字节分组：<code>0110001001101100</code></li>
<li>按照每个组6bit分4个组,不足6位的补0：<code>011000</code>,<code>100110</code>,<code>110000</code></li>
<li>在前面补<code>0</code>,凑够8位：<code>00011000</code>,<code>00100110</code>,<code>00110000</code></li>
<li>转为10进制：<code>24</code>,<code>38</code>,<code>48</code>。</li>
<li>查表得到：<code>Y</code>,<code>m</code>,<code>w</code></li>
<li>最后补<code>=</code>,所以结果为<code>Ymw=</code></li>
</ol>
<p>标准的程序实现可以参考：<code>GTMBase64.m</code>。</p>
<p>说明：</p>
<p><strong>Base64是一种编码算法，不是加密算法</strong>,他的作用不是加密，而是用最简的ASCII码来传输文本数据，屏蔽掉设备网络差异，是为了方便传输的一种算法。很多加密算法，最后生成的是二进制数据，不是可见字符，而传输的一般是通过字符传输，所以常见的二进制转化方式就是Base64算法。</p>
<h1 id="哈希散列算法"><a href="#哈希散列算法" class="headerlink" title="哈希散列算法"></a>哈希散列算法</h1><p><code>一个萝卜一个坑</code>这个俗语形容这个算法很贴切。官方的定义为：</p>
<p><strong>散列（Hash）函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。</strong></p>
<p>安全的哈希算法要满足下面条件：</p>
<ol>
<li><strong>固定长度</strong>。不同长度的数据，生成的固定长度的数据</li>
<li><strong>唯一性</strong>。不同的数据，生成的结果一定不同。相同的数据，每次输出的结果一定一样。</li>
<li><strong>不可逆</strong>。对于生成后的数据，反推回原数据，通过算法是不可能的。</li>
<li><strong>防篡改</strong>。两个输出的散列值相同，则原数据一定相同。如果两个输出的散列值不同，则原数据一定不同。</li>
</ol>
<p>从上面的特点可以知道散列值主要使用的场景：</p>
<ol>
<li>生成唯一的值做索引，比如哈希表</li>
<li>用作数据签名，校验数据完整性和有效性。</li>
<li>密码脱敏处理。</li>
</ol>
<h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><p>MD5算法是最常用的散列算法。</p>
<p>对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为十六个32位子分组，经过了一系列的处理后，算法的输出由4个32位分组组成，将这4个32位分组级联后将生成1个128位散列值。</p>
<p>算法有点复杂，没有看懂，放下不表。</p>
<p>下面是本人的简单理解：</p>
<ol>
<li>MD5算法效率是比较快的。</li>
<li>MD5防碰撞能力比较强，只有少数的几个例子有出现碰撞的情况。但也不影响安全性。</li>
<li>MD5生成的是固定128位,16个字节。</li>
</ol>
<h3 id="MD5算法安全性"><a href="#MD5算法安全性" class="headerlink" title="MD5算法安全性"></a>MD5算法安全性</h3><p><strong>目前主流看法是MD5逐渐有被攻克的风险。</strong>但是目前还没有有效算法破解。</p>
<p>主要的破解方法是使用数据库保存常见的字符串的MD5值，然后通过反查得到原始数据。也就是如果用户的密码很常见就很容易破解。如果用户密码是随机的，那就没什么平台可以破解了。</p>
<p>下面对于是用MD5的观点：</p>
<ol>
<li>MD5不是加密算法，重要的用户密码应该加密存储。做MD5只是为了脱敏，也就是不让相关人员知道原文是什么（包括内鬼）。</li>
<li>极重要数据是用更安全的算法：比如用户密码数据使用更安全的算法，比如SHA1算法。传输过程中也进一步加密。</li>
<li>如果使用MD5算法，在原始值里面加入盐值。盐值要尽量随机。因为如果加入随机值后原始值也变得随机，使用暴力破解就基本不可能了。即<code>result = MD5(password + salt)</code></li>
</ol>
<h3 id="关于加盐"><a href="#关于加盐" class="headerlink" title="关于加盐"></a>关于加盐</h3><p>这里有个<a href="http://www.cmd5.com/hash.aspx" target="_blank" rel="external">破解的网站</a>，大家可以看下常用的策略其实都可以破解。安全性主要是盐如何选择。 </p>
<ol>
<li>盐值要是随机字符，数据尽量长一些，只有这样才能保证最后数据的随机。</li>
<li>盐值尽量保证每个用户不一样，增加破解的难度。</li>
<li>盐值的保存可以是前后端约定,固化在APP里，但是也应该和用户相关，比如salt=(固化的值+用户信息)。可以是通过一些随机值变化得来：比如用户注册时间等信息做盐值。可以是每次随机生成，当做参数带给后端，后端保存密码+盐值。安全性从低到高。还有做多次MD5的，个人觉得意义不大。</li>
<li>个人推荐的一个方案。<code>result = MD5 (password + salt)</code>。salt的计算方法是：MD5(Random(128)+ uid)。其中Random(128)表示一个随机128位字符串，两端可以一致，固化在代码里。uid是用户唯一标示，比如登陆用的用户名。这样对于破解者来说就需要先拿到这个salt值，然后对每个用户都要生成一个唯一的128位的盐值，去生成对应的库，破解成本就非常高了。</li>
</ol>
<p>其实目前暴漏出来的是攻击者把整个数据库的内容拿到后，暴力解密出原文。但是MD5加盐也好变换也好都是可以通过前端代码查到算法的，通过算法就可以生成常用数据对应的MD5库。<strong>所以密码做MD5更重要的是脱敏处理，不能做为安全的加密使用，重要的用户密码持久化或传输过程中一定是要通过加密算法处理的</strong>。这样只要安全保存私钥就可以了。在很多金融公司，大量使用硬件加密机做加密处理，然后保存，更加大了破解难度。所以如果你的密码是使用加密再保存的，使用固定盐值的已经可以满足要求了。如果担心可以加上用户的注册时间或服务器时间戳做盐值。</p>
<h2 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h2><p>SHA1也是一种HASH算法。是MD5的替代方案。生成的数据是160位，20个字节。</p>
<p>目前SHA1也被认为不安全,<a href="http://www.92to.com/bangong/2017/02-25/17585278.html" target="_blank" rel="external">google找到了算法进行了碰撞</a>,所以普遍推荐使用新的SHA2代替。Google已经开始废弃这个算法了。</p>
<h2 id="SHA2"><a href="#SHA2" class="headerlink" title="SHA2"></a>SHA2</h2><ul>
<li>SHA-224、SHA-256、SHA-384，和SHA-512并称为SHA-2。</li>
<li>新的散列函数并没有接受像SHA-1一样的公众密码社区做详细的检验，所以它们的密码安全性还不被大家广泛的信任。</li>
<li>虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。</li>
</ul>
<p>所以目前推荐使用SHA2相关的算法做散列算法。</p>
<p>其中SHA-256输出为256位，32字节。<br>SHA-512输出为512位，64字节。</p>
<h2 id="HMac"><a href="#HMac" class="headerlink" title="HMac"></a>HMac</h2><p>HMac是秘钥相关的哈希算法。和之前的算法不同的在于需要一个秘钥，才能生成输出。主要是基于签名散列算法。可以认为是散列算法加入了加密逻辑，所以相比SHA算法更难破解，包含下面的算法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line">    @enum       CCHmacAlgorithm</div><div class="line">    @abstract   Algorithms implemented in this module.</div><div class="line"></div><div class="line">    @constant   kCCHmacAlgSHA1      HMAC with SHA1 digest</div><div class="line">    @constant   kCCHmacAlgMD5       HMAC with MD5 digest</div><div class="line">    @constant   kCCHmacAlgSHA256    HMAC with SHA256 digest</div><div class="line">    @constant   kCCHmacAlgSHA384    HMAC with SHA384 digest</div><div class="line">    @constant   kCCHmacAlgSHA512    HMAC with SHA512 digest</div><div class="line">    @constant   kCCHmacAlgSHA224    HMAC with SHA224 digest</div><div class="line"> */</div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    kCCHmacAlgSHA1,</div><div class="line">    kCCHmacAlgMD5,</div><div class="line">    kCCHmacAlgSHA256,</div><div class="line">    kCCHmacAlgSHA384,</div><div class="line">    kCCHmacAlgSHA512,</div><div class="line">    kCCHmacAlgSHA224</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> uint32_t CCHmacAlgorithm;</div></pre></td></tr></table></figure>
<p>HMAC主要应用场景：</p>
<ol>
<li>密码的散列存储，因为需要散列的时候需要密码，实际上相当于算法里加了盐值。使用的密码要随机和用户相关，请参考盐值的生产规则。</li>
<li>用于数据签名。双方使用共同的秘钥，然后做签名验证。秘钥可以固化，也可以会话开始前协商，增加签名篡改和被破解的难度。</li>
</ol>
<p>PS：目前项目中的密码散列算法，采用的就是HMac算法。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>密码保存和传输需要做散列处理。但是散列算法主要是脱敏，不能替代加密算法。</li>
<li>如今常用的Md5算法和SHA1算法都不再安全。所以推荐使用SHA-2相关算法。</li>
<li>散列算法应该加入盐值即：<code>result=HASH(password+salt)</code>。其中盐值应该是随机字符串且每个用户不一样。</li>
<li>HMac引入了秘钥的概念，如果不知道秘钥，秘钥不同，散列值也不同，相当于散列算法加入了盐值。可以把它当做更安全的散列算法使用。</li>
</ol>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>算法都是使用苹果自己的Security.framework框架实现的，只需要调用相关算法就可以了。推荐一个<a href="https://github.com/cocoajin/Security-iOS" target="_blank" rel="external">github</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//</div><div class="line">//  NSData+KKHASH.m</div><div class="line">//  SecurityiOS</div><div class="line">//</div><div class="line">//  Created by cocoa on 16/12/15.</div><div class="line">//  Copyright © 2016年 dev.keke@gmail.com. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;NSData+KKHASH.h&quot;</div><div class="line">#include &lt;CommonCrypto/CommonDigest.h&gt;</div><div class="line">#import &lt;CommonCrypto/CommonHMAC.h&gt;</div><div class="line"></div><div class="line">@implementation NSData (KKHASH)</div><div class="line">- (NSData *)hashDataWith:(CCDIGESTAlgorithm )ccAlgorithm</div><div class="line">&#123;</div><div class="line">    NSData *retData = nil;</div><div class="line">    if (self.length &lt;1) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    unsigned char *md;</div><div class="line">    </div><div class="line">    switch (ccAlgorithm) &#123;</div><div class="line">        case CCDIGEST_MD2:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_MD2_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_MD2_DIGEST_LENGTH);</div><div class="line">            CC_MD2(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_MD2_DIGEST_LENGTH];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_MD4:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_MD4_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_MD4_DIGEST_LENGTH);</div><div class="line">            CC_MD4(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_MD4_DIGEST_LENGTH];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_MD5:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_MD5_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_MD5_DIGEST_LENGTH);</div><div class="line">            CC_MD5(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_MD5_DIGEST_LENGTH];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA1:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA1_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA1_DIGEST_LENGTH);</div><div class="line">            CC_SHA1(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA224:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA224_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA224_DIGEST_LENGTH);</div><div class="line">            CC_SHA224(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA224_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA256:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA256_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA256_DIGEST_LENGTH);</div><div class="line">            CC_SHA256(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA256_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA384:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA384_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA384_DIGEST_LENGTH);</div><div class="line">            CC_SHA384(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA384_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case CCDIGEST_SHA512:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA512_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA512_DIGEST_LENGTH);</div><div class="line">            CC_SHA512(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA512_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        default:</div><div class="line">            md = malloc(1);</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    free(md);</div><div class="line">    md = NULL;</div><div class="line">    </div><div class="line">    return retData;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSData *)hmacHashDataWith:(CCHmacAlgorithm )ccAlgorithm key:(NSString *)key &#123;</div><div class="line">    NSData *retData = nil;</div><div class="line">    if (self.length &lt;1) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    unsigned char *md;</div><div class="line">    const char *cKey    = [key cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    </div><div class="line">    switch (ccAlgorithm) &#123;</div><div class="line">        case kCCHmacAlgSHA1:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA1_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA1_DIGEST_LENGTH);</div><div class="line">            CC_SHA1(self.bytes, (CC_LONG)self.length, md);</div><div class="line">            CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case kCCHmacAlgSHA224:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA224_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA224_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgSHA224, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA224_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case kCCHmacAlgSHA256:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA256_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA256_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgSHA256, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA256_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case kCCHmacAlgSHA384:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA384_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA384_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgSHA384, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA384_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case kCCHmacAlgSHA512:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_SHA512_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_SHA512_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgSHA512, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_SHA512_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">            </div><div class="line">        case CCDIGEST_MD5:</div><div class="line">        &#123;</div><div class="line">            md = malloc(CC_MD5_DIGEST_LENGTH);</div><div class="line">            bzero(md, CC_MD5_DIGEST_LENGTH);</div><div class="line">            CCHmac(kCCHmacAlgMD5, cKey, strlen(cKey), self.bytes, (CC_LONG)self.length, md);</div><div class="line">            retData = [NSData dataWithBytes:md length:CC_MD5_DIGEST_LENGTH];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            md = malloc(1);</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    free(md);</div><div class="line">    md = NULL;</div><div class="line">    </div><div class="line">    return retData;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (NSString *)hexString</div><div class="line">&#123;</div><div class="line">    NSMutableString *result = nil;</div><div class="line">    if (self.length &lt;1) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    result = [[NSMutableString alloc] initWithCapacity:self.length * 2];</div><div class="line">    for (size_t i = 0; i &lt; self.length; i++) &#123;</div><div class="line">        [result appendFormat:@&quot;%02x&quot;, ((const uint8_t *) self.bytes)[i]];</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (NSData *)dataWithHexString:(NSString *)hexString &#123;</div><div class="line">    NSMutableData *     result;</div><div class="line">    NSUInteger          cursor;</div><div class="line">    NSUInteger          limit;</div><div class="line">    </div><div class="line">    NSParameterAssert(hexString != nil);</div><div class="line">    </div><div class="line">    result = nil;</div><div class="line">    cursor = 0;</div><div class="line">    limit = hexString.length;</div><div class="line">    if ((limit % 2) == 0) &#123;</div><div class="line">        result = [[NSMutableData alloc] init];</div><div class="line">        </div><div class="line">        while (cursor != limit) &#123;</div><div class="line">            unsigned int    thisUInt;</div><div class="line">            uint8_t         thisByte;</div><div class="line">            </div><div class="line">            if ( sscanf([hexString substringWithRange:NSMakeRange(cursor, 2)].UTF8String, &quot;%x&quot;, &amp;thisUInt) != 1 ) &#123;</div><div class="line">                result = nil;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            thisByte = (uint8_t) thisUInt;</div><div class="line">            [result appendBytes:&amp;thisByte length:sizeof(thisByte)];</div><div class="line">            cursor += 2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h1 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h1><p>对称加密，指双方使用的秘钥是相同的。加密和解密都使用这个秘钥。</p>
<p>对称加密的优点为：</p>
<ol>
<li>加密效率高</li>
<li>加密速度快</li>
<li>可以对大数据进行加密</li>
</ol>
<p>缺点为：</p>
<ol>
<li>秘钥安全性无法保证，以现在的技术手段来说，默认对称秘钥的秘钥是非安全的，可以被拿到的。</li>
</ol>
<h2 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h2><ul>
<li>DES ：数据加密标准。<br>  是一种分组数据加密技术，先将数据分成固定长度64位的小数据块，之后进行加密。<br>  速度较快，适用于大量数据加密。<strong>DES密钥为64位,实际使用56位</strong>。将64位数据加密成64位数据。</li>
<li>3DES：使用三组密钥做三次加密。<br>  是一种基于 DES 的加密算法，使用3个不同密钥对同一个分组数据块进行3次加密，如此以使得密文强度更高。<strong>3DES秘钥为DES两倍或三倍，即112位或168位</strong>。其实就是DES的秘钥加强版。</li>
<li>AES ：高级加密标准。<br>  是美国联邦政府采用的一种区块加密标准。<br>  相较于 DES 和 3DES 算法而言，AES 算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准。<strong>AES秘钥长度为128、192、256位</strong>。</li>
</ul>
<p>使用到的基础数学方法：</p>
<ul>
<li>移位和循环移位<br>　　移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。</li>
<li>置换<br>　　就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。</li>
<li>扩展<br>　　就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。</li>
<li>压缩<br>　　就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。</li>
<li>异或<br>　　这是一种二进制布尔代数运算。异或的数学符号为⊕ ，它的运算法则如下：<br>1⊕1 = 0<br>0⊕0 = 0<br>1⊕0 = 1<br>0⊕1 = 1<br>　　也可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。</li>
<li>迭代<br>　　迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。</li>
</ul>
<p>对于对称加密来说，有几个共同要点：</p>
<ol>
<li>密钥长度；（关系到密钥的强度）</li>
<li>加密模式；（ecb、cbc等等）</li>
<li>块加密算法里的块大小和填充方式区分；</li>
</ol>
<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><h3 id="ECB-模式"><a href="#ECB-模式" class="headerlink" title="ECB 模式"></a>ECB 模式</h3><p>ECB ：电子密本方式，最古老,最简单的模式，将加密的数据分成若干组，每组的大小跟加密密钥长度相同；<br>然后每组都用相同的密钥加密。OC对应的为<code>kCCOptionECBMode</code></p>
<p>ECB的特点为：</p>
<ul>
<li>每次Key、明文、密文的长度都必须是64位；</li>
<li>数据块重复排序不需要检测；</li>
<li>相同的明文块(使用相同的密钥)产生相同的密文块，容易遭受字典攻击；</li>
<li>一个错误仅仅会对一个密文块产生影响，所以支持并行计算；</li>
</ul>
<h3 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h3><ul>
<li>CBC ：密文分组链接方式。与ECB相比，加入了<strong>初始向量IV</strong>。将加密的数据分成若干组，加密时第一个数据需要先和向量异或之后才加密。后面的数据需要先和前面的数据异或，然后再加密。是OC默认的加密模式。</li>
</ul>
<p>CBC的特点为：</p>
<ul>
<li>每次加密的密文长度为64位(8个字节);</li>
<li>当相同的明文使用相同的密钥和初始向量的时候CBC模式总是产生相同的密文;</li>
<li>密文块要依赖以前的操作结果,所以，密文块不能进行重新排列;</li>
<li>可以使用不同的初始化向量来避免相同的明文产生相同的密文,一定程度上抵抗字典攻击;</li>
<li>一个错误发生以后,当前和以后的密文都会被影响;</li>
</ul>
<h2 id="块大小和填充方式"><a href="#块大小和填充方式" class="headerlink" title="块大小和填充方式"></a>块大小和填充方式</h2><p>对称算法的第一步就是对数据进行分组，每一个组的大小称为快大小，比如DES需要将数据分组为64位（8个字节），如果数据不够64位就需要进行补位。</p>
<h3 id="PKCS7Padding填充"><a href="#PKCS7Padding填充" class="headerlink" title="PKCS7Padding填充"></a>PKCS7Padding填充</h3><p>OC中指定的填充方法只有<code>kCCOptionPKCS7Padding</code>，对应JAVA的<code>PKCS5Padding</code>填充方式。算法为计算缺几位数，然后就补几位数，数值为下面的公式：</p>
<p><code>value=k - (l mod k)  ,K=块大小，l=数据长度，如果l=8, 则需要填充额外的8个byte的8</code></p>
<p>比如块大小为8字节，数据为<code>DD DD DD DD</code>4个字节，带入公式，l=4,k=8,计算 8 - （4 mod 8）= 4 ,所以补充4个4，补位后得到<code>DD DD DD DD 04 04 04 04</code>。</p>
<p>唯一特别的是如果最后位数是够的，也需要额外补充，比如数据是<code>DD DD DD DD DD DD DD DD</code>8个字节,带入公式，l=8,k=8,计算 8 - （8 mod 8）= 8，所以补位后得到<code>DD DD DD DD DD DD DD DD 08 08 08 08 08 08 08 08</code>。 所以如果考虑补位，实际输出buffer大小要加上快大小，防止buffer不够。</p>
<h3 id="Zero-Padding（No-Padding）"><a href="#Zero-Padding（No-Padding）" class="headerlink" title="Zero Padding（No Padding）"></a>Zero Padding（No Padding）</h3><p>补位的算法和PKCS7Padding一致，只不过补的位为<code>0x00</code>,比如数据为<code>DD DD DD DD</code>4个字节，带入公式，l=4,k=8,计算 8 - （4 mod 8）= 4 ,所以补充4个00，补位后得到<code>DD DD DD DD 00 00 00 00</code>。</p>
<p><strong>非常不建议用这种模式，因为解密后的数据会多出补的<code>00</code></strong>。如果原始数据以<code>00</code>结尾(ASCII码代表空字符)，就没办法区分出来了。</p>
<h2 id="几种算法比较"><a href="#几种算法比较" class="headerlink" title="几种算法比较"></a>几种算法比较</h2><table>
<thead>
<tr>
<th>算法</th>
<th>秘钥长度（字节）</th>
<th>分组长度（字节）</th>
<th>加密效率</th>
<th>破解难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>DES</td>
<td>8</td>
<td>8</td>
<td>较快（22.5MB/S）</td>
<td>简单</td>
</tr>
<tr>
<td>3DES</td>
<td>24</td>
<td>8</td>
<td>慢（12MB/S）</td>
<td>难</td>
</tr>
<tr>
<td>AES</td>
<td>16/24/32</td>
<td>16</td>
<td>快（51.2MB/s）</td>
<td>难</td>
</tr>
</tbody>
</table>
<h2 id="IOS-代码实现解析"><a href="#IOS-代码实现解析" class="headerlink" title="IOS 代码实现解析"></a>IOS 代码实现解析</h2><p>下面以AES代码实现为例，说明下IOS加解密算法的实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ (<span class="built_in">NSString</span> *)AES128Encrypt:(<span class="built_in">NSString</span> *)plainText key:(<span class="built_in">NSString</span> *)gkey iv:(<span class="built_in">NSString</span> *)gIv padding:(<span class="built_in">BOOL</span>)padding</div><div class="line">&#123;</div><div class="line">    <span class="comment">//先处理秘钥，如果秘钥不够算法长度，就用0填充，如果长于算法长度就截断。</span></div><div class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128+<span class="number">1</span>]; <span class="comment">//申请秘钥buffer，这里根据不同算法导入需要的key长度。AES128是16个字节，对应的值kCCKeySizeAES128。</span></div><div class="line">    memset(keyPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(keyPtr)); <span class="comment">//使用0填充，保证秘钥长度达到要求。</span></div><div class="line">    [gkey getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>]; <span class="comment">//将传入的秘钥copy进秘钥buffer里</span></div><div class="line">    </div><div class="line">    <span class="comment">//注意这个只在模式为CBC下有效，</span></div><div class="line">    <span class="comment">//处理向量值，默认模式为CBC。如果指定了kCCOptionECBMode模式，就不需要这个向量。</span></div><div class="line">    <span class="keyword">char</span> ivPtr[kCCBlockSizeAES128+<span class="number">1</span>]; <span class="comment">//申请向量的buffer，长度为块长度。AES128块长度为kCCBlockSizeAES128。</span></div><div class="line">    memset(ivPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ivPtr));</div><div class="line">    [gIv getCString:ivPtr maxLength:<span class="keyword">sizeof</span>(ivPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>]; <span class="comment">//将传入的值copy进向量buffer</span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="built_in">NSData</span>* data = [plainText dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">    <span class="built_in">NSUInteger</span> dataLength = [data length];</div><div class="line">    </div><div class="line">    <span class="comment">//注意这个只在不指定padding的情况下有效，需要填充0，算法为num_to_fill= k - (length mod k)，如果指定了kCCOptionPKCS7Padding，就不需要人为填充。</span></div><div class="line">    </div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> newSize = dataLength;</div><div class="line">    <span class="keyword">int</span> diff = padding ? <span class="number">0</span> : kCCKeySizeAES128 - (dataLength % kCCKeySizeAES128);</div><div class="line">    <span class="keyword">if</span>(diff &gt; <span class="number">0</span>) &#123;</div><div class="line">        newSize = dataLength + diff;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">char</span> dataPtr[newSize];</div><div class="line">    memcpy(dataPtr, [data bytes], [data length]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; i++) &#123;</div><div class="line">        dataPtr[i + dataLength] = <span class="number">0x00</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//输出的buffer</span></div><div class="line">    size_t bufferSize = newSize + kCCBlockSizeAES128;</div><div class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</div><div class="line">    memset(buffer, <span class="number">0</span>, bufferSize);</div><div class="line">    </div><div class="line">    size_t numBytesCrypted = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    CCOptions option = padding ? kCCOptionPKCS7Padding : <span class="number">0x0000</span>;</div><div class="line">    option = gIv.length &gt; <span class="number">0</span> ? option : option | kCCOptionECBMode;</div><div class="line">    </div><div class="line">    </div><div class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</div><div class="line">                                          kCCAlgorithmAES128,</div><div class="line">                                          option,</div><div class="line"><span class="comment">//                                          0x0000,               //No padding | CBC模式  需要补零且需要iv向量</span></div><div class="line"><span class="comment">//                                          kCCOptionPKCS7Padding,  //  kCCOptionPKCS7Padding | CBC模式   需要iv向量</span></div><div class="line">                                          <span class="comment">//kCCOptionPKCS7Padding | kCCOptionECBMode, // kCCOptionPKCS7Padding | kCCOptionECBMode 不需要iv向量，也不需要补零</span></div><div class="line"><span class="comment">//                                          kCCOptionECBMode, // No padding | kCCOptionECBMode 不需要补零，不需要iv向量</span></div><div class="line">                                          keyPtr,</div><div class="line">                                          kCCKeySizeAES128,</div><div class="line">                                          ivPtr,</div><div class="line">                                          dataPtr,</div><div class="line">                                          <span class="keyword">sizeof</span>(dataPtr),</div><div class="line">                                          buffer,</div><div class="line">                                          bufferSize,</div><div class="line">                                          &amp;numBytesCrypted);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</div><div class="line">        <span class="built_in">NSData</span> *resultData = [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesCrypted];</div><div class="line">        resultData = [resultData base64EncodedDataWithOptions:(<span class="built_in">NSDataBase64EncodingOptions</span>)<span class="number">0</span>];</div><div class="line">        <span class="built_in">NSString</span> *encryptedString = [[<span class="built_in">NSString</span> alloc] initWithData:resultData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">        <span class="keyword">return</span> encryptedString;</div><div class="line">    &#125;</div><div class="line">    free(buffer);</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSString</span> *)AES128Decrypt:(<span class="built_in">NSString</span> *)encryptText key:(<span class="built_in">NSString</span> *)gkey iv:(<span class="built_in">NSString</span> *)gIv padding:(<span class="built_in">BOOL</span>)padding</div><div class="line">&#123;</div><div class="line">    <span class="comment">//复制秘钥buffer</span></div><div class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128 + <span class="number">1</span>];</div><div class="line">    memset(keyPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(keyPtr));</div><div class="line">    [gkey getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//复制向量buffer</span></div><div class="line">    <span class="keyword">char</span> ivPtr[kCCBlockSizeAES128 + <span class="number">1</span>];</div><div class="line">    memset(ivPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ivPtr));</div><div class="line">    [gIv getCString:ivPtr maxLength:<span class="keyword">sizeof</span>(ivPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">    <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc] initWithBase64EncodedString:encryptText options:<span class="number">0</span>];</div><div class="line">    <span class="built_in">NSUInteger</span> dataLength = [data length];</div><div class="line">    size_t bufferSize = dataLength + kCCBlockSizeAES128;</div><div class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</div><div class="line">    </div><div class="line">    <span class="comment">//计算采用哪种模式和填充方式</span></div><div class="line">    CCOptions option = padding ? kCCOptionPKCS7Padding : <span class="number">0x0000</span>;</div><div class="line">    option = gIv.length &gt; <span class="number">0</span> ? option : option | kCCOptionECBMode;</div><div class="line">    </div><div class="line">    size_t numBytesCrypted = <span class="number">0</span>;</div><div class="line">    <span class="comment">//解密</span></div><div class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</div><div class="line">                                          kCCAlgorithmAES128,</div><div class="line">                                          option,</div><div class="line"><span class="comment">//                                          0x0000,               //No padding | CBC模式  需要补零且需要iv向量</span></div><div class="line"><span class="comment">//                                          kCCOptionPKCS7Padding,  //  kCCOptionPKCS7Padding | CBC模式   需要iv向量</span></div><div class="line">                                          <span class="comment">//kCCOptionPKCS7Padding | kCCOptionECBMode, // kCCOptionPKCS7Padding | kCCOptionECBMode 不需要iv向量，也不需要补零</span></div><div class="line"><span class="comment">//                                          kCCOptionECBMode, // No padding | kCCOptionECBMode 不需要补零，不需要iv向量</span></div><div class="line">                                          keyPtr,</div><div class="line">                                          kCCBlockSizeAES128,</div><div class="line">                                          ivPtr,</div><div class="line">                                          [data bytes],</div><div class="line">                                          dataLength,</div><div class="line">                                          buffer,</div><div class="line">                                          bufferSize,</div><div class="line">                                          &amp;numBytesCrypted);</div><div class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</div><div class="line">        <span class="built_in">NSData</span> *resultData = [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesCrypted];</div><div class="line">        <span class="built_in">NSString</span> *result = [[<span class="built_in">NSString</span> alloc] initWithData:resultData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">        <span class="keyword">if</span> ([result length] &gt; <span class="number">0</span> &amp;&amp; !padding) &#123;</div><div class="line">            <span class="comment">//如果是非填充模式，解析后的数据会多出填充的'\0',所以需要去掉。</span></div><div class="line">            <span class="keyword">long</span> byteWithoutZero = numBytesCrypted;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *utf8Str =  [result UTF8String];</div><div class="line">            <span class="comment">//从后开始扫描，查到需要截断的长度</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = byteWithoutZero - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --) &#123;</div><div class="line">                <span class="keyword">if</span> (utf8Str[i] != <span class="string">'\0'</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                byteWithoutZero --;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">NSString</span> *finalReslut = [[<span class="built_in">NSString</span> alloc] initWithBytes:utf8Str length:byteWithoutZero encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> finalReslut;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    free(buffer);</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建议和说明</p>
<ol>
<li>建议使用ECB模式（kCCOptionECBMode），填充采用kCCOptionPKCS7Padding。这种使用最广泛，和PHP、JAVA（AES/ECB/PKCS5Padding）都适配。联调的时候需要注意两端是否一致，不一致是调不通的。</li>
<li>通常数据加密后，会做一次Base64编码进行传输，有些应用也会将数据转为二进制字符串传输。 </li>
<li>如果不指定模式，则默认是CBC模式，需要用到向量IV。</li>
<li>如果不指定填充格式，则需要自行补<code>0x00</code>处理，在解码后也需要把补的<code>0x00</code>去除掉，网上很多资料解码后没有去除，会多出<code>\0</code>。</li>
</ol>
<h2 id="说明和总结"><a href="#说明和总结" class="headerlink" title="说明和总结"></a>说明和总结</h2><ol>
<li>建议对称加密使用AES加密。DES无论安全性和效率都不如AES算法。</li>
<li>加密建议用<code>kCCOptionPKCS7Padding</code>填充方式，对应的JAVA模式为<code>PKCS5Padding</code></li>
<li>如果用CBC模式，需要使用初始向量，初始向量两端应该一致。如果不使用应该指定<code>kCCOptionECBMode</code>。也建议用这个模式，兼容性最好。</li>
<li>秘钥应该用随机数生成对应的位数。AES128为16个字节，也就是16个字符。不要用短密码,比如：<code>111111</code>,这样真的很蠢。</li>
<li>对称加密的安全隐患主要在于秘钥的保存。重要会话的秘钥应该随机生成，使用非对称加密来沟通交换秘钥，策略可以参考我的另一篇文章<a href="https://dishibolei.github.io/2017/05/11/https-safe-1/">IOS应用安全-HTTP/HTTPS网络安全(一)</a>。</li>
<li>如果秘钥需要硬编码到程序里，应该做脱敏运算，比如做位运算进行变形等。后面会专门写怎么解决秘钥硬编码问题。</li>
</ol>
<h1 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h1><p>非对称秘钥加密算法的特点是：<strong>加密和解密使用不同的秘钥</strong>。</p>
<p>非对称加密需要两个秘钥：公开秘钥和私有秘钥。两个秘钥是不同的，而且通过公钥是无法推算出私钥的，使用公钥加密的数据只有用私钥解密。</p>
<p>非对称算法的特点：</p>
<ol>
<li>解决了秘钥保存的问题。公钥可以发布出去，任何人都可以使用，也不用担心被人获取到，只要保证私钥的安全就可以了。而对称加密，因为秘钥相同，客户端泄露了就不安全了。</li>
<li>加密和解密的效率不高，只适合加解密少量的数据。而对称加密效率要高。这里有一篇文章对比<a href="http://blog.csdn.net/yore_/article/details/52733994" target="_blank" rel="external">AES和RSA算法的性能对比</a>。</li>
</ol>
<h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><p>RSA是目前最常用的非对称加密算法。</p>
<p>算法原理可以看下这篇文章：<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">RSA算法原理</a>。</p>
<p>RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。RSA的秘钥长度在2048位，现有的技术手段是无法破解的（实际的可以暴力破解的位数为768位，也就是768位的大数才有可能暴力进行因数分解）。</p>
<p>RSA算法优点：</p>
<ol>
<li>算法原理简单，我都快看懂了。</li>
<li>安全性也足够高，目前没有证据和方案可以破解1048位以上秘钥的RSA算法。</li>
</ol>
<p>缺点：</p>
<ol>
<li>安全性取决于秘钥长度，推荐的要至少1048位，但是这么高位数的秘钥生成速度很慢，所以没法做一次会话一次秘钥。</li>
<li>加解密的效率很低，相对于对称加密，差好几个量级，而且也不支持加密长数据。</li>
</ol>
<h2 id="国密算法SM2"><a href="#国密算法SM2" class="headerlink" title="国密算法SM2"></a>国密算法SM2</h2><p>中国特有的算法，国家强制要求金融机构使用国密算法。包括SM1/SM2/SM3/SM4。其中SM4为对称加密算法。SM3是哈希算法。SM2为非对称加密算法。但是国家只给算法原理，没有给出常用的算法实现，所以是件蛋疼的事情。</p>
<p>算法我也没看懂。因为项目中使用到了，所以做了一些研究。相关代码可以参考我的<a href="https://github.com/dishibolei/SM2.git" target="_blank" rel="external">github</a>,IOS SM2开源实现非常少，而且都有些问题，要么基于openSSL，代码特别大。要么基于libtommath库，但是有一些问题，SM2无法调通。所以两个结合重新整理的下代码。这个代码只保证SM2算法有效性，因为经过实际使用过，其他的项目未用到。</p>
<h3 id="SM2的加密流程"><a href="#SM2的加密流程" class="headerlink" title="SM2的加密流程"></a>SM2的加密流程</h3><p><img src="/2017/05/25/save-encode/safe_encode_sm2.jpg" alt=""></p>
<p>抛出掉数学方法，下面是本人的一些理解：</p>
<ol>
<li><p>SM2需要依赖于一个曲线，一般使用国家<a href="http://www.oscca.gov.cn/News/201012/News_1197.htm" target="_blank" rel="external">推荐曲线</a>。如果曲线不对，肯定是无法加解密的。曲线参数</p>
<pre><code class="objc">
<span class="meta">#define SM2_P     <span class="meta-string">"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF"</span></span>
<span class="meta">#define SM2_A     <span class="meta-string">"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC"</span></span>
<span class="meta">#define SM2_B     <span class="meta-string">"28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93"</span></span>
<span class="meta">#define SM2_N     <span class="meta-string">"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123"</span></span>
<span class="meta">#define SM2_G_X   <span class="meta-string">"32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7"</span></span>
<span class="meta">#define SM2_G_Y   <span class="meta-string">"BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0"</span></span>
</code></pre>
</li>
<li>SM2公钥分为两部分：Pub_x和Pub_y。每个都是32字节，总共是64字节。私钥长度现在还不清楚是多少，有资料说是要32位，但是文档里面未提到。字节数如果不对说明生成秘钥算法有问题。</li>
<li>输出数据分为3段：<code>C1C2C3</code>,其中C1是64个字节，C2和原始数据大小相同，即原文是6个字节，C2就是6个字节，C3是32个字节。所以总长度是64+32+原文长度（字节）。如果长度不对，要看下是否是人为添加了其他字段。</li>
<li>算法涉及到哈希算法，标准是使用SM3的hash算法，SM3的Hash算法生成的字节为32字节，这个联调的时候一定要保证一致。</li>
</ol>
<h4 id="加密步骤说明："><a href="#加密步骤说明：" class="headerlink" title="加密步骤说明："></a>加密步骤说明：</h4><ol>
<li>第一步计算随机数，如果这个不是随机的,是固定的，那后面的结果每次输出就是唯一的。</li>
<li>通过随机数rank和曲线的G_x、G_y、P、A五个参数，通过ECC算法<code>C1=[k]G = (x1,y1)</code>生成一个点（x1,y1）。拼接起来就是C1数据。C1数据应该是64个字节。有些算法里面会在前面填充<code>0x04</code>，变成65个字节</li>
<li>通过公钥的P_x和P_y,随机数rank,A,P，通过ECC算法<code>[k]PukeyB = [k](XB,YB) = (x2,y2)</code>计算出(x2,y2)，x2和y2的大小为分别为32字节</li>
<li>将上面的(x2,y2)拼接，然后做KDF（密码派生算法）计算，输出原文长度（klen）的t值。<code>t= KDF(x2||y2, klen)</code>,KDF一般使用的是SM3的算法。结果t的大小和原文的大小一致。</li>
<li>然后将t和原文做异或运算，得到C2,C2的大小和原文一致。</li>
<li>然后将(x2,原文,x3)拼接，计算一次SM3的Hash算法,生成的数据放入C3中，C3的大小为32字节。</li>
<li>最后把<code>C1C2C3</code>拼接到一起，长度为64+原文长度+32字节。注意，<strong>老的标准为<code>C1C3C2</code>,有些实现的是这种模式。</strong></li>
</ol>
<p>注：这其中ECC算法是标准算法，大部分第三方实现的都没有问题。主要是KDF算法和Hash算法会有不同。这个联调的时候需要搞清楚。</p>
<h3 id="SM2解密流程"><a href="#SM2解密流程" class="headerlink" title="SM2解密流程"></a>SM2解密流程</h3><p>流程图如下：</p>
<p><img src="/2017/05/25/save-encode/safe_decode_sm2.jpg" alt=""></p>
<h4 id="解密步骤说明"><a href="#解密步骤说明" class="headerlink" title="解密步骤说明"></a>解密步骤说明</h4><ol>
<li>先判断C1是否在曲线上。C1长度为64字节，取数据的前64字节就可以了。所以两端一定要用同样的曲线。</li>
<li>使用C1的数据,曲线参数（A,P）,私钥dA，使用ECC算法生成(x2,y2)，<code>dA*C1 = dA*(x2,y2) = dA*[k]*(Xg,Yg)</code></li>
<li>使用(x2,y2)和C2的长度（总长度-64-32），使用KDF计算t。</li>
<li>使用c2异或t，达到M’</li>
<li>计算(x2,M’,y2)的hash值U。</li>
<li>比较U和C3数据是否是一致的，如果一致就输出M’</li>
</ol>
<h3 id="KDF算法说明："><a href="#KDF算法说明：" class="headerlink" title="KDF算法说明："></a>KDF算法说明：</h3><p>文档里的描述</p>
<blockquote>
<blockquote>
<p>密钥派生函数的作用是从一个共享的秘密比特串中派生出密钥数据。在密钥协商过程中，密钥派<br>生函数作用在密钥交换所获共享的秘密比特串上，从中产生所需的会话密钥或进一步加密所需的密钥<br>数据。<br>密钥派生函数需要调用密码杂凑函数。<br>设密码杂凑函数为Hv( )，其输出是长度恰为v比特的杂凑值。<br>密钥派生函数KDF(Z, klen)：<br>输入：比特串Z，整数klen(表示要获得的密钥数据的比特长度，要求该值小于(232-1)v)。<br>输出：长度为klen的密钥数据比特串K。<br>a)初始化一个32比特构成的计数器ct=0x00000001；<br>b)对i从1到⌈klen/v⌉执行：<br>b.1)计算Hai=Hv(Z ∥ ct)；<br>b.2) ct++；<br>c)若klen/v是整数，令Ha!⌈klen/v⌉ = Ha⌈klen/v⌉，否则令Ha!⌈klen/v⌉为Ha⌈klen/v⌉最左边的(klen −<br>(v × ⌊klen/v⌋))比特；<br>d)令K = Ha1||Ha2|| · · · ||Ha⌈klen/v⌉−1||Ha!⌈klen/v⌉。</p>
</blockquote>
</blockquote>
<p>简化下说明：</p>
<ol>
<li>先分组,分组的大小为<code>klen/v</code>,向上取整,其中klen是数据长度，v是HASH算法输出长度。SM3的输出长度为32字节。</li>
<li>然后每一组循环，把原始数据Z和计数器ct拼接，做SM3_Hash运算得到Hai。然后计数器ct+1。</li>
<li>最终生成的数据Ha1,Ha2…拼接起来，然后截断到klen长度也就是数据长度。</li>
</ol>
<h3 id="HASH算法说明"><a href="#HASH算法说明" class="headerlink" title="HASH算法说明"></a>HASH算法说明</h3><p>官方使用的是SM3密码杂凑算法，输入为小于2的64次方bit，输出为<strong>256bit（32字节）</strong>。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>国密算法的基础是使用曲线计算。<strong>曲线应该使用官方推荐的曲线</strong>，曲线不同加解密肯定失败。</li>
<li>国密算法生成的数据为<code>C1C2C3</code>,其中C1为固定的64字节，c2和原始数据一样长，C3为固定的32字节。<strong>有些要求数据前面加上’0x04’,旧的版本输出是<code>C3C1C2</code></strong>，这两点要注意。</li>
<li><strong>公钥分为P_x和P_y,都是32字节长度</strong>。私钥长度从资料上看没有限制，是一个随机数[1,N-2]。N为曲线参数。</li>
<li>加密过程中使用了SM3的散列算法(官方叫杂凑算法)，这个算法输出为32字节的数据。如果对端没有用这个算法，两端也无法加解密成功。</li>
</ol>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><ol>
<li>字符编码是为了把可见字符和二进制之间做一层转化。其中UNICODE编码是国际编码标准。UTF-8是这种编码格式的实现方式。特点是ASCII码的字符占用一个字节，其他的比如中文字符占用两到三个字符。</li>
<li>Base64也是一种编码方式，主要用于把二进制数据转化为ASCII字符，方便传输。现在很多加密算法习惯在加密后把二进制数做一次Base64进行传输。相对于原文，长度会多出1/3。也有把二进制转为字符串的形式，不过长度是原文的2倍。</li>
<li>哈希散列算法，主要用于脱敏处理和信息签名防篡改，做哈希运算应该加盐处理。盐值应该是随机值，而且和用户相关，建议使用（随机数 + 用户名）。</li>
<li>对称加密两端秘钥相同，加密速度快，可以加密大数据，但是秘钥保存一直是个难题。</li>
<li>非对称加密分为公钥和私钥，公钥可以公开。加密速度慢，只能加密小数据，但是只需要妥善保存私钥就可以了。</li>
</ol>
<p>通常一个信息加密传输流程为：</p>
<ol>
<li>双方约定好使用的编码格式。通常常用的是UTF-8编码。</li>
<li>客户端随机生成对称秘钥作为会话秘钥。使用非对称加密传输给后端，后端保存这个对称秘钥用于之后的加解密过程。</li>
<li>用户使用对称加密（通常为RSA）加密整个数据，结果通常使用Base64做编码（通常还要做一次URLEncode操作）,整个相关数据按照规则使用Hash算法（通常为SHA256算法）做数据签名。最后做传输</li>
<li>如果是用户密码的话建议用HMac做Hash脱敏处理，然后单独使用非对称加密进一步加强安全性。</li>
</ol>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode和UTF-8</a></li>
<li><a href="http://baike.baidu.com/link?url=FjDXJpkvwA7a2I_XBaIBK84bxaJZ6CGSoQDYnmBNf7nsJN867uLnyBptnJ8jkgRo9gpEXvrRgWcc12_rjqn-5q" target="_blank" rel="external">百度百科-ASCII</a></li>
<li><a href="http://www.cnblogs.com/Alandre/p/4878841.html" target="_blank" rel="external">深入浅出大小端</a></li>
<li><a href="http://www.cnblogs.com/BeyondTechnology/archive/2011/03/27/1997165.html" target="_blank" rel="external">Base64 编码</a></li>
<li><a href="http://www.server110.com/sec_news/201309/995.html" target="_blank" rel="external">MD5+Salt安全浅析</a></li>
<li><a href="http://www.atool.org/hash.php" target="_blank" rel="external">哈希加密算法 MD5,SHA-1,SHA-2,SHA-256,SHA-512,SHA-3,RIPEMD-160 - aTool</a></li>
<li><a href="http://www.blogjava.net/wayne/archive/2011/05/23/350879.html" target="_blank" rel="external">DES加密模式详解</a></li>
<li><a href="http://blog.chinaunix.net/uid-29106641-id-4032988.html" target="_blank" rel="external">DES加密算法原理</a></li>
<li><a href="http://www.cnblogs.com/midea0978/articles/1437257.html" target="_blank" rel="external">关于PKCS5Padding与PKCS7Padding的区别</a></li>
<li><a href="http://www.cnblogs.com/sunxuchu/p/5483956.html" target="_blank" rel="external">各种加密算法比较</a></li>
<li><a href="http://tool.chacuo.net/cryptaes" target="_blank" rel="external">AES在线加解密</a></li>
<li><a href="http://www.cnblogs.com/QianChia/p/6246129.html" target="_blank" rel="external">iOS - Safe iOS 加密安全</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">RSA算法原理</a></li>
<li><a href="http://www.oscca.gov.cn/News/201012/News_1197.htm" target="_blank" rel="external">SM2国密算法官方说明</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/upload/wechat_pay.jpeg" alt="bolei WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/安全/" rel="tag"># 安全</a>
          
            <a href="/tags/加解密/" rel="tag"># 加解密</a>
          
            <a href="/tags/字符编码/" rel="tag"># 字符编码</a>
          
            <a href="/tags/大小端/" rel="tag"># 大小端</a>
          
            <a href="/tags/国密算法/" rel="tag"># 国密算法</a>
          
            <a href="/tags/HASH/" rel="tag"># HASH</a>
          
            <a href="/tags/对称加密/" rel="tag"># 对称加密</a>
          
            <a href="/tags/非对称加密/" rel="tag"># 非对称加密</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/15/https-safe-2/" rel="next" title="IOS应用安全-HTTP/HTTPS网络安全(二)">
                <i class="fa fa-chevron-left"></i> IOS应用安全-HTTP/HTTPS网络安全(二)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/26/safe-hard-code/" rel="prev" title="安全-秘钥硬编码解决">
                安全-秘钥硬编码解决 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yODYyNy81MTk4"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="bolei" />
          <p class="site-author-name" itemprop="name">bolei</p>
           
              <p class="site-description motion-element" itemprop="description">金融互联网下的小码农。目前专注于IOS客户端安全、性能、架构和react-native相关的技术。2017.5月开始写博客，分享工作中的一些心得。只准备写原创文章，文笔逻辑不好，慢慢改正。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/dishibolei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://sunyazhou.com/#blog" title="孙亚洲的Blog" target="_blank">孙亚洲的Blog</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#字符编码"><span class="nav-number">1.</span> <span class="nav-text">字符编码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ASCII-（NSASCIIStringEncoding）"><span class="nav-number">1.1.</span> <span class="nav-text">ASCII （NSASCIIStringEncoding）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UNICODE-NSUnicodeStringEncoding"><span class="nav-number">1.2.</span> <span class="nav-text">UNICODE (NSUnicodeStringEncoding)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UTF-8-（NSUTF8StringEncoding）"><span class="nav-number">1.3.</span> <span class="nav-text">UTF-8 （NSUTF8StringEncoding）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UTF-16-（NSUTF16StringEncoding）"><span class="nav-number">1.4.</span> <span class="nav-text">UTF-16 （NSUTF16StringEncoding）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UTF-16大端-小端（NSUTF16BigEndianStringEncoding-NSUTF16LittleEndianStringEncoding）"><span class="nav-number">1.5.</span> <span class="nav-text">UTF-16大端/小端（NSUTF16BigEndianStringEncoding/NSUTF16LittleEndianStringEncoding）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UTF-32"><span class="nav-number">1.6.</span> <span class="nav-text">UTF-32</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Base64编码"><span class="nav-number">2.</span> <span class="nav-text">Base64编码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哈希散列算法"><span class="nav-number">3.</span> <span class="nav-text">哈希散列算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MD5算法"><span class="nav-number">3.1.</span> <span class="nav-text">MD5算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MD5算法安全性"><span class="nav-number">3.1.1.</span> <span class="nav-text">MD5算法安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于加盐"><span class="nav-number">3.1.2.</span> <span class="nav-text">关于加盐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SHA1"><span class="nav-number">3.2.</span> <span class="nav-text">SHA1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SHA2"><span class="nav-number">3.3.</span> <span class="nav-text">SHA2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HMac"><span class="nav-number">3.4.</span> <span class="nav-text">HMac</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">3.5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法实现"><span class="nav-number">3.6.</span> <span class="nav-text">算法实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对称加密算法"><span class="nav-number">4.</span> <span class="nav-text">对称加密算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#加密方法"><span class="nav-number">4.1.</span> <span class="nav-text">加密方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加密模式"><span class="nav-number">4.2.</span> <span class="nav-text">加密模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ECB-模式"><span class="nav-number">4.2.1.</span> <span class="nav-text">ECB 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CBC模式"><span class="nav-number">4.2.2.</span> <span class="nav-text">CBC模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#块大小和填充方式"><span class="nav-number">4.3.</span> <span class="nav-text">块大小和填充方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PKCS7Padding填充"><span class="nav-number">4.3.1.</span> <span class="nav-text">PKCS7Padding填充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zero-Padding（No-Padding）"><span class="nav-number">4.3.2.</span> <span class="nav-text">Zero Padding（No Padding）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几种算法比较"><span class="nav-number">4.4.</span> <span class="nav-text">几种算法比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOS-代码实现解析"><span class="nav-number">4.5.</span> <span class="nav-text">IOS 代码实现解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说明和总结"><span class="nav-number">4.6.</span> <span class="nav-text">说明和总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#非对称加密算法"><span class="nav-number">5.</span> <span class="nav-text">非对称加密算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RSA算法"><span class="nav-number">5.1.</span> <span class="nav-text">RSA算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#国密算法SM2"><span class="nav-number">5.2.</span> <span class="nav-text">国密算法SM2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SM2的加密流程"><span class="nav-number">5.2.1.</span> <span class="nav-text">SM2的加密流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加密步骤说明："><span class="nav-number">5.2.1.1.</span> <span class="nav-text">加密步骤说明：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SM2解密流程"><span class="nav-number">5.2.2.</span> <span class="nav-text">SM2解密流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解密步骤说明"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">解密步骤说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KDF算法说明："><span class="nav-number">5.2.3.</span> <span class="nav-text">KDF算法说明：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HASH算法说明"><span class="nav-number">5.2.4.</span> <span class="nav-text">HASH算法说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结："><span class="nav-number">5.2.5.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结-2"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考："><span class="nav-number">7.</span> <span class="nav-text">参考：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bolei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

</body>
</html>
